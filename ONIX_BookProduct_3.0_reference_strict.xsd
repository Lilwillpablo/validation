<?xml version="1.0" encoding="UTF-8"?>
<!--

	**************************************************
	*                                                *
	*               ONIX INTERNATIONAL               *
	*                                                *
	*     BOOK PRODUCT INFORMATION MESSAGE SCHEMA    *
	*                                                *
	*                STRUCTURE MODULE                *
	*               W3C XSD 1.1 SCHEMA               *
	*          STRICT REFERENCE TAG VERSION          *
	*                                                *
	*          Original author: Francis Cave         *
	*          Recent revisions: Graham Bell         *
	*                                                *
	*                  Release 3.0                   *
	*               Revision 8 Strict                *
	*                Status: RELEASED                *
	*            Release date: 2009-04-26            *
	*              Revised: 2021-08-08               *
	*                                                *
	*             (c) 2000-2021 EDItEUR              *
	*             http://www.editeur.org/            *
	*                                                *
	**************************************************


	TERMS AND CONDITIONS OF USE OF THE ONIX for Books PRODUCT INFORMATION FORMAT AND
	ASSOCIATED XML SCHEMAS

	All ONIX standards and documentation – including this document – are copyright
	materials, made available free of charge for general use. A full license agreement
	(DOI: 10.4400/nwgj) that governs their use is available on the EDItEUR website. In
	particular, if you use any of the ONIX for Books Product Information Format schemas
	(RNG, XSD or DTD) (‘the schemas’), you will be deemed to have accepted these terms
	and conditions:

	1. You agree that you will not add to, delete from, amend or copy for use outside of
	the schemas any part thereof except for strictly internal use in your own organization.

	2. You agree that if your business would benefit from future additions or amendments
	to or extracts of the schemas for any purpose that is not strictly internal to your own
	organisation, you will in the first instance notify EDItEUR and allow EDItEUR to review
	and comment on your proposed use, in the interest of securing an orderly
	development of the Schema for the benefit of other users.

	If you do not accept these terms, you must not use any version of the ONIX Product
	Information Message Schemas.

	Full copies of all published versions of the latest release of this Schema and all
	associated documentation are available from the EDItEUR web site, where may also be
	found details of how to contact EDItEUR for advice on the use of this Schema. The URL
	for the EDItEUR web site is:

	https://www.editeur.org/


	SCHEMA REVISION HISTORY (IN REVERSE CHRONOLOGICAL ORDER)

	2021-08-20: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure URIs do not contain spaces
	               b. modified rule _20171218_d_9 to remove X (unknown) options – although valid *internally*, they should never be sent to others

	2021-08-06: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure <SubjectCode> is supplied for coded subject schemes
	               b. ensure <SubjectHeadingText> is supplied for non-coded schemes
	               c. added plausibility check for Dewey (inc segmentation marks) and Abridged Dewey subject codes
	               d. ensure SpecificationFeaureValue paper color is from List 257
	               e. ensure SpecificationFeatureValue special finish is from List 258
	               f. ensure ResourceFileFeatureValue file type is from List 178
	               g. Updated second order codelist 203 for Issue 54

	2021-04-29: ONIX for Books 3.0 revision 8
	            1. added <ProductionDetail> block
	            2. added <AudienceHeadingText> in <Audience>
	            3. added <SupportingResource> in <PromotionalEvent> and <EventOccurrence>
	            4. added <TelephoneNumber> in <SupplyContact>, <ProductContact>, <Sender>, <Addressee>
	            5. added selected rule based assertions using XSD 1.1
	               a. ensure repeated textual data elements have unique language attributes in <PromotionalEvent> and <EventOccurrence>
	               b. modified rule 20171208a to also check language attributes on <WebsiteLink>
	               c. in Schematron, added warning if ROWSalesRightsType is positive
	               d. in Schematron, added warning if IDTypename is longer than 50 characters
	               e. ensure EventIdentifiers have an IDTypeName if and only if proprietary
	               f. check FeatureValue formats for RGB and RGBA colours
	               g. check FeatureValue second order codelist 256
	               h. added proper unique IDs for all rules
	            6. Updated second order codelists for Issue 53

	2021-03-02: added selected rule-based assertions using XSD 1.1
	            a. ContributorPlaceRelator 08 cannot be used with region codes
	            b. ensure ProductIdentifier present in ProductionManifest if and only if ProductPart is present
	            c. ensure all Resources in Cover, Body, InsertManifests have sequence numbers, or all omit sequence numbers
	            d. ensure proprietary ResourceIdentifiers include IDTypeName
	            e. ensure Resource URIs do not contain empty hostnames
	            f. ensure a valid date according to the dateformat attribute or DateFormat in ResourceFileDate

	2021-01-25: updated second order codelists for Issue 52

	2020-12-18: correction to rule 20181113f, simplification of Lexile rule in 20171219g

	2020-10-20: updated second order codelists for Issue 51

	2020-07-09: updated second order codelist 139 for Issue 50

	2020-05-18: 1. added selected rule based assertions using XSD 1.1
	               a. modified rules 20171126b, 20171221j to differentiate between ISNI and ORCID
	               b. extended rule 20171218d to check BIC, Thema version numbers

	2020-04-13: 1. refactored DateOrDateTime pattern
	            2. added selected rule-based assertions using XSD 1.1
	               a. added UK SLC plausibility check to rule 20171218d
	            3. fixed bug in rule 20190710d which produced false errors with ContributorPlace

	2020-03-17: 1. added selected rule-based assertions using XSD 1.1
	               a. NameType can only be fictional in NameAsSubject
	            2. modified rules 20171126f, 20180118a for new character extent units
	            3. modified rule 20180308a for new diary/calendar product forms
	            4. updated second order codelist 139 for Issue 49

	2020-01-15: 1. added selected rule-based assertions using XSD 1.1
	               a. in Schematron, best practice is to include only one <Subject> composite with keywords
	               b. APA stock quantity code scheme is deprecated
	               c. in XSD, ensure ProductFormFeatureValue is an integer (or integer range) for game pieces, game players, playing time
	               d. in Schematron, added extended Latin, Cyrillic, Arabic, CJK character detection
	            2. modified rule 20180308a for new diary/calendar product forms
	            3. modified rule 20190410c to improve NFC detection
	            4. updated second order codelists 143, 184, 196 for Issue 48

	            (intentionally blank)

	2019-11-28: 1. added selected rule-based assertions using XSD 1.1
	               a. modified how Product composition affinities are expressed in rule 20180214a
	               b. ensure ContributorReference and Contributor sequence numbers are consecutive numbers starting at 1 in <PromotionalEvent>
	               c. ensure Promotional event contributor reference name identifiers exist elsewhere in the record
	               d. ensure UN chemical IDs match UNxxxx
	               e. additional rules in <ProductFormFeature>
	            2. fixed bug in rule 20171221e where there are multiple short descriptions

	2019-10-31: ONIX for Books 3.0 revision 7
	            1. added <PromotionalEvent> in <PromotionDetail> block
	            2. added <ProductClassificationTypeName> in <ProductClassification> composite
	            3. added <TextSourceDescription> in <TextContent> composite
	            4. added <RegionCode> and <PrizeRegion> to <Language> and <Prize> composites
	            5. modified <PrizeStatement> to accept (X)HTML markup (and added assertions)
	            6. modified cardinality of <CopyrightYear> in <CopyrightStatement>
	            7. added collationkey attribute to imprint, publisher, agent and supplier name
	            8. added selected rule-based assertions using XSD 1.1
	               a. DescriptiveDetail (block 1) and PublishingDetail (block 4) are mandatory unless record is a block update or deletion
	               b. ensure region is within country in Prize, Language,  EventOccurrence
	               c. extended rule 20181026a to ensure PromotionDetail is only empty in block updates
	               d. ensure ProductClassificationTypeName is supplied if and only if ProductClassificationType is sender’s own proprietary classification scheme
	               e. extended rules 20190426a, 20171219a to check requirements for version 3.0.7
	            9. updated second order codelists 139, 204 for Issue 47

	2019-07-10: 1. added selected rule-based assertions using XSD 1.1
	               a. either or both of ProductFormFeatureValue or ProductFormFeatureDescription must be present (with two exceptions)
	               b. products in multiple related product composites must be unique
	               c. added HTML best practice check in embedded Schematron
	               d. check specific contributor place relators can only be used with corporate contributors
	               e. extended rule 20180109b to check for correct use of ProductIdentifier and PublisherName
	               f. added plausibility check for ISAN in AVItemIdentifier
	               g. for CPSIA hazard warnings, certain ProductFormFeatureValues are mutually exclusive
	               h. No restrictions must be the only Sales restriction
	            2. updated second order codelists 139, 143, 196, 243 for Issue 46

	2019-04-26: ONIX for Books 3.0 revision 6
	            1. added <Measure> within <ProductPart>
	            2. made <WebsiteLink> repeatable, added @language
	            3. added selected rule-based assertions using XSD 1.1
	               a. added version number checks in embedded Schematron

	2019-04-10: 1. added selected rule-based assertions using XSD 1.1
	               a. extended rule 20171218d to check WGSneu and NUR code plausibility
	               b. extended rule 20171219a to check for ProductClassifications without Percents
	               c. added example best practice check using embedded Schematron (NFC, MessageNumber, ISBN as record reference)
	               d. ensure battery weight does not exceed product weight
	               e. ensure for batteries and other dangerous goods that ProductFormFeatureValue comes from codelist 242 and 243
	               f. ensure battery detail in ProductFormFeatureDescription matches '[int] x [num]V [optional text]'
	               g. ensure battery detail is consistent (eg rechargeable / non-rechargeable are mutually exclusive)
	            2. updated reference list of second order codelists: 28, 66, 76, 77, 90, 98, 99, 139, 143, 176, 184, 196, 203, 204, 220, 227, 238, 242, 243 for Issue 45

	2019-01-07: 1. added selected rule-based assertions using XSD 1.1
	               a. ONIX audience code must be consistent with Thema or BIC main subject code indicating for children or teenagers / education
	               b. ONIX audience code must be consistent with BISAC main subject code indicating for juveniles or young adults
	               c. ONIX audience code must be consistent with CBMC
	               d. Thema Interest qualifiers may only include one From… age
	               e. Thema or BIC main subject code must be consistent with single child/teen-onlyONIX audience code
	               f. Thema or BIC main subject code must be consistent with education-only ONIX audience code
	               g. Thema Narrative theme cannot be a main subject, and Narrative theme and Special feature must be accompanied by a subject code
	               h. FeatureValue must be from List 178 if ResourceVersionFeatureType is 01
	            2. modified rule 20180308b to check A- and B-format dimensions in cm as well as mm
	            3. added extra Schematron deprecation warnings for Codelists Issue 44

	2018-12-10: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure URIs do not contain empty hostnames
	               b. ensure either all ResourceLink URIs carry a language attribute, or none
	               c. ensure PartNumber is not used in a collection-level title
	               d. ensure PrimaryPart occurs no more than once
	               e. ensure Website description is included if role is Unspecified
	            2. modified rule 20180214a to ensure ProductPart is ONLY used with multi-item and multi-component products, and ProductComposition is consistent with ProductForm
	            3. modified rule 20180324f and 20180612a to allow different Digital exclusivity statements in different territories
	            4. extended rule 20171212d to ensure 979-ISBNs do not have an ISBN-10 equivalent

	2018-12-05: 1. update version to include fix noted below 2018-11-13 #3.
	            2. outstanding issue in 20180214b, if product placed *diagonally* inside packaging (rare false negative)

	2018-11-13: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure Collection SourceName is only used with ascribed collections
	               b. ensure NumberOfItemsOfThisForm is not used alongside ProductIdentifier (in ProductPart)
	               c. ensure LastPageNumber is after FirstPageNumber (assuming both are purely numeric)
	               d. ensure NumberOfPages is consistent with FirstPageNumber and LastPageNumber
	               e. ensure AVDuration is consistent with StartTime and EndTime
	               f. ensure FromLanguage and ToLanguage are only used with translators
	               g. ensure Publication date is no later than any Sales embargo (not deployed until next version)
	            2. fixed regex error in rule 20171218d for plausibility of BISAC regional themes
	            3. fixed logical error in rules 20180109a, 20180109e, 20180109f, 20180109g for comparing dates (not deployed until next version)
	            4. added extra dimension check in rule 20180214b for unpackaged dimensions
	            5. extended hierarchy checks in rule 20180308e to BIC and Thema qualifiers
	            6. added extra whitespace-only checks in rule 20180517b

	2018-10-26: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure Blocks 2, 3, 5 are only empty in block updates
	               b. ensure inc-tax prices do not have TaxExempt
	               c. ensure if secondary flap/cover copy included, primary copy must also be included
	               d. linear and weight measurements must be credible
	               e. ensure TimeRun/EndTime is after StartTime
	            2. removed assertion 20180720a (was ensure Block 2 is not empty)
	            3. added relevant existing rules to <AVItem> and <AVItemIdentifier>
	            4. added extra Schematron deprecation warnings for Codelists Issue 43

	2018-10-26: ONIX for Books 3.0 revision 5
	            1. added <AVItem> within <ContentItem>, as an alternative to <TextItem>
	            2. added <PalletQuantity> within <SupplyDetail>
	            3. added <TaxExempt/> empty element
	            4. ensure Blocks 2, 3, 5 can be blank

	2018-09-27: added selected rule-based assertions using XSD 1.1
	               a. ensure repeats of DiscountCoded each have a unique DiscountCodeType

	2018-07-20: 1. added selected rule-based assertions using XSD 1.1
	               a. invalidate empty blocks <CollateralDetail> and <RelatedMaterial>
	               b. ensure Pack quantity is not specified for electronic products
	            2. fixed Xerces-related bugs in rules 20180214l, 20180109g and 20180109f and 20180109e

	2018-06-22: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure repeats of Short or Long description, Promotional headline, Biographical note among repeats of TextContent each have a unique Audience (unless they also have a territory)
	            2. moved Schematron rules into a single <appinfo> block – speeds up validation, reduces required memory
	            3. various bugfixes to rule-based assertions, updated deprecations for Issue 42

	2018-06-12: various bugfixes to rule-based assertions

	2018-05-17: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure ASCII only characters used with textformat 07
	               b. ensure Flow elements are not empty
	               c. ensure only physical products have FSC, PEFC certification, or PCW claims
	               d. ensure BIC Discount Group codes are plausible
	               e. ensure Discount code type name is supplied if (and only if) discount code type is proprietary
	               f. ensure repeats of <ProductSupply> each have a <Market> composite
	               g. ensure repeats of <SalesRights> each have distinct lists of countries included and of regions included
	               h. ensure <PublishingStatus> is present, or that every market includes MarketPublishingStatus
	            2. corrected rule 20180214f to include possibility of positive ROW sales rights and to simplify logic
	            3. corrected rule 20171126a to include possibility that ISBN and GTIN for a product may be different
	            4. corrected rules 20171218b and c, 20180214f and l to avoid a Saxon issue with use of the preceding-sibling::axis
	            5. potential issue with rules in other parsers. All rules are tested in Saxon, but Xerces and Raptor may require minor changes
	            6. outstanding issue in 20180109a and 20180109e-g: dates are not checked at all if they are of different dateformat or if they are of the same dateformat but use different timezones (false positive, impact very low)
	            7. outstanding issue in 20171221e: string-length does not count length of embedded markup (child XML tags), and counts '&#233;' as six chars (false positive and false negative, impact low)
	            8. outstanding issue in 20180101a and b: assumptions about nesting of regions within countries fail if GB-EWS is used (other regions can nest within this region). Similar issue with ECZ (false negative, impact very low)
	            9. potential issue in 20180109h and 20180517g where regions excluded are not taken into account (false positive and false negative, impact low)
	           10. reference list of second order codelists: 28, 66, 76, 77, 90, 98, 99, 139, 143, 176, 184, 196, 203, 204, 220, 227, 238

	2018-03-24: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure region lies within country, if both included in <ContributorPlace>
	               b. ensure WORLD is not used as a region in <ContributorPlace>
	               c. ensure uniqueness of various repeatable <Bible> features
	               d. ensure <AncillaryContentDescription> is provided when the content type is 'see description'
	               e. ensure repeats of <AudienceRange> each have a unique <AudienceRangeQualifier>
	               f. ensure there is only one each of Table of contents, Index, Intro, Biog, Flap/cover text, OA statement, Digital exclusivity statement among the repeats of <TextContent>
	            2. replaced rule 20171221k with full list of codes from List 139, replaced placeholder rule 20180214l with completed rule (works with oXygen v20 and Saxon 9.8.0.8)

	2018-03-14: fixed Xerces-related issue in rule 20180101b

	2018-03-08: added selected rule-based assertions using XSD 1.1
	               a. ensure affinities for <ProductFormDetail> A101-12, A301–5, B101–7, B113–8, B131–3, B306, B412, B201-23, B301-3, B311-4, B201-7, P101-13 match the appropriate <ProductForm>
	               b. ensure appropriate <Measurements> for Rack size, A-, B-format, A4, A5
	               c. ensure <EditionType> UBR and ABR, LTE and ULP, NUM and UNN, STU and TCH, EXP and UXP do not co-exist
	               d. ensure ONIX adult content ratings are only provided for books aimed at the general adult audience
	               e. ensure BISAC, BIC, Thema codes are not accompanied by their less-precise ancestors

	2018-02-22: added selected rule-based assertions using XSD 1.1
	               a. ensure <NotificationType> is 05 when <DeletionText> is used

	2018-02-14: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure multi-item and multi-component products (product forms S*, certain X*) specify the contained items or components using ProductPart
	               b. ensure unpackaged dimension measurements are accompanied by packaged overall dimensions
	               c. ensure consistency between <PublishingStatus> and publication date
	               d. ensure consistency between <MarketPublishingStatus> and market date
	               e. ensure second order codelist is validated in ReligiousTextFeature
	               f. ensure every price has a territory within which it is valid (either explicitly, or as implied by market territory or sales rights territory)
	               g. ensure generic sales restrictions are described in <SalesRestrictionNote>, and ensure retailer-specific restrictions specify the outlet in <SalesOutlet>
	               h. ensure claimed PCW percentage is accompanied by a declaration that this is not PEFC- or FSC-certified
	               i. ensure multi-item products have product identifiers for their contained items within ProductPart
	               j. ensure that any group biography in P.14 is matched to multiple contributors
	               k. ensure that e-book and e-audio products do not have measurements
	               l. ensure market pub date is not earlier than 'global' publication date (placeholder)
	            2. added new codes in second order codelists for Issue 40 to relevant rules

	2018-02-02: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure Flow contains at least one non-white space character [in XHTML_subset_strict ONLY - not in release version] (affects <BiographicalNote>, <ContributorStatement> etc)
	               b. modified 20171208d to accept dates back to 1BC in <ContributorDate> and <SubjectDate> (only), renamed rule to 20180202b
	            2. and added selected rule-based deprecations using embedded Schematron
	               c. warning of deprecation of <AudienceCode>, <Conference>, <CurrencyZone>, <DateFormat>, <Reissue>, <PromotionContact>, <SalesRestriction> (as child of <PublishingDetail>), and <TelephoneNumber>, <FaxNumber> and <EmailAddress> (as children of <PublisherRepresentative> or <Supplier>)
	               d. warning of deprecation of individual codes from Lists 5, 16, 21, 27, 29, 30, 32, 44, 45, 47, 49, 64, 74, 79, 91, 92, 93, 96, 102, 158, 167, 175, 176
	            3. minor changes to some XSD 1.1 assertion error messages to improve clarity
	            4. fixed 20171208b to make PositionOnProduct in Price 'if and only if yes'
	            5. enforce 'if and only if' on PositionOnProduct in Price in main XSD

	2018-01-29: added selected rule-based assertions using XSD 1.1
	               a. ensure remaining second order codelists are validated in <ProductFormFeature>
	               b. ensure second order codelists are validated in <AudienceRange>
	               c. ensure values in <AudienceRangeValue> are (unsigned positive) integers (ages 0-120, wpm 0-1000)
	               d. ensure <AudienceRangeValues> run from lower to higher ages/grades/speeds
	               e. ensure second order codelists are validated in <ReturnsCode>
	               f. ensure no escaped markup in text elements with textformat 06, 07 (or no textformat attribute) NB escaped markup is defined as < character, possibly followed by /, followed by a letter followed by anything up to the next >
	               g. ensure textformat attribute uses only allowed values (other values were removed from codelist at issue 41 - removed rule at issue 46)
	               h. Pah! Can't use 'castable as List98' etc

	2018-01-22: changes to 20180109e-g to avoid comparisons when dates have different timezone

	2018-01-18: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure that ExtentValue matches HHH, HHHmm or HHHmmss specified in ExtentUnit
	            2. added friendly error messages in XPath comments

	2018-01-09: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure that if <StartDate> and <EndDate> are both present in <SalesRestriction>, end is later than start
	               b. ensure that a <SalesRestriction> does not occur when sales rights type is 'not for sale'
	               c. ensure that if there is a second occurrence of <AudienceRangePrecision> the first occurrence must be 03 and the second 04
	               d. ensure that if the same measurement is given in multiple units (eg in both mm and inches), that the conversion is correct (within a certain tolerance)
	               e. ensure that if <PriceDate> is repeated with from and to dates, then to is later than from
	               f. ensure that if <ContributorDate>, <SubjectDate> are repeated with birth and death dates, then death is later than birth
	               g. ensure that if <ContentDate> is repeated with from/to, availability from/to or associated from/to dates, then to is later than from
	               h. ensure any country included in a market is included in a salesright composite (or not excluded from WORLD) with type 01 or 02
	            2. Xerces parser is less forgiving than Saxon regarding use of ge, le and so on with nodes rather than atomic values. Changes to 20180109d, 20180109e, 20180109f, 20180109g to ensure compared values are atomic (ie the value of a node rather than the node itself). Fixes to other rules may be required

	2018-01-05: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure that every <Price> has a price type and a currency code unless a default type or code is provided in the header
	               b. ensure that repeats of <ProductRelationCode> are unique
	               c. ensure that repeats of <ResourceFeature> have a unique <ResourceFeatureType> (excepting types 05 and 06, which could be repeated)
	               d. ensure that repeats of <ResourceVersionFeature> have a unique <ResourceVersionFeatureType>
	               e. ensure that repeats of <ContentItem> have a unique <LevelSequenceNumber>
	            2. fixed minor issue in 20171212c and similar 'unique combination' rules using concat(), where proprietary ID type 'AB' with ID '123' and proprietary ID type 'AB1' with ID '23' are not treated as 'unique'. Fixed by using string-join((string,string,…),' '). Fix not necessary where all string parameters come from codelists (eg 20171212f)

	2018-01-01: 1. modified pattern for dt.NonEmptyString to ensure no leading or trailing whitespace
	            2. modified pattern for dates in 20171208d to accept only years from 1000 to 2099, and aligned with dt.Year, dt.YearOrYearRange, dt.DateOrDateTime
	            3. added selected rule-based assertions using XSD 1.1
	               a. ensure that <ROWSalesRightsType> is included if necessary (Questions 1, 2 and 3)
	               b. ensure that if a <Territory> with <RegionsIncluded> = WORLD exists, every CI and RI in other Territories is excluded from WORLD

	2017-12-21: added selected rule-based assertions using XSD 1.1
	               a. ensure that if <Tax> is used once (and once only) then <PriceAmount> must be <TaxableAmount> plus <TaxAmount>
	               b. ensure that if <Tax> is used more than once, then <PriceAmount> must be sum of multiple <TaxableAmount> plus <TaxAmount> pairs
	               c. ensure that if both <TaxableAmount> and <TaxRatePercent> are provided, that any provided <TaxAmount> is correct
	               d. ensure that repeated <AncillaryContent> composites where type ≠ 00 have a unique <AncillaryContentType>
	               e. ensure that short descriptions/annotations in <Text> are less than 350 characters
	               f. ensure that if <Territory> contains the combination of CI and RX together, then the excluded regions must be within the included countries (rule 1)
	               g. ensure that if <Territory> contains a combination of CI and RI, or CX and RX, together, then regions must be outside the countries (rules 2 and 3)
	               h. ensure that repeated <ContributorRoles> are unique
	               i. ensure that repeated <...Identifier> composites have a unique combination of ...IDType, IDTypeName and IDValue in <AddresseeIdentifier>, <AgentIdentifier>, <CollectionIdentifier>, <ConferenceSponsorIdentifier>, <EventSponsorIdentifier>, <CopyrightOwnerIdentifier>, <FundingIdentifier>, <ImprintIdentifier>, <LocationIdentifier>, <NameIdentifier>, <PriceIdentifier>, <ProductContactIdentifier>, <PublisherIdentifier>, <RecordSourceIdentifier>, <SalesOutletIdentifier>, <SenderIdentifier>, <SupplierIdentifier>, <SupplyContactIdentifier>, <TextItemIdentifier>, <WorkIdentifier>
	               j. ensure that identifiers consist of valid characters and correct check digit in <AgentIDType>, <LocationIdentifier>, <SupplierIdentifier> (proprietary, GLN, SAN), <CopyrightOwnerIdentifier>, <ConferenceSponsorIdentifier>, <EventSponsorIdentifier>, <ProductContactIdentifier>, <SupplyContactIdentifier> (proprietary, GLN, SAN, ISNI, ORCID, Ringgold, EIDR, Fundref), <PriceIdentifier>, <FundingIdentifier> (proprietary), <WorkIdentifier> (proprietary, ISBN-10, DOI, ISTC, ISBN-13), <TextItemIdentifier> (proprietary, GTIN-13, ISBN-13, DOI, ISTC)
	               k. ensure ONIX outlet ID in <SalesOutletIdentifier> is a plausible code from codelist 139

	2017-12-19: added selected rule-based assertions using XSD 1.1
	               a. ensure that repeated <ProductClassification> composites each have unique combination of <ProductClassificationType> and <ProductClassificationCode>, that where there are repeats with the same Type then every repeat has a <Percent>, and where there are Percentages of a particular type, they add up to 100 ± 0.5
	               b. ensure that <ProductClassificationCode> matches required syntax for WCO Harmonized System, UNSPSC, TARIC, CPA, NCM
	               c. ensure exc-tax prices do not have <Tax>
	               d. ensure that if <Tax> is repeated then <TaxableAmount> is included in each repeat
	               e. ensure ISBN-13, ISSN consist of valid characters and correct check digit, ensure DOIs look plausible in <CollectionIdentifier>. Also ensure IDTypeName is included if and only if <...IDType>  is proprietary
	               f. ensure ONIX audience code, audience content rating in AudienceCodeValue come from Lists 28, 203. Also ensure <AudienceCodeTypeName> is included if and only if <AudienceCodeType> is proprietary
	               g. ensure <ComplexityCode> matches required syntax of Fry, IoE, Lexile measure, F&amp;P level, ATOS
	               h. ensure that repeated <Complexity> composites have a unique <ComplexitySchemeIdentifier>

	2017-12-18: 1. added selected rule-based assertions using XSD 1.1
	               a. ensure that if <SubjectSchemeIdentifier> is proprietary then a scheme name is provided
	               b. ensure that repeated <Subject> composites have a unique combination of SubjectSchemeIdentifier, SubjectSchemeName(when = 24), SubjectSchemeVersion, SubjectCode, SubjectHeadingText(when code not present)
	               c. ensure that <MainSubject> occurs only once for each unique combination of SubjectSchemeIdentifier, SubjectSchemeName(when = 24), SubjectSchemeVersion
	               d. ensure Thema, BISAC, BIC, CLIL, CBMC codes match required patterns
	               e. ensure that if Thema, BIC, BISAC qualifiers exist, then subjects also exist
	               f. ensure repeated <Language> composites have unique combination of LanguageRole, LanguageCode, CountryCode and ScriptCode
	            2. rewrote 20171126b, 20171126c, 20171126e, 20171208a, 20171208d, 20171208f, 20171208g, 20171212a, 20171212b and others to avoid if () then else pattern and improve performance

	2017-12-16: added selected rule-based assertions using XSD 1.1
	               a. ensure repeated <EpubTechnicalProtections> are unique, and any <EpubTechnicalProtection> 00 occurs alone
	               b. ensure repeated <ProductFormDetails> are unique
	               c. ensure if <ProductFormFeatureType> is 31–35, <ProductFormFeatureValue> carries a correctly-formatted FSC and PEFC chain of custody number, and that there is only one certification of each type
	               d. ensure if <ProductFormFeatureType> is 01-02, <ProductFormFeatureValue> carries a colour from List 98, and that there is only one colour of each type
	               e. ensure if <ProductFormFeatureType> is 09, <ProductFormFeatureValue> carries correct accessibility details from list 196, and that each no value is repeated
	               f. ensure if <ProductFormFeatureType> is 04, <ProductFormFeatureValue> carries a material type from List 99, and that there is only one material type

	2017-12-15: corrected error in 20171208b, made LCCN pattern in 20171212a more precise

	2017-12-12: added selected rule-based assertions using XSD 1.1
	               a. ensure GTIN-14, ISMN-10 consist of valid characters and correct check digit in <ProductIdentifier>. Also check LCCN is 12 alphanumeric characters
	               b. ensure that DOIs and ISBN-As look plausible in <ProductIdentifier>
	               c. ensure repeated <ProductIdentifier> composites each have a unique combination of <ProductIDType>, <IDTypeName> and <IDValue>
	               d. ensure that ISBN-10s and ISBN-As are also provided as conventional ISBN/GTIN-13s, and same for ISMN-10 and ISMN/GTIN-13
	               e. ensure repeated <Barcode> composites each have a unique combination of <BarcodeType> and <PositionOnProduct>. Also if <BarcodeType> is 'not barcoded' then there is only one instance of <Barcode>
	               f. ensure repeated <Measure> composites each have a unique combination of <MeasureType> and <MeasureUnitCode>
	               g. ensure linear measurements use linear units, mass measurements use mass units in <Measure>
	               h. ensure <EpubUsageLimit> exists if and only if Status is 'restricted', and repeated <EpubUsageLimit> composites each have a unique <EpubUsageUnit>
	               i. ensure repeated <EpubUsageConstraint> composites each have a unique <EpubUsageType>
	               j. ensure <PriceConstraintLimit> exists if and only if Status is 'restricted', and repeated <PriceConstraintLimit> composites each have unique <PriceConstraintUnit>
	               k. ensure repeated <PriceConstraint> composites each have a unique <PriceConstraintType>

	2017-12-08: added selected rule-based assertions using XSD 1.1
	               a. ensure repeated textual data elements have unique language attributes in <MessageNote>, <DeletionText>, <ContributorDescription>, <ProfessionalPosition>, <WebsiteDescription>, <ContributorStatement>, <EditionStatement>, <ReligiousTextFeatureDescription>, <IllustrationsNote>, <AncillaryContentDescription>, <SubjectHeadingText>, <AudienceDescription>, <Text>, <FeatureNote>, <CitationNote>, <PublishingStatusNote>, <SalesRestrictionNote>, <MarketPublishingStatusNote>, <PriceTypeDescription>, <PromotionCampaign>, <InitialPrintRun>, <ReprintDetail>, <CopiesSold>, <BookClubAdoption>, <PrizeName>, <ListName>, <SourceTitle>, <LocationName>, <EpubLicenseName>, <EventName>, <EventAcronym>, <EventTheme>, <EventPlace>, <RatingUnits>, <ReturnsNote>, <PricePartDescription>
	               b. ensure if and only if any <PrintedOnProduct> is 'no' then <PositionOnProduct> must be omitted
	               c. ensure repeated <ProductContentTypes> are unique (and different from any <PrimaryContentType>)
	               d. ensure <Date> is a valid date, according to the relevant dateformat attribute or <DateFormat> in <ContentDate>, <ContributorDate>, <MarketDate>, <PriceDate>, <PublishingDate>, <SubjectDate>, <SupplyDate>
	               e. ensure repeats of <ContentDate>, <ContributorDate>, <MarketDate>, <PriceDate>, <PublishingDate>, <SubjectDate>, <SupplyDate> have unique <...DateRoles>
	               f. ensure a valid date according to the dateformat attribute in <ConferenceDate>, <CopyrightYear>, <EventDate>, <EndDate>, <ExpectedDate>, <ReissueDate>, <StartDate>, <ThesisYear>
	               g. ensure textformat attribute is 05 if there are child elements (ie XHTML markup) in <AncillaryContentDescription>, <AudienceDescription>, <BiographicalNote>, <BookClubAdoption>, <CitationNote>, <CopiesSold>, <ConferenceTheme> (deprecated), <ContributorDescription>, <ContributorStatement>, <EditionStatement>, <FeatureNote>, <IllustrationsNote>, <InitialPrintRun>, <MarketPublishingStatusNote>, <PrizeJury>, <PromotionCampaign>, <PromotionContact> (deprecated), <PublishingStatusNote>, <ReissueDescription> (deprecated), <ReligiousTextFeatureDescription>, <ReprintDetail>, <SalesRestrictionNote>, <Text>, <TitleStatement>, <WebsiteDescription>
	               h. ensure when <CountriesIncluded> and <RegionsIncluded> coexist in <Territory> that <RegionsIncluded> is not WORLD
	               i. ensure that if <CountriesIncluded> is omitted and either <CountriesExcluded> or <RegionsExcluded> occur, then <RegionsIncluded> must be WORLD
	               j. ensure RegionsExcluded does not contain WORLD
	               k. ensure repeats of <ContentAudience> have unique values
	               l. ensure repeated <Audience> composites each have a unique combination of code type, codename and code value

	2017-11-26: STRICT version of schema using XSD 1.1
	            added selected rule-based assertions using XSD 1.1
	               a. ensure <RecordReference> and ISBN are unique within file
	               b. ensure GLN, SAN, ISNI, ORCID consist of valid characters and correct check digit in <SenderIdentifier>, <AddresseeIdentifier>, <RecordSourceIdentifier>, <NameIdentifier>, <ImprintIdentifier>, <PublisherIdentifier>, and that DOIs (EIDR, FundRef) and Ringgold IDs look plausible. Also ensure IDTypeName is included if and only if <...IDType> is proprietary
	               c. ensure ISBN-10, GTIN-13, UPC, UPC+5, ISBN-13, ISMN-13 consist of valid characters and correct check digit in <ProductIdentifier>. Also ensure IDTypeName is included if and only if <...IDType> is proprietary
	               d. ensure Contributor sequence numbers are consecutive numbers starting at 1 in <DescriptiveDetail> (ordinary contributors), and in <Collection> and <ContentItem>
	               e. ensure repeated textual data elements have unique language attributes in <ProductFormDescription>, <ProductFormFeatureDescription>, <BiographicalNote>
	               f. ensure repeated <Extent> composites each have a unique combination of dimension and unit, and that unit is correct for dimension
	               g. ensure that 00 is not used in <SalesRightsType>
	               h. ensure country and region codes are not repeated within simpletypes CountryCodeList and RegionCodeList, and if the regionlist includes WORLD, it includes ONLY WORLD
	               i. ensure if and only if <BarcodeType> is 'not barcoded' then <PositionOnProduct> must be omitted
	               j. ensure repeated <EditionTypes> are unique

	2017-11-26: corrected content model for <InitialPrintRun> to match documentation

	2017-10-26: ONIX for Books 3.0 revision 4
	            1. added <SupplyContact> within <SupplyDetail>
	            2. added <PricePartDescription> in <Tax>
	            3. added <EpubTechnicalProtection> and <EpubLicense> in <Price>
	            4. modified <CollectionSequenceNumber> to accept hyphen for unordered levels in numbering hierarchy
	            5. added <Reserved> within <Stock>
	            6. added <Language> in <ContentItem>
	            7. used gp.authorship in <Collection> and <ContentItem>

	2017-10-19: corrected regex for dt.MultiLevelNumber

	2017-05-22: simplified expression of data model for <Territory>

	2016-04-25: ONIX for Books 3.0 revision 3
	            1. added Event as near-synonym for Conference
	               a. choose either elements labelled <Event…> OR <Conference…>, but cannot mix in one <Product> record
	               b. <EventRole> is mandatory, where <ConferenceRole> is optional and defaults to 01 (currently undefined) if omitted
	               c. <EventName>, <EventAcronym>, <EventTheme>, <EventPlace> are repeatable in parallel languages, where the <Conference> equivalents are not
	               d. <EventTheme> is simple string, whereas <ConferenceTheme> accepts XHTML for backward compatibility (though this is deprecated)
	            2. added <Territory> into <TextContent>, <CitedContent>, <SupportingResource> so that marketing collateral can be region-specific
	            3. added <ReviewRating> into <TextContent> and <CitedContent> to carry star ratings
	            4. added <AlternativeName>, <SubjectDate> and <ProfessionalAffiliation> into <NameAsSubject>
	            5. added <Funding> (including <FundingIdentifier>) into <Publisher> to identify grant funds for open access
	            6. added <RelatedProduct> within <ContentItem> to allow per-chapter citation lists
	            7. added <ProductIdentifier> within <Tax> to support German tax requirements
	            8. added <Gender> within gp.structured_name and gp.unstructured_name
	            9. added <ProductPackaging> into <ProductPart>
	           10. added <ReturnsNote> within <ReturnsConditions>
	           11. added <Prize> within <Contributor>
	           12. added <UnpricedItemType> within <Price>
	           13. added <PriceConstraint> within <Price>
	           14. added <OrderQuantityMinimum> and <OrderQuantityMultiple> within <Price>
	           15. relocated <UnnamedPersons> within <Contributor>, so an anonymous author can have a name identifier or an alternative name
	           16. for consistency, <LocationName> within <Stock> is repeatable if the language attribute is provided
	           17. for consistency, <LocationIdentifier> within <Stock> is repeatable
	           18. for consistency, added language attribute to <ResourceLink>

	2016-01-24: 1. enforce positive (>= 0), strict positive (> 0) or percentage (0..100) real numbers in various fields
	            2. enforce positive (0, 1, 2…) or strict positive (1, 2, 3…) integers in various fields

	               note these changes had been included in a 'strict' version of schema from 2015-01-24

	2015-07-29: corrected Flow to dt.NonEmptyString in ConferenceName to match documentation

	            (intentionally blank)

	2014-11-23: enforce 'either <ComponentTypeName> or <TitleDetail> or both' in <ContentItem>

	2014-06-29: added explicit mixed="true" to elements which are extended from Flow to avoid problems with some XML parsers

	2014-01-24: ONIX for Books 3.0 revision 2
	            1. added <NoPrefix> within <TitleElement>
	            2. added <LocationName> within <ContributorPlace>
	            3. added <Proximity> within <Stock> - uses List 215
	            4. changed cardinality of <StockQuantityCoded> to 1…n to allow coded values for OnOrder and CBO etc.
	            5. added <Velocity> within <Stock>
	            6. added <VelocityMetric> within <Velocity> - uses List 216
	            7. added <Rate> and <Proximity> within <Velocity>
	            8. added <SalesRestriction> within <SalesRights>
	            9. added <ProductIdentifier> within <PriceCondition>
	           10. added <PrizeStatement> within <Prize>
	           11. added <PriceIdentifier> within <Price>
	           12. added <PriceIDType> within <PriceIdentifier> - uses list 217
	           13. added <NoProduct/> to support explicitly empty delta updates
	           14. added <EpubLicense> composite after <EpubUsageConstraint>, to support e-book licenses
	           15. added <EpubLicenseName> inside <EpubLicense>
	           16. added <EpubLicenseExpression> inside <EpubLicense>
	           17. added <EpubLicenseExpressionType> within <EpubLicenseExpression> - uses list 218
	           18. added <EpubLicenseExpressionTypeName within <EpubLicenseExpression>
	           19. added <EpubLicenseExpressionLink> within <EpubLicenseExpression>
	           20. added <CopyrightType> within <CopyrightStatement> - uses list 219
	           21. added <SupplierCodeTypeName> in <SupplierOwnCoding>
	           22. added <ToQuantity> within <Discount>
	           23. changed cardinality on <PromotionCampaign>, <InitialPrintRun>, <CopiesSold>, <BookClubAdoption>, <PrizeName>, <ListName>, <SourceTitle>
	           24. added textformat attribute to <EditionStatement> and changed data type to flow
	           25. added language attribute to <SourceTitle>, <PartNumber>, ImprintName>, <CityOfPublication>, <ConferencePlace> and to 12 contributor name elements
	           26. added textscript attribute to <PartNumber>, <TitleText>, <TitlePrefix>, <TitleWithoutPrefix>, <Subtitle>
	           27. enforce '<ContributorStatement> must be preceded by <Contributor>' within <Collection> (ensures P.5 matches P.7)
	           28. enforce '<SourceTitle> mandatory except where <ListName> is present' in <CitedContent>

	2013-07-19  relax URI requirements to allow relative URIs

	2013-04-24  1. enforce 'either <ConferenceSponsorIdentifier>, or either a personal or corporate name, or both' in <ConferenceSponsor>
	            2. enforce 'either <NameIdentifier> alone, or personal name or corporate name with or without <NameIdentifier>, or <UnnamedPersons>' in <Contributor>, <AlternativeName> and <NameAsSubject>
	            3. corrected dt.NonEmptyString to dt.Decimal in <PriceAmount>
	            4. enforce http or ftp protocol in <ResourceLink>, http:// can be omitted in <Weblink>
	            5. enforce at least one non-whitespace character in dt.NonEmptyString

	2013-01-25  1. corrected long-standing error in the content model of <TextContent>: <TextAuthor> is repeatable
	            2. enforce 'either <TaxRatePercent> or <TaxAmount>, or both' in <Tax>
	            3. enforce URIs cannot be empty strings (must contain '://')
	            4. escaped hyphen in dt.EmailString regex to avoid issue with SAX parser

	2012-10-25  1. enforce 'either <CopyrightOwnerIdentifier> or a personal or corporate name, or both' in <CopyrightOwner>
	            2. enforce 'either <SubjectCode> or <SubjectHeadingText> or both' in <Subject>
	            3. enforce 'at least one of <PartNumber>, <YearOfAnnual>, or either <TitleText> or <TitlePrefix> plus <TitleWithoutPrefix>' in <TitleElement>
	            4. enforce '<PublishingStatusNote must be preceded by the <PublishingStatus> element'
	            5. enforce '<ROWSalesRightsType> must be preceded by a <SalesRights> element'
	            6. modify <RelatedProduct> to disallow <ProductFormDetail> without <ProductForm>
	            7. changed xs:token to xs:string in dt.DateOrDateTime, dt.Year, dt.YearOrYearRange, dt.MultiLevelNumber and releaseAttribute (token will validate even when there is leading or trailing whitespace)
	            8. changed dt.NonEmptyString to dt.Integer in ConferenceNumber, LatestReprintNumber, NumberOfPages, OrderTime, PackQuantity
	            9. changed dt.NonEmptyString to dt.RomanNumeralString in ExtentValueRoman
	           10. added type="xs:string" to collationkeyAttribute
	           11. validation of e-mail addresses via dt.EmailString type

	               note changes 1-11 above enforce limitations already expressed clearly in the documentation

	2012-04-20: 1. corrected long-standing error in content model of <CitedContent>: <PositionOnList> is optional
	            2. enforce 'either <SenderIdentifier> or <SenderName>, or both' in <Sender>
	            3. enforce 'either <AddresseeIdentifier> or <AddresseeName>, or both' in <Addressee>
	            4. enforce 'if used, either <TitleText> or <TitlePrefix> with <TitleWithoutPrefix>' in <TitleElement>
	            5. enforce 'either <CountryCode> or <RegionCode>' in <ContributorPlace>. Note 'both' should probably not be an option, but is allowed (see change of 2009-12-22)
	            6. enforce 'if used, <EditionVersionNumber> must be preceded by <EditionNumber>'
	            7. enforce 'either <ExtentValue> or <ExtentValueRoman>, or both' in <Extent>
	            8. enforce 'either <ImprintIdentifier> or <ImprintName>, or both' in <Imprint>
	            9. enforce 'either <PublisherIdentifier> or <PublisherName>, or both' in <Publisher>
	           10. enforce 'either <ProductContactIdentifier> or <ProductContactName>, or both' in <ProductContact> (fixes cardinality limitation inadvertently introduced 2012-01-27)
	           11. enforce 'either <CountriesIncluded> or <RegionsIncluded>, or both' in <Territory>, and enforce limits on use of <CountriesExcluded> and <RegionsExcluded>
	           12. enforce 'either <SalesOutletIdentifier> or <SalesOutletName>, or both' in <SalesOutlet>
	           13. enforce 'either <AgentIdentifier> or <AgentName>, or both' in <PublisherRepresentative>
	           14. enforce 'either <SupplierIdentifier> or <SupplierName>, or both' in <Supplier>
	           15. enforce 'either <SupplierIdentifier> or <SupplierName>, or both' in <NewSupplier>
	           16. enforce 'either <ProfessionalPosition> or <Affiliation>, or both' in <ProfessionalAffiliation>
	           17. enforce 'either <NumberOfItemsOfThisForm> or <NumberOfCopies>, or both', in <ProductPart>. Note 'both' should probably not be an option, but is allowed
	           18. enforce 'either <DiscountPercent> or <DiscountAmount>, or both', in <Discount>

	               note changes 2–18 above (and 10 below) enforce limitations expressed clearly in the documentation, but make the schema a little
	               more complex, and may cause issues when automatically creating object classes from the schema

	2012-01-27: ONIX for Books 3.0 revision 1
	            1. added collationkey and textscript attributes
	            2. added <CollectionSequence> composite
	            3. added <SequenceNumber> within <TitleElement>
	            4. added <TitleStatement> within <TitleDetail>
	            5. added <ProductContact> composite
	            6. modified <ThesisYear> to take dateformat attribute
	            7. modified <MessageNote> and <AudienceCodeTypeName> to take language attribute
	            8. modified cardinality of <MessageNote>, <DeletionText>, <ProductFormFeatureDescription>, <ProductFormDescription>, <BiographicalNote>, <ContributorDescription>, <ProfessionalPosition>, <WebsiteDescription>, <ContributorStatement>, <EditionStatement>, <ReligiousTextFeatureDescription>, <IllustrationsNote>, <AncillaryContentDescription>, <SubjectHeadingText>, <AudienceDescription>, <Text>, <FeatureNote>, <CitationNote>, <PrizeJury>, <PublishingStatusNote>, <SalesRestrictionNote>, <MarketPublishingStatusNote>, <PriceTypeDescription>
	            9. added <ContributorStatement> within <Collection>
	           10. enforce 'either <Imprint> or <Publisher>, or both' to match documentation

	2011-11-03: corrected cardinality of <ComparisonProductPrice>

	2011-10-21: changed XML namespace to http://ns.editeur.org/onix/3.0/reference

	2011-07-15: 1. simplified DateOrDateTime format, with minor correction in line with documentation
	            2. corrected data type of EditionNumber to Integer in line with documentation

	2011-05-31: corrected cardinality of <Territory> within <SalesRights> to 1 (from 1…n) to match documentation (reverts change of 2010-05-20)

	2011-05-05: 1. added textformat attribute to <InitialPrintRun> to match documentation
	            2. added language attribute to <DeletionText> to match documentation
	            3. removed textformat attribute from <ConferenceName> to match documentation

	2010-11-25: Short tag name for element MarketPublishingStatusNote changed from x408 to x406

	2010-10-29: 1. new ROWSalesRightsType element added
	            2. cardinality of SupplyDetail and Supplier corrected
	            3. new CorporateNameInverted element added
	            4. new dateformat attribute added to date-related elements
	            5. DateFormat elements made optional, in favour of using new attribute
	            6. cardinality of NameType element changed within NameAsSubject
	            7. content model of RelatedProduct changed to include ProductForm and ProductFormDetail
	            8. cardinality of ProductRelationCode element changed
	            9. new MarketPublishingStatusNote element added
	           10. cardinality of MarketDate element changed
	           11. new PriceCoded composite added, as an alternative to PriceAmount
	           12. new ComparisonProductPrice composite added

	2010-05-20: 1. Content model of SalesRights corrected to make Territory repeatable
	            2. Content model of SupplyDate corrected to make DateFormat mandatory

	2009-12-22: 1. Data type 'NonEmptyString' corrected
	            2. Pattern 'YearOrYearMonth' corrected
	            3. Content model of ContributorPlace changed to allow both CountryCode and RegionCode

	2009-09-18: Content model of UnnamedPersons corrected

	2009-08-12: 1. Top-level element tag name changed to 'ONIXMessage'
	            2. Pattern 'CountryCodeList' corrected to allow multiple code values
	            3. Pattern 'RegionCodeList' corrected to allow multiple code values
	            4. Pattern 'DateOrDateTime' changed to allow omission of seconds

	2009-07-17: Mandatory 'release' attribute added to top-level element

	2009-05-11: Content model of MarketPublishingDetail corrected

	2009-04-09: Release 3.0 schema for public release

-->
<xs:schema xmlns="http://ns.editeur.org/onix/3.0/reference" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" xmlns:sch="http://purl.oclc.org/dsdl/schematron" vc:minVersion="1.1" elementFormDefault="qualified" targetNamespace="http://ns.editeur.org/onix/3.0/reference" xpathDefaultNamespace="##defaultNamespace">
	<xs:include schemaLocation="ONIX_BookProduct_CodeLists.xsd"/>
	<xs:include schemaLocation="ONIX_XHTML_Subset.xsd"/>

	<xs:annotation>
		<xs:appinfo>
			<!-- sch:schema querybinding="xslt2" /> might have to uncomment if SCH assertions require XPath 2 -->
			<sch:ns prefix="onix" uri="http://ns.editeur.org/onix/3.0/reference"/>
			<!-- Deprecations -->
			<sch:pattern>
				<sch:rule context="//onix:AddresseeIDType | //onix:ConferenceSponsorIDType | //onix:CopyrightOwnerIDType | //onix:EventSponsorIDType | //onix:ImprintIDType | //onix:NameIDType | //onix:ProductContactIDType | //onix:PublisherIDType | //onix:RecordSourceIDType | //onix:SenderIDType | //onix:SupplyContactIDType">
					<sch:report role="warn" id="_20180202_d_1" test=". eq '02'">Warning: Code 02 is deprecated (for Proprietary, use code 01 instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_2" test=". eq '17'">Warning: PND is deprecated (use GND instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_3" test=". eq '20'">Warning: GKD is deprecated (use GND instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:AgentIDType | //onix:SupplierIDType | //onix:LocationIDType">
					<sch:report role="warn" id="_20180202_d_4" test=". eq '02'">Warning: Code 02 is deprecated (for Proprietary, use code 01 instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:AudienceCode">
					<sch:report role="warn" id="_20180202_c_1" test="true()">Warning: AudienceCode is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:AudienceCodeType">
					<sch:report role="warn" id="_20180202_d_5" test=". eq '19'">Warning: Lexile is deprecated here (use Complexity instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_6" test=". eq '20'">Warning: Fry is deprecated here (use Complexity instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_7" test=". eq '25'">Warning: IoE Band is deprecated here (use Complexity instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:AudienceRangeQualifier">
					<sch:report role="warn" id="_20180202_d_8" test=". eq '23'">Warning: Schulform is deprecated here (use Audience instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_9" test=". eq '24'">Warning: Bundesland is deprecated here (use Audience instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_10" test=". eq '25'">Warning: Ausbildungsberuf is deprecated here (use Audience instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:CompexitySchemeIdentifier">
					<sch:report role="warn" id="_20180202_d_11" test=". eq '01'">Warning: Lexile code is deprecated (use Lexile measure instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_12" test=". eq '02'">Warning: Lexile number is deprecated (use Lexile measure instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:Conference">
					<sch:report role="warn" id="_20180202_c_2" test="true()">Warning: Conference is deprecated (use Event instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:CountriesIncluded | //onix:CountriesExcluded | //onix:CountryCode | //onix:CountryOfPublication | //onix:CountryOfManufacture | //onix:PrizeCountry">
					<sch:report role="warn" id="_20180202_d_13" test="matches(., 'AN')">Warning: Netherlands Antilles is deprecated (use codes BQ, CW, SX instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_14" test="matches(., 'CS')">Warning: Serbia and Montenegro is deprecated (use codes ME, RS instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_15" test="matches(., 'YU')">Warning: Yugoslavia is deprecated (use codes ME, RS instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:CurrencyCode | //onix:DefaultCurrencyCode">
					<sch:report role="warn" id="_20180202_d_16" test=". eq 'AFA'">Warning: AFA is deprecated (replaced by AFN)</sch:report>
					<sch:report role="warn" id="_20180202_d_17" test=". eq 'BGL'">Warning: BGL is deprecated (replaced by BGN)</sch:report>
					<sch:report role="warn" id="_20180202_d_18" test=". eq 'CSD'">Warning: CSD is deprecated (replaced by RSD)</sch:report>
					<sch:report role="warn" id="_20180202_d_19" test=". eq 'GHC'">Warning: GHC is deprecated (replaced by GHS)</sch:report>
					<sch:report role="warn" id="_20180202_d_20" test=". eq 'MRO'">Warning: MRO is deprecated (replaced by MRU)</sch:report>
					<sch:report role="warn" id="_20180202_d_21" test=". eq 'ROL'">Warning: ROL is deprecated (replaced by RON)</sch:report>
					<sch:report role="warn" id="_20180202_d_22" test=". eq 'RUR'">Warning: RUR is deprecated (replaced by RUB)</sch:report>
					<sch:report role="warn" id="_20180202_d_23" test=". eq 'SRG'">Warning: SRG is deprecated (replaced by SRD)</sch:report>
					<sch:report role="warn" id="_20180202_d_24" test=". eq 'STD'">Warning: STD is deprecated (replaced by STN)</sch:report>
					<sch:report role="warn" id="_20180202_d_25" test=". eq 'TMM'">Warning: TMM is deprecated (replaced by TMT)</sch:report>
					<sch:report role="warn" id="_20180202_d_26" test=". eq 'TPE'">Warning: TPE is deprecated (replaced by USD)</sch:report>
					<sch:report role="warn" id="_20180202_d_27" test=". eq 'TRL'">Warning: TRL is deprecated (replaced by TRY)</sch:report>
					<sch:report role="warn" id="_20180202_d_28" test=". eq 'VEB'">Warning: VEB is deprecated (replaced by VEF)</sch:report>
					<sch:report role="warn" id="_20180202_d_29" test=". eq 'VEF'">Warning: VEF is deprecated (replaced by VES)</sch:report>
					<sch:report role="warn" id="_20180202_d_30" test=". eq 'YUM'">Warning: YUM is deprecated (replaced by CSD)</sch:report>
					<sch:report role="warn" id="_20180202_d_31" test=". eq 'ZMK'">Warning: ZMK is deprecated (replaced by ZMW)</sch:report>
					<sch:report role="warn" id="_20180202_d_32" test=". eq 'ZWD'">Warning: ZWD is deprecated (replaced by ZWL)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:CurrencyZone">
					<sch:report role="warn" id="_20180202_c_3" test="true()">Warning: CurrencyZone is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:DateFormat">
					<sch:report role="warn" id="_20180202_c_4" test="true()">Warning: DateFormat is deprecated (use the dateformat attribute instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:LanguageCode | //onix:DefaultLanguageOfText | //onix:FromLanguage | //onix:ToLanguage | //onix:Audience[onix:AudienceCodeType eq '27']/onix:AudienceCodeValue | //onix:*/@language">
					<sch:report role="warn" id="_20180202_d_33" test=". eq 'mol'">Warning: mol is deprecated (use rum instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_34" test=". eq 'scc'">Warning: scc is deprecated (use srp instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_35" test=". eq 'src'">Warning: scr is deprecated (use hrv instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:DescriptiveDetail">
					<sch:report role="warn" id="_20180308_e_1" test="some $code in (onix:Subject[onix:SubjectSchemeIdentifier eq '10']/onix:SubjectCode) satisfies (count(onix:Subject[onix:SubjectSchemeIdentifier eq '10'][starts-with(onix:SubjectCode, $code)]) gt 1)">Warning: A BISAC code and one of its ancestors should not both be assigned</sch:report>
					<sch:report role="warn" id="_20180308_e_2" test="some $code in (onix:Subject[matches(onix:SubjectSchemeIdentifier, '^(12|13|14|15|16|17)$')]/onix:SubjectCode) satisfies (count(onix:Subject[matches(onix:SubjectSchemeIdentifier, '^(12|13|14|15|16|17)$')][starts-with(onix:SubjectCode, $code)]) gt 1)">Warning: A BIC subject code or qualifier and one of its ancestors should not both be assigned</sch:report>
					<sch:report role="warn" id="_20180308_e_3" test="some $code in (onix:Subject[matches(onix:SubjectSchemeIdentifier, '^(93|94|95|96|97|98|99)$')]/onix:SubjectCode) satisfies (count(onix:Subject[matches(onix:SubjectSchemeIdentifier, '^(93|94|95|96|97|98|99)$')][starts-with(onix:SubjectCode, $code)]) gt 1)">Warning: A Thema subject code or qualifier and one of its ancestors should not both be assigned</sch:report>
				</sch:rule>
				<sch:rule context="//onix:EditionType">
					<sch:report role="warn" id="_20180202_d_36" test=". eq 'ALT'">Warning: Alternate is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:EmailAddress">
					<sch:report role="warn" id="_20180202_c_5" test="exists(parent::onix:PublisherRepresentative | parent::onix:Supplier)">Warning: EmailAddress is deprecated here (use &lt;ProductContact> or &lt;SupplyContact> instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:FaxNumber">
					<sch:report role="warn" id="_20180202_c_6" test="exists(parent::onix:PublisherRepresentative | parent::onix:Supplier)">Warning: FaxNumber is deprecated here</sch:report>
				</sch:rule>
				<sch:rule context="//onix:PriceConditionType">
					<sch:report role="warn" id="_20180202_d_37" test=". eq '10'">Warning: Code 10 is deprecated (use PriceConstraint instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ProductFormDetail">
					<sch:report role="warn" id="_20180202_d_38" test="matches(., '^(A201|A207)$')">Warning: Code <sch:value-of select="."/> is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ProductFormFeatureType">
					<sch:report role="warn" id="_20180202_d_39" test=". eq '11'">Warning: Code 11 is deprecated (use code 12 instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ProductFormFeature[onix:ProductFormFeatureType eq '06']/onix:ProductFormFeatureValue">
					<sch:report role="warn" id="_20180202_d_40" test="matches(., '^(05|06)$')">Warning: Code <sch:value-of select="."/> is deprecated (use code 13 instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ProductIDType">
					<sch:report role="warn" id="_20180202_d_41" test=". eq '02'">Warning: ISBN-10 is deprecated, except where providing historical information for compatibility with legacy systems</sch:report>
					<sch:report role="warn" id="_20180202_d_42" test=". eq '05'">Warning: ISMN-10 is deprecated, except where providing historical information for compatibility with legacy systems</sch:report>
				</sch:rule>
				<sch:rule context="//onix:PromotionContact">
					<sch:report role="warn" id="_20180202_c_7" test="true()">Warning: PromotionContact is deprecated (use ProductContact instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:PublishingRole">
					<sch:report role="warn" id="_20180202_d_43" test=". eq '08'">Warning: Code 08 is deprecated (use code 06 instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:PublishingStatus">
					<sch:report role="warn" id="_20180202_d_44" test=". eq '12'">Warning: Code 12 is deprecated (for Recalled, use code 15 instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:RegionsIncluded | //onix:RegionsExcluded | //onix:RegionCode">
					<sch:report role="warn" id="_20180202_d_45" test="matches(., '(CN-11|CN-12|CN-13|CN-14|CN-15|CN-21|CN-22|CN-23|CN-31|CN-32|CN-33|CN-34|CN-35|CN-36|CN-37|CN-41|CN-42|CN-43|CN-44|CN-45|CN-46|CN-50|CN-51|CN-52|CN-53|CN-54|CN-61|CN-62|CN-63|CN-64|CN-65)')">Warning: CN-11 to CN-92 are deprecated (use CN-letter codes from List 49 instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_46" test="matches(., '(CN-71|CN-91|CN-92)')">Warning: CN-11 to CN-92 are deprecated (prefer codes from List 91 instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_47" test="matches(., '(CN-TW|CN-HK|CN-MO)')">Warning: for CN-TW, CN-HK, CN-MO, prefer codes from List 91 instead</sch:report>
					<sch:report role="warn" id="_20180202_d_48" test=". eq 'GB-CHA'">Warning: GB-CHA is deprecated (use code from List 91 instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_49" test=". eq 'GB-IOM'">Warning: GB-IOM is deprecated (use code from List 91 instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_50" test=". eq 'GB-EWS'">Warning: GB-EWS is deprecated (use separate codes from List 49 instead)</sch:report>
					<sch:report role="warn" id="_20180202_d_51" test=". eq 'ECZ'">Warning: ECZ is deprecated (list countries individually instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:Reissue">
					<sch:report role="warn" id="_20180202_c_8" test="true()">Warning: Reissue is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ResourceContentType">
					<sch:report role="warn" id="_20180202_d_52" test=". eq '99'">Warning: Code 99 is deprecated (use EpubLicense instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ROWSalesRightsType | //onix:SalesRightsType">
					<sch:report role="warn" id="_20180202_d_53" test="matches(., '^(07|08)$')">Warning: Code <sch:value-of select="."/> is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:SalesOutletIDType">
					<sch:report role="warn" id="_20180202_d_54" test="(. eq '03') and matches(./following-sibling::onix:IDValue, '^(BDL|BIL|BLA|GOS|BRB|BRD|BRT|COP|ECH|HST|KNO|MYB|OYS|PST|RDB|RMB|TXR|VRG)$')">Warning: ONIX Retail outlet ID code <sch:value-of select="./following-sibling::onix:IDValue"/> is deprecated (retailer and brand are believed to be obsolete)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:SalesRestriction">
					<sch:report role="warn" id="_20180202_c_9" test="exists(parent::onix:PublishingDetail)">Warning: SalesRestriction is deprecated here</sch:report>
				</sch:rule>
				<sch:rule context="//onix:StockQuantityCodeType">
					<sch:report role="warn" id="_20200115_b_1" test=". eq '02'">Warning: Code 02 is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:SubjectSchemeIdentifier">
					<sch:report role="warn" id="_20180202_d_55" test=". eq '27'">Warning: SWD is deprecated</sch:report>
					<sch:report role="warn" id="_20180202_d_56" test=". eq '39'">Warning: Læreplaner is deprecated</sch:report>
				</sch:rule>
				<sch:rule context="//onix:SupplierRole">
					<sch:report role="warn" id="_20180202_d_57" test=". eq '05'">Warning: Code 05 is deprecated (use MarketPublishingDetail instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:TelephoneNumber">
					<sch:report role="warn" id="_20180202_c_10" test="exists(parent::onix:PublisherRepresentative | parent::onix:Supplier)">Warning: TelephoneNumber is deprecated here (use &lt;ProductContact> or &lt;SupplyContact> instead)</sch:report>
				</sch:rule>
				<sch:rule context="//onix:UnnamedPersons">
					<sch:report role="warn" id="_20180202_c_11" test="exists(preceding-sibling::onix:ContributorDate | preceding-sibling::onix:ProfessionalAffiliation | preceding-sibling::onix:Prize | preceding-sibling::onix:BiographicalNote | preceding-sibling::onix:Website | preceding-sibling::onix:ContributorDescription | preceding-sibling::onix:ContributorPlace)">Warning: UnnamedPersons is deprecated here</sch:report>
				</sch:rule>
				<sch:rule context="//onix:WorkIDType">
					<sch:report role="warn" id="_20180202_d_58" test=". eq '02'">Warning: ISBN-10 is deprecated, except where providing historical information for compatibility with legacy systems</sch:report>
				</sch:rule>
			</sch:pattern>
			<!-- Best practice warnings -->
			<sch:pattern>
				<sch:rule context="//onix:Header">
					<sch:report role="warn" id="_20190410_c_2" test="not(exists(onix:MessageNumber))">Best practice: inclusion of MessageNumber is strongly recommended, so recipients can detect missed messages</sch:report>
				</sch:rule>
				<sch:rule context="//onix:Product">
					<sch:report role="warn" id="_20190410_c_3" test="onix:RecordReference eq onix:ProductIdentifier[matches(onix:ProductIDType, '^(03|15)$')][1]/onix:IDValue">Best practice: use of only the ISBN or GTIN as a RecordReference is strongly discouraged, so recipients can reliably manage records for the same product from different sources</sch:report>
				</sch:rule>
				<sch:rule context="//onix:AncillaryContentDescription | //onix:AudienceDescription | //onix:BiographicalNote | //onix:BookClubAdoption | //onix:CitationNote | //onix:CopiesSold | //onix:ConferenceTheme | //onix:ContributorDescription | //onix:ContributorStatement | //onix:EditionStatement | //onix:EventDescription | //onix:FeatureNote | //onix:IllustrationsNote | //onix:InitialPrintRun | //onix:MarketPublishingStatusNote | //onix:PrizeJury | //onix:PrizeStatement | //onix:PromotionCampaign | //onix:PromotionContact | //onix:PublishingStatusNote | //onix:ReissueDescription | //onix:ReligiousTextFeatureDescription | //onix:ReprintDetail | //onix:SalesRestrictionNote | //onix:Text | //onix:TextSourceDescription | //onix:TitleStatement | //onix:VenueNote | //onix:WebsiteDescription">
					<sch:report role="warn" id="_20190710_c_1" test="count(descendant::*) ne count(descendant::onix:p | descendant::onix:br | descendant::onix:strong | descendant::onix:em | descendant::onix:b | descendant::onix:i | descendant::onix:cite | descendant::onix:ul | descendant::onix:ol | descendant::onix:li | descendant::onix:dl | descendant::onix:dt | descendant::onix:dd | descendant::onix:sup | descendant::onix:sub | descendant::onix:ruby | descendant::onix:rb | descendant::onix:rp | descendant::onix:rt)">Best Practice: use of XHTML tags outside basic set is not recommended</sch:report>
				</sch:rule>
				<sch:rule context="//onix:DescriptiveDetail">
					<sch:report role="warn" id="_20200115_a_1" test="count(onix:Subject[onix:SubjectSchemeIdentifier eq '20']) gt 1">Best practice: should only be a single Subject composite with a list of keywords</sch:report>
				</sch:rule>
				<sch:rule context="//onix:ROWSalesRightsType">
					<sch:report role="warn" id="_20210429_c_1" test="matches(., '^(01|02)$')">Best practice: use of ROWSalesRightsType to express positive rights (codes 01, 02) is not recommended</sch:report>
				</sch:rule>
			</sch:pattern>
			<!-- Version reports -->
			<sch:pattern>
				<sch:rule context="//onix:ONIXMessage">
					<sch:report role="info" id="_20190426_a_3" test="exists(onix:Product/onix:DescriptiveDetail/onix:Event | onix:Product/onix:CollateralDetail/onix:TextContent/onix:Territory | onix:Product/onix:CollateralDetail/onix:CitedContent/onix:Territory | onix:Product/onix:CollateralDetail/onix:SupportingResource/onix:Territory | onix:Product/onix:CollateralDetail/onix:TextContent/onix:ReviewRating | onix:Product/onix:CollateralDetail/onix:CitedContent/onix:ReviewRating | onix:Product/onix:DescriptiveDetail/onix:NameAsSubject/onix:AlternativeName | onix:Product/onix:DescriptiveDetail/onix:NameAsSubject/onix:SubjectDate | onix:Product/onix:DescriptiveDetail/onix:NameAsSubject/onix:ProfessionalAffiliation | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Funding | onix:Product/onix:ContentDetail/onix:ContentItem/onix:RelatedProduct | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:Tax/onix:ProductIdentifier | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Gender | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:AlternativeName/onix:Gender | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Gender | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:AlternativeName/onix:Gender | onix:Product/onix:DescriptiveDetail/onix:NameAsSubject/onix:Gender | onix:Product/onix:DescriptiveDetail/onix:NameAsSubject/onix:AlternativeName/onix:Gender | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Gender | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:AlternativeName/onix:Gender | onix:Product/onix:ContentDetail/onix:ContentItem/onix:NameAsSubject/onix:Gender | onix:Product/onix:ContentDetail/onix:ContentItem/onix:NameAsSubject/onix:AlternativeName/onix:Gender | onix:Product/onix:DescriptiveDetail/onix:ProductPart/onix:ProductPackaging | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:ReturnsConditions/onix:ReturnsNote | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Prize | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:UnpricedItemType | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:UnpricedItemType | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:PriceConstraint | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:PriceConstraint | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:OrderQuantityMinimum | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:OrderQuantityMultiple | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:UnnamedPersons[exists(preceding-sibling::onix:NameIdentifier | following-sibling::onix:AlternativeName | following-sibling::onix:ContributorDate | following-sibling::onix:ProfessionalAffiliation | following-sibling::onix:Prize | following-sibling::onix:BiographicalNote | following-sibling::onix:Website | following-sibling::onix:ContributorDescription)] | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:UnnamedPersons[exists(preceding-sibling::onix:NameIdentifier | following-sibling::onix:AlternativeName | following-sibling::onix:ContributorDate | following-sibling::onix:ProfessionalAffiliation | following-sibling::onix:Prize | following-sibling::onix:BiographicalNote | following-sibling::onix:Website | following-sibling::onix:ContributorDescription)] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:UnnamedPersons[exists(preceding-sibling::onix:NameIdentifier | following-sibling::onix:AlternativeName | following-sibling::onix:ContributorDate | following-sibling::onix:ProfessionalAffiliation | following-sibling::onix:Prize | following-sibling::onix:BiographicalNote | following-sibling::onix:Website | following-sibling::onix:ContributorDescription)] | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Stock/onix:LocationName[2] | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Stock/onix:LocationIdentifier[2] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:SupportingResource/onix:ResourceVersion/onix:ResourceLink/@language) and not(exists(onix:Product/onix:DescriptiveDetail/onix:ProductPart/onix:Measure | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:Tax/onix:PricePartDescription | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:Tax/onix:PricePartDescription | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:EpubTechnicalProtection | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:EpubTechnicalProtection | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:EpubLicense | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:EpubLicense | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Stock/onix:Reserved | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:ContributorStatement | onix:Product/onix:ContentDetail/onix:ContentItem/onix:NoContributor | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:NoContributor | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:CollectionSequence/onix:CollectionSequenceNumber[matches(., '-')] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:AVItem | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:PalletQuantity | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:TaxExempt | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:TaxExempt | onix:Product/onix:PromotionDetail | onix:Product/onix:DescriptiveDetail/onix:ProductClassification/onix:ProductClassificationTypeName | onix:Product/onix:DescriptiveDetail/onix:Language/onix:RegionCode | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeRegion | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/@textformat | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/child::* | onix:Product/onix:PublishingDetail/onix:Imprint/onix:ImprintName/@collationkey | onix:Product/onix:PublishingDetail/onix:Publisher/onix:PublisherName/@collationkey | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:AgentName/@collationkey | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:SupplierName/@collationkey | onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource))">Requires at least some features of ONIX 3.0.3</sch:report>
					<sch:report role="info" id="_20190426_a_4" test="exists(onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:Tax/onix:PricePartDescription | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:Tax/onix:PricePartDescription | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:EpubTechnicalProtection | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:EpubTechnicalProtection | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:EpubLicense | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:EpubLicense | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Stock/onix:Reserved | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:ContributorStatement | onix:Product/onix:ContentDetail/onix:ContentItem/onix:NoContributor | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:NoContributor | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:CollectionSequence/onix:CollectionSequenceNumber[matches(., '-')]) and not(exists(onix:Product/onix:DescriptiveDetail/onix:ProductPart/onix:Measure | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:AVItem | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:PalletQuantity | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:TaxExempt | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:TaxExempt | onix:Product/onix:PromotionDetail | onix:Product/onix:DescriptiveDetail/onix:ProductClassification/onix:ProductClassificationTypeName | onix:Product/onix:DescriptiveDetail/onix:Language/onix:RegionCode | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeRegion | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/@textformat | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/child::* | onix:Product/onix:PublishingDetail/onix:Imprint/onix:ImprintName/@collationkey | onix:Product/onix:PublishingDetail/onix:Publisher/onix:PublisherName/@collationkey | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:AgentName/@collationkey | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:SupplierName/@collationkey | onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource))">Requires at least some features of ONIX 3.0.4</sch:report>
					<sch:report role="info" id="_20190426_a_5" test="exists(onix:Product/onix:ContentDetail/onix:ContentItem/onix:AVItem | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:PalletQuantity | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Price/onix:TaxExempt | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Reissue/onix:Price/onix:TaxExempt) and not(exists(onix:Product/onix:DescriptiveDetail/onix:ProductPart/onix:Measure | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:PromotionDetail | onix:Product/onix:DescriptiveDetail/onix:ProductClassification/onix:ProductClassificationTypeName | onix:Product/onix:DescriptiveDetail/onix:Language/onix:RegionCode | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeRegion | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/@textformat | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/child::* | onix:Product/onix:PublishingDetail/onix:Imprint/onix:ImprintName/@collationkey | onix:Product/onix:PublishingDetail/onix:Publisher/onix:PublisherName/@collationkey | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:AgentName/@collationkey | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:SupplierName/@collationkey | onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource))">Requires at least some features of ONIX 3.0.5</sch:report>
					<sch:report role="info" id="_20190426_a_6" test="exists(onix:Product/onix:DescriptiveDetail/onix:ProductPart/onix:Measure | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink[2] | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:PublishingDetail/onix:Publisher/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:ContentDetail/onix:ContentItem/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Event/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Conference/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Contributor/onix:Website/onix:WebsiteLink/@language | onix:Product/onix:DescriptiveDetail/onix:Collection/onix:Contributor/onix:Website/onix:WebsiteLink/@language) and not(exists(onix:Product/onix:PromotionDetail | onix:Product/onix:DescriptiveDetail/onix:ProductClassification/onix:ProductClassificationTypeName | onix:Product/onix:DescriptiveDetail/onix:Language/onix:RegionCode | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeRegion | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/@textformat | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/child::* | onix:Product/onix:PublishingDetail/onix:Imprint/onix:ImprintName/@collationkey | onix:Product/onix:PublishingDetail/onix:Publisher/onix:PublisherName/@collationkey | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:AgentName/@collationkey | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:SupplierName/@collationkey | onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource))">Requires at least some features of ONIX 3.0.6</sch:report>
					<sch:report role="info" id="_20190426_a_7" test="exists(onix:Product/onix:PromotionDetail | onix:Product/onix:DescriptiveDetail/onix:ProductClassification/onix:ProductClassificationTypeName | onix:Product/onix:DescriptiveDetail/onix:Language/onix:RegionCode | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeRegion | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/@textformat | onix:Product/onix:CollateralDetail/onix:Prize/onix:PrizeStatement/child::* | onix:Product/onix:PublishingDetail/onix:Imprint/onix:ImprintName/@collationkey | onix:Product/onix:PublishingDetail/onix:Publisher/onix:PublisherName/@collationkey | onix:Product/onix:ProductSupply/onix:MarketPublishingDetail/onix:PublisherRepresentative/onix:AgentName/@collationkey | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:Supplier/onix:SupplierName/@collationkey) and not(exists(onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource | onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource))">Requires at least some features of ONIX 3.0.7</sch:report>
					<sch:report role="info" id="_20190426_a_8" test="exists(onix:Product/onix:ProductionDetail | onix:Header/onix:Sender/onix:TelephoneNumber | onix:Header/onix:Addressee/onix:TelephoneNumber | onix:Product/onix:PublishingDetail/onix:ProductContact/onix:TelephoneNumber | onix:Product/onix:ProductSupply/onix:SupplyDetail/onix:SupplyContact/onix:TelephoneNumber | onix:Product/onix:DescriptiveDetail/onix:Audience/onix:AudienceHeadingText | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:EventOccurrence/onix:SupportingResource | onix:Product/onix:PromotionDetail/onix:PromotionalEvent/onix:SupportingResource)">Requires at least some features of ONIX 3.0.8</sch:report>
					<sch:report role="info" id="_20200115_d_1" test="exists(descendant::*[matches(., '(\p{IsLatin-1Supplement}|\p{IsLatinExtended-A}|\p{IsLatinExtended-B}|\p{IsLatinExtended-C}|\p{IsLatinExtended-D}|\p{IsLatinExtendedAdditional}|[&#xAB30;-&#xAB6F;])')])">Message contains Latin extended (ie non-ASCII) characters</sch:report> <!-- &#xAB30;-&#xAB6F; is LatinExtended-E -->
					<sch:report role="info" id="_20200115_d_2" test="exists(descendant::*[matches(., '(\p{IsCyrillic}|\p{IsCyrillicSupplement}|\p{IsCyrillicExtended-A}|\p{IsCyrillicExtended-B}|[&#x1C80;-&#x1C8F;])')])">Message contains Cyrillic characters</sch:report> <!-- &#x1C80;-&#x1C8F; is CyrillicExtended-C -->
					<sch:report role="info" id="_20200115_d_3" test="exists(descendant::*[matches(., '(\p{IsArabic}|\p{IsArabicSupplement}|[&#x08A0;-&#x08FF;]|[&#xFB50;-&#xFDFF;]|[&#xFE70;-&#xFEFF;])')])">Message contains Arabic characters</sch:report> <!-- &#x08a0;-&#x08FF; is IsArabicExtended-A, &#xFB50;-&#xFDFF; and &#xFE70;-&#xFEFF; are rabic Prefentational Forms A and B -->
					<sch:report role="info" id="_20200115_d_4" test="exists(descendant::*[matches(., '\p{IsHebrew}')])">Message contains Hebrew characters</sch:report>
					<sch:report role="info" id="_20200115_d_5" test="exists(descendant::*[matches(., '(\p{IsHangulSyllables}|\p{IsHangulJamo}|\p{IsHangulJamoExtended-A}|\p{IsHangulJamoExtended-B})')])">Message contains Hangul characters</sch:report>
					<sch:report role="info" id="_20200115_d_6" test="exists(descendant::*[matches(., '(\p{IsCJKUnifiedIdeographs}|\p{IsCJKUnifiedIdeographsExtensionA}|\p{IsCJKUnifiedIdeographsExtensionB}|\p{IsCJKUnifiedIdeographsExtensionC}|\p{IsCJKUnifiedIdeographsExtensionD}|[&#x2B820;-&#x2CEAF;]|[&#x2CEB0;-&#x2EBEF;])')])">Message contains Hanzi / Kanji ideographs</sch:report> <!-- &#x2B820;-&#x2CEAF;, &#x2CEB0;-&#x2EBEF; are CJKUnifiedIdeographsExtensionE and CJKUnifiedIdeographsExtensionF -->
					<sch:report role="info" id="_20200115_d_7" test="exists(descendant::*[matches(., '(\p{IsHiragana}|\p{IsKatakana}|\p{IsKatakanaPhoneticExtensions})')])">Message contains Hiragana / Katakana characters</sch:report>
					<sch:report role="warn" id="_20190410_c_1" test="exists(descendant::*[matches(., '(\p{IsCombiningDiacriticalMarks}|\p{IsCombiningDiacriticalMarksSupplement}|[&#x1AB0;-&#x1AFF;])')])">Warning: Message is not Unicode NFC</sch:report> <!-- &#x1AB0;-&#x1AFF; is CombiningDiacriticalMarksExtended -->
				</sch:rule>
			</sch:pattern>
		</xs:appinfo>
	</xs:annotation>

	<xs:element name="ONIXMessage">
		<xs:annotation>
			<xs:documentation>Root element – the top level container within an ONIX message</xs:documentation>
			<xs:documentation>Added &lt;NoProduct> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Header"/>
				<xs:choice>
					<xs:element ref="NoProduct"/>
					<xs:element maxOccurs="unbounded" ref="Product"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ONIXMessage"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ONIXmessage"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:attributeGroup ref="releaseAttribute"/>
			<xs:assert id="_20171126_a_1" test="(: Repeats of Product must each have a unique RecordReference :) count(Product) eq count(distinct-values(Product/RecordReference))"/>
			<xs:assert id="_20171126_a_2" test="(: Repeats of Product with a GTIN/ISBN must each have a unique GTIN/ISBN :) count(Product[exists(ProductIdentifier[matches(ProductIDType, '^(03|15)$')])]) eq (count(distinct-values(Product/ProductIdentifier[ProductIDType eq '15']/IDValue)) + count(distinct-values(Product[not(exists(ProductIdentifier[ProductIDType eq '15']))]/ProductIdentifier[ProductIDType eq '03']/IDValue)))"/>
			<xs:assert id="_20180105_a_1" test="(: Every Price must include PriceType, unless a DefaultPriceType is specified in Header :) exists(Header/DefaultPriceType) or (every $price in Product/ProductSupply/SupplyDetail/Price satisfies exists($price/PriceType))"/>
			<xs:assert id="_20180105_a_2" test="(: Every Price must include Currency, unless a DefaultCurrencyCode is specified in Header :) exists(Header/DefaultCurrencyCode) or (every $price in Product/ProductSupply/SupplyDetail/Price satisfies exists($price/CurrencyCode))"/>
		</xs:complexType>
		<xs:unique name="Product_RecordReference_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:Product"/>
			<xs:field xpath="onix:RecordReference"/>
		</xs:unique>
	</xs:element>

	<xs:element name="ProductionDetail">                               <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Block 8, container for file manifests and manufacturing specifications</xs:documentation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductionManifest"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductionDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productiondetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210302_b_2" test="(: Every ProductionManifest must include a ProductIdentifier :) exists(ProductionManifest/ProductIdentifier) eq (every $manifest in ProductionManifest satisfies exists($manifest/ProductIdentifier))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductionManifest">                             <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Container for a file manifest and manufacturing specification for a product or product part</xs:documentation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductIdentifier"/>
				<xs:element minOccurs="0" ref="CoverManifest"/>
				<xs:element ref="BodyManifest"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="InsertManifest"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SupplementManifest"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductionManifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productionmanifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CoverManifest">                                  <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.product_specification"/>
				<xs:element maxOccurs="unbounded" ref="CoverResource"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CoverManifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="covermanifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210302_c_1" test="(: Repeats of CoverResource must each have a SequenceNumber, or must all omit a SequenceNumber :) not(exists(CoverResource/SequenceNumber)) or count(CoverResource/SequenceNumber) eq count(CoverResource)"/>
		</xs:complexType>
		<xs:unique name="Cover_SpecificationDetail_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Cover_SpecficationDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="BodyManifest">                                   <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.product_specification"/>
				<xs:element maxOccurs="unbounded" ref="BodyResource"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="BodyManifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="bodymanifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210302_c_2" test="(: Repeats of BodyResource must each have a SequenceNumber, or must all omit a SequenceNumber :) not(exists(BodyResource/SequenceNumber)) or count(BodyResource/SequenceNumber) eq count(BodyResource)"/>
		</xs:complexType>
		<xs:unique name="Body_SpecificationDetail_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Body_SpecficationDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="InsertManifest">                                 <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.product_specification"/>
				<xs:element ref="InsertPoint"/>
				<xs:element maxOccurs="unbounded" ref="InsertResource"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="InsertManifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="insertmanifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210302_c_3" test="(: Repeats of InsertResource must each have a SequenceNumber, or must all omit a SequenceNumber :) not(exists(InsertResource/SequenceNumber)) or count(InsertResource/SequenceNumber) eq count(InsertResource)"/>
		</xs:complexType>
		<xs:unique name="Insert_SpecificationDetail_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Insert_SpecificationDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="SupplementManifest">                             <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesOutlet"/>
				<xs:choice>
					<xs:sequence>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductIdentifier"/>
						<xs:element ref="ProductForm"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormDetail"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormDescription"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="Measure"/>
						<xs:element minOccurs="0" ref="CoverManifest"/>
						<xs:element ref="BodyManifest"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="InsertManifest"/>
					</xs:sequence>
					<xs:element ref="NoSupplement" />
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplementManifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplementmanifest"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationBundleName">                        <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<!-- always proprietary -->
				<xs:element ref="SpecificationBundleNameTypeName"/>
				<xs:element ref="SpecificationBundleNameValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SpecificationBundleName"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="specificationbundlename"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationBundleNameTypeName">                <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationBundleNameTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x558"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationBundleNameValue">                   <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationBundleNameValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x559"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationDetail">                            <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List248">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationDetail"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x560"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationFeature">                           <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SpecificationFeatureType"/>
				<xs:element minOccurs="0" ref="SpecificationFeatureValue"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SpecificationFeatureDescription"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SpecificationFeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="specificationfeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210806_d_1" test="(: Color in SpecificationFeatureValue must be from ONIX codelist 257 :) (SpecificationFeatureType ne '43') or matches(SpecificationFeatureValue, '^(BRW|WHT|OFW|CRE)$')"/>
			<xs:assert id="_20210806_e_1" test="(: Special finish in SpecificationFeatureValue must be from ONIX codelist 258 :) (SpecificationFeatureType ne '45') or matches(SpecificationFeatureValue, '^(01|02)$')"/>
		</xs:complexType>
		<xs:unique name="SpecificationFeatureDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SpecificationFeatureDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="SpecificationFeatureType">                       <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List249">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationFeatureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x561"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationFeatureValue">                      <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationFeatureValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x562"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationFeatureDescription">                <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationFeatureDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x563"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SpecificationDescription">                       <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SpecificationDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x564"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CoverResource">                                  <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesOutlet"/>
				<xs:choice>
					<xs:group ref="gp.resource_specification"/>
					<xs:element ref="NoResource"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CoverResource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="coverresource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
		<xs:unique name="Cover_ResourceFileDetail_must_be_unique"  xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Cover_ResourceFileLink_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileLink"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Cover_ResourceFileDateRole_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileDate"/>
			<xs:field xpath="onix:ResourceFileDateRole"/>
		</xs:unique>
	</xs:element>
	<xs:element name="BodyResource">                                   <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:group ref="gp.resource_specification"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="BodyResource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="bodyresource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
		<xs:unique name="Body_ResourceFileDetail_must_be_unique"  xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Body_ResourceFileLink_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileLink"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Body_ResourceFileDateRole_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileDate"/>
			<xs:field xpath="onix:ResourceFileDateRole"/>
		</xs:unique>
	</xs:element>
	<xs:element name="InsertResource">                                 <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesOutlet"/>
				<xs:choice>
					<xs:group ref="gp.resource_specification"/>
					<xs:element ref="NoResource"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="InsertResource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="insertresource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
		<xs:unique name="Insert_ResourceFileDetail_must_be_unique"  xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Insert_ResourceFileLink_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileLink"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Insert_ResourceFileDateRole_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileDate"/>
			<xs:field xpath="onix:ResourceFileDateRole"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ResourceIdentifier">                             <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ResourceIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="resourceidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210302_d_1" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (ResourceIDType eq '01') eq exists(IDTypeName)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceIDType">                                 <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List250">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x565"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceRole">                                   <!-- added 3.0.8 -->
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List251">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x566"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileDetail">                             <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List252">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileDetail"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x567"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileFeature">                            <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceFileFeatureType"/>
				<xs:element minOccurs="0" ref="ResourceFileFeatureValue"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFileFeatureDescription"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ResourceFileFeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="resourcefilefeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210806_f_1" test="(: File type in ResourceFileFeatureValue must be from ONIX Codelist 178 :) (ResourceFileFeatureType ne '01') or matches(ResourceFileFeatureValue, '^(A103|A104|A105|A106|A107|A108|A111|D101|D102|D103|D104|D105|D106|D107|D108|D109|D401|D501|D502|D503|D504|D505|D506|D507|D508|E101|E105|E107|E112|E113|E115|E116|E139|E140)$')"/>
		</xs:complexType>
		<xs:unique name="ResourceFileFeatureDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ResourceFileFeatureDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ResourceFileFeatureType">                        <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List253">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileFeatureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x568"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileFeatureValue">                       <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileFeatureValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x569"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileFeatureDescription">                 <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileFeatureDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x570"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileDescription">                        <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x571"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileContentDescription">                 <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileContentDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x576"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileLink">                               <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyURI">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileLink"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x572"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:assert id="_20210302_e_1" test="(: URI must not contain an empty hostname :) not(matches(., '///'))"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileDate">                               <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceFileDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ResourceFileDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="resourcefiledate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210302_f_1" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20210302_f_2" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20210302_f_3" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20210302_f_4" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20210302_f_5" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20210302_f_6" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20210302_f_7" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20210302_f_8" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20210302_f_9" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20210302_f_10" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20210302_f_11" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20210302_f_12" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20210302_f_13" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20210302_f_14" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFileDateRole">                           <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List254">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFileDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x573"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="InsertPoint">                                    <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="InsertPointType"/>
				<xs:element ref="InsertPointValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="InsertPoint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="insertpoint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="InsertPointType">                                <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List255">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="InsertPointType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x574"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="InsertPointValue">                               <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="InsertPointValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x575"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoResource">                                     <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoResource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x577"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceHeadingText">                            <!-- added 3.0.8 -->
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceHeadingText"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x578"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoSupplement">                                   <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoSupplement"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x579"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>

	<xs:group name="gp.product_specification">                         <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="SpecificationBundleName"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="SpecificationDetail"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="SpecificationFeature"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="SpecificationDescription"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.resource_specification">                        <!-- added 3.0.8 -->
		<xs:annotation>
			<xs:documentation>Added at 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceIdentifier"/>
			<xs:element minOccurs="0" ref="ResourceRole"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFileDetail"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFileFeature"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFileDescription"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFileContentDescription"/>
			<xs:element maxOccurs="unbounded" ref="ResourceFileLink"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFileDate"/>
		</xs:sequence>
	</xs:group>

	<xs:element name="Addressee">
		<xs:annotation>
			<xs:documentation>Added &lt;TelephoneNumber> at 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="AddresseeIdentifier"/>
						<xs:element minOccurs="0" ref="AddresseeName"/>
					</xs:sequence>
					<xs:element ref="AddresseeName"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="ContactName"/>
				<xs:element minOccurs="0" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" ref="EmailAddress"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Addressee"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="addressee"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_1" test="(: Repeats of AddresseeIdentifier must each have a unique combination of valid AddresseeIDType, IDTypeName and IDValue :) count(AddresseeIdentifier) eq count(distinct-values(AddresseeIdentifier/string-join((AddresseeIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AddresseeIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AddresseeIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AddresseeIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="addresseeidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_b_1" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(AddresseeIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_b_2" test="(: IDValue must be a valid GLN (invalid characters) :) (AddresseeIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_b_3" test="(: IDValue must be a valid GLN (check digit error) :) (AddresseeIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_b_4" test="(: IDValue must be a valid SAN (invalid characters) :) (AddresseeIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_5" test="(: IDValue must be a valid SAN (check digit error) :) (AddresseeIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_b_6" test="(: IDValue must be a valid ISNI (invalid characters) :) (AddresseeIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_7" test="(: IDValue must be a valid ISNI (check digit error) :) (AddresseeIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_8" test="(: IDValue must be a valid ORCID (invalid characters) :) (AddresseeIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_9" test="(: IDValue must be a valid ORCID (check digit error) :) (AddresseeIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_10" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) not(matches(AddresseeIDType, '^(27)$')) or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171126_b_11" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (AddresseeIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171126_b_12" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (AddresseeIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AddresseeIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AddresseeIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m380"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AddresseeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AddresseeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x300"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Affiliation">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Affiliation"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b046"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AgentIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AgentIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AgentIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="agentidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_1" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(AgentIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_2" test="(: IDValue must be a valid GLN (invalid characters) :) (AgentIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_3" test="(: IDValue must be a valid GLN (check digit error) :) (AgentIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_4" test="(: IDValue must be a valid SAN (invalid characters) :) (AgentIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_5" test="(: IDValue must be a valid SAN (check digit error) :) (AgentIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AgentIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List92">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AgentIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j400"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AgentName">
		<xs:annotation>
			<xs:documentation>Added collationkey attribute at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AgentName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j401"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AgentRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List69">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AgentRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j402"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AlternativeName">
		<xs:annotation>
			<xs:documentation>Added &lt;Gender> at revision 3.0.3</xs:documentation>
			<xs:documentation>Added &lt;CorporateNameInverted> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="NameType"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="NameIdentifier"/>
						<xs:choice minOccurs="0">
							<xs:sequence>
								<xs:group ref="gp.unstructured_name"/>
								<xs:group minOccurs="0" ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:sequence>
								<xs:group ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:group ref="gp.corporate_name"/>
						</xs:choice>
					</xs:sequence>
					<xs:sequence>
						<xs:choice>
							<xs:sequence>
								<xs:group ref="gp.unstructured_name"/>
								<xs:group minOccurs="0" ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:sequence>
								<xs:group ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:group ref="gp.corporate_name"/>
						</xs:choice>
					</xs:sequence>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AlternativeName"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="alternativename"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_2" test="(: Repeats of NameIdentifier must each have a unique combination of valid NameIDType, IDTypeName and IDValue :) count(NameIdentifier) eq count(distinct-values(NameIdentifier/string-join((NameIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AncillaryContent">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;AncillaryContentDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AncillaryContentType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="AncillaryContentDescription"/>
				<xs:element minOccurs="0" ref="Number"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AncillaryContent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ancillarycontent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180324_d_1" test="(: Description must be provided :) (AncillaryContentType ne '00') or exists(AncillaryContentDescription)"/>
			<xs:assert id="_20171208_a_1" test="(: Repeats of AncillaryContentDescription must each have a unique language attribute :) (count(AncillaryContentDescription) le 1) or count(AncillaryContentDescription) eq count(distinct-values(AncillaryContentDescription/@language))"/>
		</xs:complexType>
		<xs:unique name="AncillaryContentDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:AncillaryContentDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="AncillaryContentDescription">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AncillaryContentDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x424"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_1" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_2" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_1" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_1" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_1" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_1" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AncillaryContentType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List25">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AncillaryContentType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x423"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Audience">
		<xs:annotation>
			<xs:documentation>Added &lt;AudienceHeadingText> at 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AudienceCodeType"/>
				<xs:element minOccurs="0" ref="AudienceCodeTypeName"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="AudienceCodeValue"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="AudienceHeadingText"/>
					</xs:sequence>
					<xs:element maxOccurs="unbounded" ref="AudienceHeadingText"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Audience"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="audience"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171219_f_1" test="(: There must be an AudienceCodeTypeName if (and only if) AudienceCodeType is proprietary :) (AudienceCodeType eq '02') eq exists(AudienceTypeName)"/>
			<xs:assert id="_20171219_f_2" test="(: For ONIX audience codes, AudienceCodeValue must come from ONIX Codelist 28 :) (AudienceCodeType ne '01') or matches(AudienceCodeValue, '^(01|02|03|04|05|06|07|08|09)$')"/>
			<xs:assert id="_20171219_f_3" test="(: For ONIX content warnings, AudienceCodeValue must come from ONIX Codelist 203 :) (AudienceCodeType ne '22') or matches(AudienceCodeValue, '^(00|01|02|03|04|05|06|07|08|09)$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceCode">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Audience> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List28">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b073"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceCodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List29">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceCodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b204"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceCodeTypeName">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceCodeTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b205"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceCodeValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceCodeValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b206"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceDescription">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b207"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_3" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_4" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_2" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_2" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_2" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_2" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceRange">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AudienceRangeQualifier"/>
				<xs:element ref="AudienceRangePrecision"/>
				<xs:element ref="AudienceRangeValue"/>
				<xs:sequence minOccurs="0">
					<xs:element ref="AudienceRangePrecision"/>
					<xs:element ref="AudienceRangeValue"/>
				</xs:sequence>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AudienceRange"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="audiencerange"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180109_c_1" test="(: A second occurrence of AudienceRangePrecision must be 'To' (and the first must be 'From' ) :) not(exists(AudienceRangePrecision[2])) or (AudienceRangePrecision[1] eq '03' and AudienceRangePrecision[2] eq '04')"/>
			<xs:assert id="_20180129_b_1" test="(: US/Canadian school grade in AudienceRangeValue must be from ONIX Codelist 77 :) not(matches(AudienceRangeQualifier, '^(11|26)$')) or matches(AudienceRangeValue[1], '^(P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17)$')"/>
			<xs:assert id="_20180129_b_2" test="(: US/Canadian school grade in AudienceRangeValue 2 must be from ONIX Codelist 77 :) not(matches(AudienceRangeQualifier, '^(11|26)$')) or not(exists(AudienceRangeValue[2])) or matches(AudienceRangeValue[2], '^(P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17)$')"/>
			<xs:assert id="_20180129_b_3" test="(: Chinese school grade in AudienceRangeValue must be from ONIX Codelist 227 :) (AudienceRangeQualifier ne '29') or matches(AudienceRangeValue[1], '^(P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17)$')"/>
			<xs:assert id="_20180129_b_4" test="(: Chinese school grade in AudienceRangeValue 2 must be from ONIX Codelist 227 :) (AudienceRangeQualifier ne '29') or not(exists(AudienceRangeValue[2])) or matches(AudienceRangeValue[2], '^(P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17)$')"/>
			<xs:assert id="_20180129_b_5" test="(: Brazilian school grade in AudienceRangeValue must be from ONIX Codelist 238 :) (AudienceRangeQualifier ne '31') or matches(AudienceRangeValue[1], '^(K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|P|A|B|D|F)$')"/>
			<xs:assert id="_20180129_b_6" test="(: Brazilian school grade in AudienceRangeValue 2 must be from ONIX Codelist 238 :) (AudienceRangeQualifier ne '31') or not(exists(AudienceRangeValue[2])) or matches(AudienceRangeValue[2], '^(K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|P|A|B|D|F)$')"/>
			<xs:assert id="_20180129_c_1" test="(: Reading speed in AudienceRangeValue must be integer ≤ 1000 :) (AudienceRangeQualifier ne '15') or (matches(AudienceRangeValue[1], '^[1-9][0-9]*$') and number(AudienceRangeValue[1]) le 1000)"/>
			<xs:assert id="_20180129_c_2" test="(: Reading speed in AudienceRangeValue 2 must be integer ≤ 1000 :) (AudienceRangeQualifier ne '15') or not(exists(AudienceRangeValue[2])) or (matches(AudienceRangeValue[2], '^[1-9][0-9]*$') and number(AudienceRangeValue[2]) le 1000)"/>
			<xs:assert id="_20180129_c_3" test="(: Age in months in AudienceRangeValue must be integer ≤ 36 :) (AudienceRangeQualifier ne '16') or (matches(AudienceRangeValue[1], '^[1-9][0-9]*$') and number(AudienceRangeValue[1]) le 36)"/>
			<xs:assert id="_20180129_c_4" test="(: Age in months in AudienceRangeValue 2 must be integer ≤ 36 :) (AudienceRangeQualifier ne '16') or not(exists(AudienceRangeValue[2])) or (matches(AudienceRangeValue[2], '^[1-9][0-9]*$') and number(AudienceRangeValue[2]) le 36)"/>
			<xs:assert id="_20180129_c_5" test="(: Interest or reading age in AudienceRangeValue must be integer ≤ 120 :) not(matches(AudienceRangeQualfier, '^(17|18)$')) or (matches(AudienceRangeValue[1], '^[1-9][0-9]*$') and number(AudienceRangeValue[1]) le 120)"/>
			<xs:assert id="_20180129_c_6" test="(: Interest or reading age in AudienceRangeValue 2 must be integer ≤ 120 :) not(matches(AudienceRangeQualfier, '^(17|18)$')) or not(exists(AudienceRangeValue[2])) or (matches(AudienceRangeValue[2], '^[1-9][0-9]*$') and number(AudienceRangeValue[2]) le 120)"/>
			<xs:assert id="_20180129_d_1" test="(: US/Canadian school grade from ONIX Codelist 77 in AudienceRangeValue must be lower than AudienceRangeValue 2 :) not(matches(AudienceRangeQualifier, '^(11|26)$')) or not(exists(AudienceRangeValue[2])) or string-length(substring-before('P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17', AudienceRangeValue[1])) lt string-length(substring-before('P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17', AudienceRangeValue[2]))"/>
			<xs:assert id="_20180129_d_2" test="(: Chinese school grade from ONIX Codelist 227 in AudienceRangeValue must be lower than AudienceRangeValue 2 :) (AudienceRangeQualifier ne '29') or not(exists(AudienceRangeValue[2])) or string-length(substring-before('P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17', AudienceRangeValue[1])) lt string-length(substring-before('P|K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17', AudienceRangeValue[2]))"/>
			<xs:assert id="_20180129_d_3" test="(: Brazilian school grade from ONIX Codelist 238 in AudienceRangeValue must be lower than AudienceRangeValue 2 :) (AudienceRangeQualifier ne '31') or not(exists(AudienceRangeValue[2])) or string-length(substring-before('K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|P|A|B|D|F', AudienceRangeValue[1])) lt string-length(substring-before('K|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|P|A|B|D|F', AudienceRangeValue[2]))"/>
			<xs:assert id="_20180129_d_4" test="(: Age or Reading speed number in AudienceRangeValue must be less than AudienceRangeValue 2 :) not(matches(AudienceRangeQualifier, '^(15|16|17|18)$')) or not(exists(AudienceRangeValue[2])) or number(AudienceRangeValue[1]) lt number(AudienceRangeValue[2])"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceRangePrecision">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List31">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceRangePrecision"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b075"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceRangeQualifier">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List30">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceRangeQualifier"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b074"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AudienceRangeValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AudienceRangeValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b076"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AVDuration">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.TimeOrDuration">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AVDuration"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x544"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AVItem">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AVItemType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="AVItemIdentifier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TimeRun"/>
				<xs:element minOccurs="0" ref="AVDuration"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AVItem"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="avitem"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_3" test="(: Repeats of AVItemIdentifier must each have a unique combination of valid AVItemIDType, IDTypeName and IDValue :) count(AVItemIdentifier) eq count(distinct-values(AVItemIdentifier/string-join((AVItemIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20181113_e_1" test="(: AVDuration must be consistent with the StartTime and EndTime :) not(exists(TimeRun/EndTime) and exists(AVDuration)) or abs((3600 * number(substring(TimeRun/EndTime, 1, 3)) + 60 * number(substring(TimeRun/EndTime, 4, 2)) + number(substring(TimeRun/EndTime, 6, 2)) + 0.01 * number(substring(concat(TimeRun/EndTime, '00'), 8, 2))) - (3600 * number(substring(TimeRun/StartTime, 1, 3)) + 60 * number(substring(TimeRun/StartTime, 4, 2)) + number(substring(TimeRun/StartTime, 6, 2)) + 0.01 * number(substring(concat(TimeRun/StartTime, '00'), 8, 2))) - (3600 * number(substring(AVDuration, 1, 3)) + 60 * number(substring(AVDuration, 4, 2)) + number(substring(AVDuration, 6, 2)) + 0.01 * number(substring(concat(AVDuration, '00'), 8, 2)))) le 1"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AVItemIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AVItemIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="AVItemIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="avitemidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_c_1" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (AVItemIDType eq '01') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_c_2" test="(: IDValue must be a valid GTIN-13 (invalid characters) :) (AVItemIDType ne '03') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_c_3" test="(: IDValue must be a valid GTIN-13 (check digit error) :) (AVItemIDType ne '03') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_c_4" test="(: IDValue must be a plausible DOI (invalid structure) :) (AVItemIDType ne '06') or matches(IDValue, '^10\.([1-9][0-9]*)(\.[0-9]+)?/.+$')"/>
			<xs:assert id="_20171126_c_5" test="(: IDValue must be a valid ISAN (invalid characters) :) (AVItemIDType ne '19') or matches(IDValue, '^[0-9A-Fa-f]{16}[0-9A-Za-z]([0-9A-Fa-f]{8}[0-9A-Za-z])?$')"/>
			<xs:assert id="_20171126_c_6" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (AVItemIDType ne '31') or matches(IDValue, '^10\.5237/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="AVItemIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List241">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AVItemIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x541"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="AVItemType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List240">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="AVItemType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x540"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Barcode">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="BarcodeType"/>
				<xs:element minOccurs="0" ref="PositionOnProduct"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Barcode"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="barcode"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_i_1" test="(: PositionOnProduct must be omitted if (and only if) BarCodeType is 'not barcoded' :) (BarcodeType ne '00') eq exists(PositionOnProduct)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="BarcodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List141">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BarcodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x312"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BatchBonus">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="BatchQuantity"/>
				<xs:element ref="FreeQuantity"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="BatchBonus"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="batchbonus"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="BatchQuantity">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BatchQuantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j264"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Bible">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="BibleContents"/>
				<xs:element maxOccurs="unbounded" ref="BibleVersion"/>
				<xs:element minOccurs="0" ref="StudyBibleType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="BiblePurpose"/>
				<xs:element minOccurs="0" ref="BibleTextOrganization"/>
				<xs:element minOccurs="0" ref="BibleReferenceLocation"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="BibleTextFeature"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Bible"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="bible"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180324_c_1" test="(: Repeats of BibleContents must each be unique :) count(BibleContents) eq count(distinct-values(BibleContents))"/>
			<xs:assert id="_20180324_c_2" test="(: Repeats of BibleVersion must each be unique :) count(BibleVersion) eq count(distinct-values(BibleVersion))"/>
			<xs:assert id="_20180324_c_3" test="(: Repeats of BiblePurpose must each be unique :) count(BiblePurpose) eq count(distinct-values(BiblePurpose))"/>
			<xs:assert id="_20180324_c_4" test="(: Repeats of BibleTextFeature must each be unique :) count(BibleTextFeature) eq count(distinct-values(BibleTextFeature))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="BibleContents">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List82">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BibleContents"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b352"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BiblePurpose">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List85">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BiblePurpose"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b354"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BibleReferenceLocation">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List87">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BibleReferenceLocation"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b356"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BibleTextFeature">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List97">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BibleTextFeature"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b357"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BibleTextOrganization">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List86">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BibleTextOrganization"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b355"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BibleVersion">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List83">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BibleVersion"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b353"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BiographicalNote">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BiographicalNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b044"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_5" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_6" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_3" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_3" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_3" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_3" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="BookClubAdoption">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="BookClubAdoption"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="k169"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_7" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_8" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_4" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_4" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_4" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_4" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CBO">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CBO"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j375"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CitationNote">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CitationNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x434"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_9" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_10" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_5" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_5" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_5" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_5" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CitedContent">
		<xs:annotation>
			<xs:documentation>Added &lt;Territory>, &lt;ReviewRating> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ListName>, &lt;SourceTitle> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;CitationNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="CitedContentType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContentAudience"/>
				<xs:element minOccurs="0" ref="Territory"/>
				<xs:element minOccurs="0" ref="SourceType"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="ReviewRating"/>
						<xs:element maxOccurs="unbounded" ref="SourceTitle"/>
					</xs:sequence>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="SourceTitle"/>
						<xs:sequence minOccurs="0">
							<xs:element maxOccurs="unbounded" ref="ListName"/>
							<xs:element minOccurs="0" ref="PositionOnList"/>
						</xs:sequence>
					</xs:sequence>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="ListName"/>
						<xs:element minOccurs="0" ref="PositionOnList"/>
					</xs:sequence>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="CitationNote"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceLink"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContentDate"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CitedContent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="citedcontent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_k_1" test="(: Repeats of ContentAudience must each be unique :) count(ContentAudience) eq count(distinct-values(ContentAudience))"/>
			<xs:assert id="_20171208_a_2" test="(: Repeats of SourceTitle must each have a unique language attribute :) (count(SourceTitle) le 1) or count(SourceTitle) eq count(distinct-values(SourceTitle/@language))"/>
			<xs:assert id="_20171208_a_3" test="(: Repeats of ListName must each have a unique language attribute :) (count(ListName) le 1) or count(ListName) eq count(distinct-values(ListName/@language))"/>
			<xs:assert id="_20171208_a_4" test="(: Repeats of CitationNote must each have a unique language attribute :) (count(CitationNote) le 1) or count(CitationNote) eq count(distinct-values(CitationNote/@language))"/>
			<xs:assert id="_20171208_e_1" test="(: Repeats of ContentDate must each have a unique ContentDateRole :) count(ContentDate) eq count(distinct-values(ContentDate/ContentDateRole))"/>
			<xs:assert id="_20180109_g_1" test="(: For repeats of ContentDate with matching From and To roles, the From date must precede the To date :) if (exists(ContentDate[ContentDateRole eq '14']) and exists(ContentDate[ContentDateRole eq '15'])) then (if ((if (exists(ContentDate[ContentDateRole eq '14']/Date/@dateformat)) then ContentDate[ContentDateRole eq '14']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '14']/DateFormat)) then ContentDate[ContentDateRole eq '14']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '15']/Date/@dateformat)) then ContentDate[ContentDateRole eq '15']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '15']/DateFormat)) then ContentDate[ContentDateRole eq '15']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '14']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '15']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '14']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '15']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '15']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '14']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '15']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '14']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '15']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '15']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '14']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '15']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '14']/Date le ContentDate[ContentDateRole eq '15']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20180109_g_2" test="(: For repeats of ContentDate with matching Available from and Available until roles, the Available from date must precede the Available until date :) if (exists(ContentDate[ContentDateRole eq '27']) and exists(ContentDate[ContentDateRole eq '28'])) then (if ((if (exists(ContentDate[ContentDateRole eq '27']/Date/@dateformat)) then ContentDate[ContentDateRole eq '27']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '27']/DateFormat)) then ContentDate[ContentDateRole eq '27']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '28']/Date/@dateformat)) then ContentDate[ContentDateRole eq '28']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '28']/DateFormat)) then ContentDate[ContentDateRole eq '28']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '27']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '28']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '27']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '28']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '28']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '27']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '28']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '27']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '28']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '28']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '27']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '28']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '27']/Date le ContentDate[ContentDateRole eq '28']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20180109_g_3" test="(: For repeats of ContentDate with matching Associated start and Associated end roles, the Associated start date must precede the Associated end date :) if (exists(ContentDate[ContentDateRole eq '31']) and exists(ContentDate[ContentDateRole eq '32'])) then (if ((if (exists(ContentDate[ContentDateRole eq '31']/Date/@dateformat)) then ContentDate[ContentDateRole eq '31']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '31']/DateFormat)) then ContentDate[ContentDateRole eq '31']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '32']/Date/@dateformat)) then ContentDate[ContentDateRole eq '32']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '32']/DateFormat)) then ContentDate[ContentDateRole eq '32']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '31']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '32']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '31']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '32']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '32']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '31']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '32']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '31']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '32']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '32']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '31']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '32']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '31']/Date le ContentDate[ContentDateRole eq '32']/Date) else true()) else true()) else true()"/>
		</xs:complexType>
		<xs:unique name="Cited_SourceTitle_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SourceTitle"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="Cited_ListName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ListName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="CitationNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:CitationNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="CitedContentType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List156">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CitedContentType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x430"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CityOfPublication">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CityOfPublication"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b209"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollateralDetail">
		<xs:annotation>
			<xs:documentation>Block 2, container for information and resources to support marketing the product</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.descriptions"/>
				<xs:group ref="gp.prizes"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CollateralDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="collateraldetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<!-- xs:assert id="_20180720_a_1" test="(: CollateralDetail must not be empty :) exists(child::*)"/ -->
			<xs:assert id="_20180324_f_1" test="(: There can only be one each of Table of contents, Index, Introduction, Errata, Flap/cover text, OA statement :) count(TextContent[matches(TextType, '^(04|05|15|20|25|26|27)$')]) eq count(distinct-values(TextContent[matches(TextType, '^(04|05|15|20|25|26|27)$')]/TextType))"/>
			<xs:assert id="_20181026_c_1" test="(: If secondary flap/cover copy included, primary must also be included :) exists(TextContent[TextType eq '05']) or not(exists(TextContent[TextType eq '27']))"/>
			<xs:assert id="_20180612_a_1" test="(: Repeats of Short or Long description, Promotional headline, Biographical note must have a unique Audience (unless they also have a territory) :) count(TextContent[matches(TextType, '^(02|03|10|12|16|17|21)$')][not(exists(Territory))]) eq count(distinct-values(TextContent[matches(TextType, '^(02|03|10|12|16|17|21)$')][not(exists(Territory))]/string-join((TextType | ContentAudience), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="Collection">
		<xs:annotation>
			<xs:documentation>Added &lt;NoContributor> (in gp.authorship) at revision 3.0.4</xs:documentation>
			<xs:documentation>Added &lt;CollectionSequence> and &lt;ContributorStatement> (in gp.authorship) at revision 3.0.1</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ContributorStatement> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="CollectionType"/>
				<xs:element minOccurs="0" ref="SourceName"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="CollectionIdentifier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="CollectionSequence"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TitleDetail"/>
				<xs:group ref="gp.authorship"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Collection"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="collection"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20181113_a_1" test="(: SourceNames may only be used with Ascribed collections :) not(exists(SourceName)) or CollectionType eq '20'"/>
			<xs:assert id="_20171221_i_4" test="(: Repeats of CollectionIdentifier must each have a unique combination of valid CollectionIDType, IDTypeName and IDValue :) count(CollectionIdentifier) eq count(distinct-values(CollectionIdentifier/string-join((CollectionIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171126_d_1" test="(: Repeats of Contributor must each have a unique SequenceNumber :) count(Contributor/SequenceNumber) eq count(distinct-values(Contributor/SequenceNumber))"/>
			<xs:assert id="_20171126_d_2" test="(: Repeats of Contributor must each have a SequenceNumber, or must all omit SequenceNumber :) not(exists(Contributor/SequenceNumber)) or count(Contributor/SequenceNumber) eq count(Contributor)"/>
			<xs:assert id="_20171126_d_3" test="(: Repeats of Contributor must have consecutive SequenceNumbers beginning at 1 :) not(exists(Contributor/SequenceNumber)) or max(Contributor/SequenceNumber) eq count(Contributor)"/>
			<xs:assert id="_20171208_a_5" test="(: Repeats of ContributorStatement must each have a unique language attribute :) (count(ContributorStatement) le 1) or count(ContributorStatement) eq count(distinct-values(ContributorStatement/@language))"/>
		</xs:complexType>
		<xs:unique name="Collection_Contributor_SequenceNumber_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:Contributor"/>
			<xs:field xpath="onix:SequenceNumber"/>
		</xs:unique>
		<xs:unique name="Collection_ContributorStatement_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ContributorStatement"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="CollectionIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="CollectionIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CollectionIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="collectionidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171219_e_1" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (CollectionIDType eq '01') eq exists(IDTypeName)"/>
			<xs:assert id="_20171219_e_2" test="(: IDValue must be a valid ISSN-8 (invalid characters) :) (CollectionIDType ne '02') or matches(IDValue, '^[0-9]{7}[0-9Xx]$')"/>
			<xs:assert id="_20171219_e_3" test="(: IDValue must be a valid ISSN-8 (check digit error) :) (CollectionIDType ne '02') or not(matches(IDValue, '^[0-9]{7}[0-9Xx]$')) or (8 * number(substring(IDValue, 1, 1)) + 7 * number(substring(IDValue, 2, 1)) + 6 * number(substring(IDValue, 3, 1)) + 5 * number(substring(IDValue, 4, 1)) + 4 * number(substring(IDValue, 5, 1)) + 3 * number(substring(IDValue, 6, 1)) + 2 * number(substring(IDValue, 7, 1)) + (if (matches(substring(IDValue, 8, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 8, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171219_e_4" test="(: IDValue must be a plausible DOI (invalid structure) :) (CollectionIDType ne '06') or matches(IDValue, '^10\.([1-9][0-9]*)(\.[0-9]+)?/.+$')"/>
			<xs:assert id="_20171219_e_5" test="(: IDValue must be a valid ISBN-13 (invalid characters) :) (CollectionIDType ne '15') or matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')"/>
			<xs:assert id="_20171219_e_6" test="(: IDValue must be a valid ISBN-13 (check digit error):) (CollectionIDType ne '15') or not(matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollectionIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List13">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CollectionIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x344"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollectionSequence">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="CollectionSequenceType"/>
				<xs:element minOccurs="0" ref="CollectionSequenceTypeName"/>
				<xs:element ref="CollectionSequenceNumber"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CollectionSequence"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="collectionsequence"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollectionSequenceNumber">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.MultiLevelNumberOrHyphen">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CollectionSequenceNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x481"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollectionSequenceType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List197">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CollectionSequenceType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x479"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollectionSequenceTypeName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CollectionSequenceTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x480"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CollectionType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List148">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CollectionType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x329"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComparisonProductPrice">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ProductIdentifier"/>
				<xs:element minOccurs="0" ref="PriceType"/>
				<xs:element ref="PriceAmount"/>
				<xs:element minOccurs="0" ref="CurrencyCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ComparisonProductPrice"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="comparisonproductprice"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_c_1" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_1" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_2" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_3" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_4" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="Complexity">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ComplexitySchemeIdentifier"/>
				<xs:element ref="ComplexityCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Complexity"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="complexity"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171219_g_1" test="(: ComplexityCode must be a valid Fry score :) (ComplexitySchemeIdentifier ne '03') or matches(ComplexityCode, '^([1-9]|1[0-5])$')"/>
			<xs:assert id="_20171219_g_2" test="(: ComplexityCode must be a valid IoE book band :) (ComplexitySchemeIdentifier ne '04') or matches(ComplexityCode, '^(Lilac|Pink A|Pink B|Red A|Red B|Yellow|Blue|Green|Orange|Turquoise|Purple|Gold|White|Lime|Copper|Topaz|Ruby|Emerald|Sapphire|Diamond|Pearl)$')"/>
			<xs:assert id="_20171219_g_3" test="(: ComplexityCode must be a valid F+P text level :) (ComplexitySchemeIdentifier ne '05') or matches(ComplexityCode, '^([A-Y]|Z\+?)$')"/>
			<xs:assert id="_20171219_g_4" test="(: ComplexityCode must be a valid Lexile measure :) (ComplexitySchemeIdentifier ne '06') or matches(ComplexityCode, '^(NP|((AD|BR|GN|HL|IG|NC)?(5|([1-9][0-9]?|1[0-9]{2})[05]|2000)L))$')"/>
			<xs:assert id="_20171219_g_5" test="(: ComplexityCode must be a valid ATOS score :) (ComplexitySchemeIdentifier ne '07') or number(ComplexityCode) ge 0 and number(ComplexityCode) le 17"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComplexityCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ComplexityCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b078"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComplexitySchemeIdentifier">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List32">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ComplexitySchemeIdentifier"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b077"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComponentNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ComponentNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b289"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComponentTypeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ComponentTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b288"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Conference">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ConferenceRole"/>
				<xs:element ref="ConferenceName"/>
				<xs:element minOccurs="0" ref="ConferenceAcronym"/>
				<xs:element minOccurs="0" ref="ConferenceNumber"/>
				<xs:element minOccurs="0" ref="ConferenceTheme"/>
				<xs:element minOccurs="0" ref="ConferenceDate"/>
				<xs:element minOccurs="0" ref="ConferencePlace"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ConferenceSponsor"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Conference"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="conference"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceAcronym">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceAcronym"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b341"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceDate">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceDate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b054"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_1" test="(: Date must be in YYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_2" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_3" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_4" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_5" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_6" test="(: Date must be in YYYY format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_7" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_8" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_9" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_10" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_11" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_12" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_13" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_14" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceName">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b052"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceNumber">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b053"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferencePlace">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferencePlace"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b055"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceRole" default="01">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List20">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b051"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceSponsor">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;EventSponsor> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" ref="ConferenceSponsorIdentifier"/>
					<xs:choice minOccurs="0">
						<xs:element ref="PersonName"/>
						<xs:element ref="CorporateName"/>
					</xs:choice>
				</xs:sequence>
				<xs:element ref="PersonName"/>
				<xs:element ref="CorporateName"/>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ConferenceSponsor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="conferencesponsor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_5" test="(: Repeats of ConferenceSponsorIdentifier must each have a unique combination of valid ConferenceSponsorIDType, IDTypeName and IDValue :) count(ConferenceSponsorIdentifier) eq count(distinct-values(ConferenceSponsorIdentifier/string-join((ConferenceSponsorIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceSponsorIdentifier">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;EventSponsorIdentifier> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ConferenceSponsorIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ConferenceSponsorIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="conferencesponsoridentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_6" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(ConferenceSponsorIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_7" test="(: IDValue must be a valid GLN (invalid characters) :) (ConferenceSponsorIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_8" test="(: IDValue must be a valid GLN (check digit error) :) (ConferenceSponsorIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_9" test="(: IDValue must be a valid SAN (invalid characters) :) (ConferenceSponsorIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_10" test="(: IDValue must be a valid SAN (check digit error) :) (ConferenceSponsorIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171221_j_11" test="(: IDValue must be a valid ISNI (invalid characters) :) (ConferenceSponsorIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_12" test="(: IDValue must be a valid ISNI (check digit error) :) (ConferenceSponsorIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_13" test="(: IDValue must be a valid ORCID (invalid characters) :) (ConferenceSponsorIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_14" test="(: IDValue must be a valid ORCID (check digit error) :) (ConferenceSponsorIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_15" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (ConferenceSponsorIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171221_j_16" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (ConferenceSponsorIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171221_j_17" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (ConferenceSponsorIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceSponsorIDType">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;EventSponsorIdentifier> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceSponsorIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b391"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ConferenceTheme">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Event> instead of &lt;Conference></xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ConferenceTheme"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b342"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_11" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_12" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_6" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_6" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_6" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_6" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContactName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContactName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x299"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContentAudience">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List154">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContentAudience"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x427"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContentDate">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;DateFormat> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ContentDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ContentDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contentdate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_d_1" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20171208_d_2" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20171208_d_3" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20171208_d_4" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_5" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_6" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20171208_d_7" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20171208_d_8" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_9" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_10" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_11" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_12" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20171208_d_13" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20171208_d_14" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContentDateRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List155">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContentDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x429"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContentDetail">
		<xs:annotation>
			<xs:documentation>Block 3, container for information about the content of sections or chapters within the product</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ContentItem> at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContentItem"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ContentDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contentdetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180105_e_1" test="(: Repeats of ContentItem must each have a unique LevelSequenceNumber :) count(ContentItem/LevelSequenceNumber) eq count(distinct-values(ContentItem/LevelSequenceNumber))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContentItem">
		<xs:annotation>
			<xs:documentation>Added &lt;AVItem> at revision 3.0.5</xs:documentation>
			<xs:documentation>Added &lt;ContributorStatement>, &lt;NoContributor> (in gp.authorship), &lt;Language> at revision 3.0.4</xs:documentation>
			<xs:documentation>Added &lt;RelatedProduct> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ContributorStatement> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="LevelSequenceNumber"/>
				<xs:choice>
					<xs:element ref="TextItem"/>
					<xs:element ref="AVItem"/>
				</xs:choice>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="ComponentTypeName"/>
						<xs:element minOccurs="0" ref="ComponentNumber"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="TitleDetail"/>
					</xs:sequence>
					<xs:sequence>
						<xs:element minOccurs="0" ref="ComponentNumber"/>
						<xs:element maxOccurs="unbounded" ref="TitleDetail"/>
					</xs:sequence>
				</xs:choice>
				<xs:group ref="gp.authorship"/>
				<xs:group ref="gp.languages"/>
				<xs:group ref="gp.subjects"/>
				<xs:group ref="gp.descriptions"/>
				<xs:group ref="gp.related_materials"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ContentItem"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contentitem"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_d_4" test="(: Repeats of Contributor must each have a unique SequenceNumber :) count(Contributor/SequenceNumber) eq count(distinct-values(Contributor/SequenceNumber))"/>
			<xs:assert id="_20171126_d_5" test="(: Repeats of Contributor must each have a SequenceNumber, or must all omit a SequenceNumber :) not(exists(Contributor/SequenceNumber)) or count(Contributor/SequenceNumber) eq count(Contributor)"/>
			<xs:assert id="_20171126_d_6" test="(: Repeats of Contributor must have consecutive SequenceNumbers beginning at 1 :) not(exists(Contributor/SequenceNumber)) or max(Contributor/SequenceNumber) eq count(Contributor)"/>
			<xs:assert id="_20171208_a_6" test="(: Repeats of ContributorStatement must each have a unique language attribute :) (count(ContributorStatement) le 1) or count(ContributorStatement) eq count(distinct-values(ContributorStatement/@language))"/>
		</xs:complexType>
		<xs:unique name="ContentItem_ContributorStatement_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ContributorStatement"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="Contributor">
		<xs:annotation>
			<xs:documentation>Added &lt;Gender>, &lt;Prize> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified to allow &lt;NameIdentifier> and &lt;AlternativeName> with &lt;UnnamedPersons> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;BiographicalNote>, &lt;ContributorDescription> at revision 3.0.1</xs:documentation>
			<xs:documentation>Added &lt;CorporateNameInverted> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:element maxOccurs="unbounded" ref="ContributorRole"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="FromLanguage"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ToLanguage"/>
				<xs:element minOccurs="0" ref="NameType"/>
				<xs:choice>
					<xs:sequence>
						<xs:choice>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="NameIdentifier"/>
								<xs:choice minOccurs="0">
									<xs:sequence>
										<xs:group ref="gp.unstructured_name"/>
										<xs:group minOccurs="0" ref="gp.structured_name"/>
										<xs:element minOccurs="0" ref="Gender"/>
									</xs:sequence>
									<xs:sequence>
										<xs:group ref="gp.structured_name"/>
										<xs:element minOccurs="0" ref="Gender"/>
									</xs:sequence>
									<xs:group ref="gp.corporate_name"/>
									<xs:element ref="UnnamedPersons"/>
								</xs:choice>
							</xs:sequence>
							<xs:sequence>
								<xs:choice>
									<xs:sequence>
										<xs:group ref="gp.unstructured_name"/>
										<xs:group minOccurs="0" ref="gp.structured_name"/>
										<xs:element minOccurs="0" ref="Gender"/>
									</xs:sequence>
									<xs:sequence>
										<xs:group ref="gp.structured_name"/>
										<xs:element minOccurs="0" ref="Gender"/>
									</xs:sequence>
									<xs:group ref="gp.corporate_name"/>
									<xs:element ref="UnnamedPersons"/>
								</xs:choice>
							</xs:sequence>
						</xs:choice>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="AlternativeName"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDate"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProfessionalAffiliation"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="Prize"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="BiographicalNote"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDescription"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
					</xs:sequence>
					<xs:sequence>
						<!-- deprecated options for <UnnamedPersons> -->
						<xs:choice>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="ContributorDate"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProfessionalAffiliation"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="Prize"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="BiographicalNote"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDescription"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="ProfessionalAffiliation"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="Prize"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="BiographicalNote"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDescription"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="Prize"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="BiographicalNote"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDescription"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="BiographicalNote"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDescription"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="Website"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorDescription"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="ContributorDescription"/>
								<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" ref="ContributorPlace"/>
							</xs:sequence>
						</xs:choice>
						<xs:element ref="UnnamedPersons"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorPlace"/>
					</xs:sequence>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Contributor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contributor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_h_1" test="(: Repeats of ContributorRole must each be unique :) count(ContributorRole) eq count(distinct-values(ContributorRole))"/>
			<xs:assert id="_20181113_f_1" test="(: FromLanguage and ToLanguage may only be used with translators :) not(exists(FromLanguage | ToLanguage)) or exists(ContributorRole[matches(., '^(B06|B08|B10)$')])"/>
			<xs:assert id="_20171221_i_6" test="(: Repeats of NameIdentifier must each have a unique combination of valid NameIDType, IDTypeName and IDValue :) count(NameIdentifier) eq count(distinct-values(NameIdentifier/string-join((NameIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171208_e_2" test="(: Repeats of ContributorDate must each have a unique ContributorDateRole :) count(ContributorDate) eq count(distinct-values(ContributorDate/ContributorDateRole))"/>
			<xs:assert id="_20180109_f_1" test="(: For repeats of ContributorDate with matching Birth and Death roles, the Birth date must precede the Death date :) if (exists(ContributorDate[ContributorDateRole eq '50']) and exists(ContributorDate[ContributorDateRole eq '51'])) then (if ((if (exists(ContributorDate[ContributorDateRole eq '50']/Date/@dateformat)) then ContributorDate[ContributorDateRole eq '50']/Date/@dateformat else if (exists(ContributorDate[ContributorDateRole eq '50']/DateFormat)) then ContributorDate[ContributorDateRole eq '50']/DateFormat else '00') eq (if (exists(ContributorDate[ContributorDateRole eq '51']/Date/@dateformat)) then ContributorDate[ContributorDateRole eq '51']/Date/@dateformat else if (exists(ContributorDate[ContributorDateRole eq '51']/DateFormat)) then ContributorDate[ContributorDateRole eq '51']/DateFormat else '00')) then (if ((if (contains(ContributorDate[ContributorDateRole eq '50']/Date, '+')) then (contains(ContributorDate[ContributorDateRole eq '51']/Date, '+') and (substring-after(ContributorDate[ContributorDateRole eq '50']/Date, '+') eq substring-after(ContributorDate[ContributorDateRole eq '51']/Date, '+'))) else not(contains(ContributorDate[ContributorDateRole eq '51']/Date, '+'))) and (if (contains(ContributorDate[ContributorDateRole eq '50']/Date, '-')) then (contains(ContributorDate[ContributorDateRole eq '51']/Date, '-') and (substring-after(ContributorDate[ContributorDateRole eq '50']/Date, '-') eq substring-after(ContributorDate[ContributorDateRole eq '51']/Date, '-'))) else not(contains(ContributorDate[ContributorDateRole eq '51']/Date, '-'))) and (matches(ContributorDate[ContributorDateRole eq '50']/Date, 'Z') eq matches(ContributorDate[ContributorDateRole eq '51']/Date, 'Z'))) then (ContributorDate[ContributorDateRole eq '50']/Date le ContributorDate[ContributorDateRole eq '51']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20171126_e_1" test="(: Repeats of BiographicalNote must each have a unique language attribute :) (count(BiographicalNote) le 1) or (count(BiographicalNote) eq count(distinct-values(BiographicalNote/@language)))"/>
			<xs:assert id="_20171208_a_7" test="(: Repeats of ContributorDescription must each have a unique language attribute :) (count(ContributorDescription) le 1) or count(ContributorDescription) eq count(distinct-values(ContributorDescription/@language))"/>
			<xs:assert id="_20190710_d_1" test="(: Registration and operation relators may only be used with corporate contributors :) not(exists(ContributorPlace[matches(ContributorPlaceRelator, '^(09|10)$')])) or exists(CorporateName | CorporateNameInverted)"/>
			<xs:assert id="_20200317_a_1" test="(: NameType must not be a fictional character :) not(exists(NameType)) or NameType ne '07'"/>
			<xs:assert id="_20200317_a_2" test="(: AlternativeName Type must not be a fictional character :) not(exists(AlternativeName)) or AlternativeName/NameType ne '07'"/>
		</xs:complexType>
		<xs:unique name="BiographicalNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:BiographicalNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="ContributorDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ContributorDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ContributorDate">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;DateFormat> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ContributorDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ContributorDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contributordate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<!-- was previously _20171208_d_ -->
			<xs:assert id="_20180202_b_1" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20180202_b_2" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20180202_b_3" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20180202_b_4" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20180202_b_5" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20180202_b_6" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20180202_b_7" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20180202_b_8" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20180202_b_9" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20180202_b_10" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20180202_b_11" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20180202_b_12" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^([01][0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20180202_b_13" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20180202_b_14" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContributorDateRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List177">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContributorDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x417"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContributorDescription">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContributorDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b048"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_13" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_14" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_7" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_7" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_7" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_7" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContributorPlace">
		<xs:annotation>
			<xs:documentation>Added &lt;LocationName> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ContributorPlaceRelator"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="CountryCode"/>
						<xs:element minOccurs="0" ref="RegionCode"/>
					</xs:sequence>
					<xs:element ref="RegionCode"/>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="LocationName"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ContributorPlace"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contributorplace"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180324_a_1" test="(: The region must be within the country :) not(exists(RegionCode) and exists(CountryCode)) or starts-with(RegionCode, CountryCode)"/>
			<xs:assert id="_20171208_a_8" test="(: Repeats of LocationName must each have a unique language attribute :) (count(LocationName) le 1) or count(LocationName) eq count(distinct-values(LocationName/@language))"/>
			<xs:assert id="_20210302_a_1" test="(: Citizen of must only be used with country codes :) (ContributorPlaceRelator ne '08') or not(exists(RegionCode))"/>
		</xs:complexType>
		<xs:unique name="LocationName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:LocationName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ContributorPlaceRelator">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List151">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContributorPlaceRelator"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x418"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContributorReference">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:element maxOccurs="unbounded" ref="ContributorRole"/>
				<xs:element maxOccurs="unbounded" ref="NameIdentifier"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ContributorReference"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="contributorreference"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContributorRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List17">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContributorRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b035"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ContributorStatement">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ContributorStatement"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b049"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_15" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_16" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_8" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_8" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_8" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_8" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopiesSold">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CopiesSold"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="k168"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_17" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_18" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_9" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_9" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_9" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_9" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopyrightOwner">
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" ref="CopyrightOwnerIdentifier"/>
					<xs:choice minOccurs="0">
						<xs:element ref="PersonName"/>
						<xs:element ref="CorporateName"/>
					</xs:choice>
				</xs:sequence>
				<xs:element ref="PersonName"/>
				<xs:element ref="CorporateName"/>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CopyrightOwner"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="copyrightowner"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_7" test="(: Repeats of CopyrightOwnerIdentifier must each have a unique combination of valid CopyrightOwnerIDType, IDTypeName and IDValue :) count(CopyrightOwnerIdentifier) eq count(distinct-values(CopyrightOwnerIdentifier/string-join((CopyrightOwnerIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopyrightOwnerIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="CopyrightOwnerIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CopyrightOwnerIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="copyrightowneridentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_18" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(CopyrightOwnerIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_19" test="(: IDValue must be a valid GLN (invalid characters) :) (CopyrightOwnerIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_20" test="(: IDValue must be a valid GLN (check digit error) :) (CopyrightOwnerIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_21" test="(: IDValue must be a valid SAN (invalid characters) :) (CopyrightOwnerIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_22" test="(: IDValue must be a valid SAN (check digit error) :) (CopyrightOwnerIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171221_j_23" test="(: IDValue must be a valid ISNI (invalid characters) :) (CopyrightOwnerIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_24" test="(: IDValue must be a valid ISNI (invalid chek digit) :) (CopyrightOwnerIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_25" test="(: IDValue must be a valid ORCID (invalid characters) :) (CopyrightOwnerIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_26" test="(: IDValue must be a valid ORCID (invalid chek digit) :) (CopyrightOwnerIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_27" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (CopyrightOwnerIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171221_j_28" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (CopyrightOwnerIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171221_j_29" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (CopyrightOwnerIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopyrightOwnerIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CopyrightOwnerIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b392"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopyrightStatement">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;CopyrightYear> at revision 3.0.7</xs:documentation>
			<xs:documentation>Added &lt;CopyrightType> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="CopyrightType"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="CopyrightYear"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="CopyrightOwner"/>
					</xs:sequence>
					<xs:element maxOccurs="unbounded" ref="CopyrightOwner"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="CopyrightStatement"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="copyrightstatement"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopyrightType" default="C">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List219">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CopyrightType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x512"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CopyrightYear">
		<xs:annotation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CopyrightYear"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b087"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_15" test="(: Date must be in YYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_16" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_17" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_18" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_19" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_20" test="(: Date must be in YYYY format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_21" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_22" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_23" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_24" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_25" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_26" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_27" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_28" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CorporateName">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CorporateName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b047"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CorporateNameInverted">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
			<xs:documentation>Added at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CorporateNameInverted"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x443"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CountriesIncluded">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.CountryCodeList">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CountriesIncluded"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x449"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CountriesExcluded">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.CountryCodeList">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CountriesExcluded"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x451"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CountryCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List91">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CountryCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b251"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CountryOfManufacture">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List91">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CountryOfManufacture"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x316"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CountryOfPublication">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List91">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CountryOfPublication"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b083"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CurrencyCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List96">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CurrencyCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j152"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="CurrencyZone">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;Territory> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List172">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="CurrencyZone"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x475"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Date">
		<xs:annotation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Date"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b306"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DateFormat">
		<xs:annotation>
			<xs:documentation>Deprecated – use dateformat attribute instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List55">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DateFormat"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j260"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DefaultCurrencyCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List96">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DefaultCurrencyCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m186"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DefaultLanguageOfText">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List74">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DefaultLanguageOfText"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m184"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DefaultPriceType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List58">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DefaultPriceType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x310"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DeletionText">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DeletionText"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="a199"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DescriptiveDetail">
		<xs:annotation>
			<xs:documentation>Block 1, container for data describing the form and content of the product</xs:documentation>
			<xs:documentation>Added &lt;Event>, deprecated &lt;Conference> at revision 3.0.3</xs:documentation>
			<xs:documentation>Added &lt;EpubLicence> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ContributorStatement>, &lt;EditionStatement>, &lt;IllustrationsNote>, &lt;AudienceDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.product_form"/>
				<xs:group ref="gp.collections"/>
				<xs:group ref="gp.titles"/>
				<xs:group ref="gp.authorship"/>
				<xs:group ref="gp.events"/>
				<xs:group ref="gp.editions"/>
				<xs:group ref="gp.languages"/>
				<xs:group ref="gp.extents"/>
				<xs:group ref="gp.subjects"/>
				<xs:group ref="gp.audiences"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="DescriptiveDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="descriptivedetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180214_a_1" test="(: Product composition must be consistent with Product form :) not(matches(ProductForm, '^(A.|B.|C.|D.|E.|F.|L.|M.|V.)$')) or ProductComposition eq '00'"/>
			<xs:assert id="_20180214_a_2" test="(: Product composition must be consistent with Product form :) not(matches(ProductForm, '^(P.)$')) or matches(ProductComposition, '^(00|20)$')"/>
			<xs:assert id="_20180214_a_3" test="(: Product composition must be consistent with Product form :) not(matches(ProductForm, '^(S.)$')) or matches(ProductComposition, '^(10|11)$')"/>
			<xs:assert id="_20180214_a_4" test="(: Product composition must be consistent with Product form :) not(matches(ProductForm, '^(X.)$')) or matches(ProductComposition, '^(20|30|31)$')"/>
			<xs:assert id="_20180214_a_5" test="(: Product composition must be consistent with Product form :) not(matches(ProductForm, '^(Z.)$')) or matches(ProductComposition, '^(00|20|30|31)$')"/>
			<!-- xs:assert id="_20180214_a_6" test="(: Multi-item and multi-component products Product composition must be consistent with Product form :) matches(ProductForm, '^(S.|XC|XE|XL|XM)$') eq matches(ProductComposition, '^(10|11|30|31)$')" / -->
			<xs:assert id="_20180214_a_7" test="(: Multi-item and multi-component products (only) must use ProductPart to describe their contained items or components :) matches(ProductForm, '^(S.|XC|XE|XL|XM)$') eq exists(ProductPart)"/>
			<xs:assert id="_20181210_d_1" test="(: PrimaryPart can only be used on one ProductPart :) count(ProductPart/PrimaryPart) le 1"/>
			<xs:assert id="_20180214_i_1" test="(: Multi-item products must have product identifiers for their contained items within ProductPart :) not(matches(ProductForm, '^(XC|XE|XL|XM)$')) or exists(ProductPart/ProductIdentifier)"/>
			<xs:assert id="_20171216_b_1" test="(: Repeats of ProductFormDetail must each be unique :) count(ProductFormDetail) eq count(distinct-values(ProductFormDetail))"/>
			<xs:assert id="_20180308_a_1" test="(: ProductFormDetail codes A101–2 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(A101|A102)$')])) or matches(ProductForm, '^(AA|AC)$')"/>
			<xs:assert id="_20180308_a_2" test="(: ProductFormDetail codes A103–12 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(A103|A104|A105|A106|A107|A108|A109|A110|A111|A112)$')])) or matches(ProductForm, '^(AA|AE|AH|AJ|AK|AL|AN|AO|D.|E.)$')"/>
			<xs:assert id="_20180308_a_3" test="(: ProductFormDetail codes A301–5 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(A301|A302|A303|A304|A305)$')])) or matches(ProductForm, '^(A.|D.|E.|V.)$')"/>
			<xs:assert id="_20180308_a_4" test="(: ProductFormDetail codes B101–7, B113–4, B116–8, B131–2 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(B101|B102|B103|B104|B105|B106|B107|B113|B114|B116|B117|B118|B131|B132|B412)$')])) or ProductForm eq 'BC'"/>
			<xs:assert id="_20180308_a_5" test="(: ProductFormDetail codes B115, B306 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B115|B306)$')])) or ProductForm eq 'BB'"/>
			<xs:assert id="_20180308_a_6" test="(: ProductFormDetail codes B133 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[. eq 'B133'])) or matches(ProductForm, '^(BB|BC)$')"/>
			<xs:assert id="_20180308_a_7" test="(: ProductFormDetail codes B301-3 can only be used with appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B301|B302|B303)$')])) or ProductForm eq 'BD'"/>
			<xs:assert id="_20180308_a_8" test="(: ProductFormDetail codes B201-2, B204-10, B212-6, B221-3 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(B201|B202|B204|B205|B206|B207|B208|B209|B210|B212|B213|B214|B215|B216|B221|B222|B223)$')])) or matches(ProductForm, '^B.$')"/>
			<xs:assert id="_20180308_a_9" test="(: ProductFormDetail codes B311-4 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B311|B312|B313|B314)$')])) or ProductForm eq 'BE'"/>
			<xs:assert id="_20180308_a_10" test="(: ProductFormDetail codes B403-5 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B403|B404|B405)$')])) or ProductForm eq 'BG'"/>
			<xs:assert id="_20180308_a_11" test="(: ProductFormDetail codes B201-7 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(D201|D202|D203|D204|D205|D206|D207)$')])) or matches(ProductForm, '^(D.)$')"/>
			<xs:assert id="_20180308_a_12" test="(: ProductFormDetail codes P104-112 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(P104|P105|P106|P108|P111|P112)$')])) or ProductForm eq 'PC'"/>
			<xs:assert id="_20180308_a_13" test="(: ProductFormDetail codes P105, P115 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(P105|P115)$')])) or matches(ProductForm, '^(PC|PK)$')"/>
			<xs:assert id="_20180308_a_14" test="(: ProductFormDetail codes P101-103, P107, P110 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(P101|P102|P103|P107|P110)$')])) or matches(ProductForm, '^(PC|PF)$')"/>
			<xs:assert id="_20180308_a_15" test="(: ProductFormDetail codes P109 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[. eq 'P109'])) or matches(ProductForm, '^(PC|PT)$')"/>
			<xs:assert id="_20180308_a_16" test="(: ProductFormDetail codes P113 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[. eq 'P113'])) or matches(ProductForm, '^(PC|PF|PS)$')"/>
			<xs:assert id="_20190410_g_1" test="(: Battery details in ProductFormFeature are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '19'][ProductFormFeatureValue eq '00']) le 1"/>
			<xs:assert id="_20190410_g_2" test="(: Battery details in ProductFormFeature are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '19'][matches(ProductFormFeatureValue, '^(01|02|03|04)$')]) le 1"/>
			<xs:assert id="_20190410_g_3" test="(: Battery details in ProductFormFeature are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '19'][matches(ProductFormFeatureValue, '^(08|09)$')]) le 1"/>
			<xs:assert id="_20190410_g_4" test="(: Battery details in ProductFormFeature are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '19'][matches(ProductFormFeatureValue, '^(20|21|22|23|24|25|26|27|29|29|99)$')]) le 1"/>
			<xs:assert id="_20180308_b_1" test="(: Rack-size must be 6¾–7⅛in tall :) not(exists(ProductFormDetail[. eq 'B101'])) or not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'in'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'in']/Measurement) - 6.9375) le 3.125"/>
			<xs:assert id="_20180308_b_2" test="(: Tall rack-size must be 7½in tall :) not(exists(ProductFormDetail[. eq 'B107'])) or not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'in'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'in']/Measurement) - 7.5) le 0.25"/>
			<xs:assert id="_20180308_b_3" test="(: Rack-size must be 4¼in wide :) not(exists(ProductFormDetail[matches(., '^(B101|B107)$')])) or not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'in'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'in']/Measurement) - 4.25) le 0.125"/>
			<xs:assert id="_20180308_b_4" test="(: A-format must be 178mm tall :) not(exists(ProductFormDetail[. eq 'B104'])) or ((not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']/Measurement) - 178) le 3) and (not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm']/Measurement) - 17.8) le 0.3))"/>
			<xs:assert id="_20180308_b_5" test="(: A-format must be 111mm wide :) not(exists(ProductFormDetail[. eq 'B104'])) or ((not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']/Measurement) - 111) le 3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm']/Measurement) - 11.1) le 0.3))"/>
			<xs:assert id="_20180308_b_6" test="(: B-format must be 197mm tall :) not(exists(ProductFormDetail[. eq 'B105'])) or ((not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']/Measurement) - 197) le 3) and (not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm']/Measurement) - 19.7) le 0.3))"/>
			<xs:assert id="_20180308_b_7" test="(: B-format must be 129mm wide :) not(exists(ProductFormDetail[. eq 'B105'])) or ((not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']/Measurement) - 129) le 3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm']/Measurement) - 12.9) le 0.3))"/>
			<xs:assert id="_20180308_b_8" test="(: A4 must be 297mm x 210mm :) not(exists(ProductFormDetail[. eq 'B121'])) or ((not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']/Measurement) - 297) le 3) and (not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm']/Measurement) - 29.7) le 0.3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']/Measurement) - 210) le 3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm']/Measurement) - 21.0) le 0.3)) or ((not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']/Measurement) - 210) le 3) and (not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm']/Measurement) - 21.0) le 0.3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']/Measurement) - 297) le 3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm']/Measurement) - 29.7) le 0.3))"/>
			<xs:assert id="_20180308_b_9" test="(: A5 must be 210mm x 148mm :) not(exists(ProductFormDetail[. eq 'B134'])) or ((not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']/Measurement) - 210) le 3) and (not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureTyoe eq '01'][MeasureUnitCode eq 'cm']/Measurement) - 21.0) le 0.3) and (not(exists(Measure[MeasureTyoe eq '02'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']/Measurement) - 148) le 3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm']/Measurement) - 14.8) le 0.3)) or ((not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']/Measurement) - 148) le 3) and (not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '01'][MeasureUnitCode eq 'cm']/Measurement) - 14.8) le 0.3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']/Measurement) - 210) le 3) and (not(exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm'])) or abs(number(Measure[MeasureType eq '02'][MeasureUnitCode eq 'cm']/Measurement) - 21.0) le 0.3))"/>
			<xs:assert id="_20180517_c_1" test="(: Only physical products should have FSC, PEFC certification, or PCW claims :) not(matches(ProductForm, '^(A[JNO]|E[ABCD])$')) or not(exists(ProductFormFeature[matches(ProductFormFeaureType, '^(30|31|32|33|34|35|36|37|40)$')]))"/>
			<xs:assert id="_20171216_c_1" test="(: Repeats of ProductFormFeature must only include a single FSC certification :) count(ProductFormFeature[matches(ProductFormFeatureType, '^(31|32|33)$')]) le 1"/>
			<xs:assert id="_20171216_c_2" test="(: Repeats of ProductFormFeature must only include a single PEFC certification :) count(ProductFormFeature[matches(ProductFormFeatureType, '^(34|35)$')]) le 1"/>
			<xs:assert id="_20180214_h_1" test="(: Claimed PCW percentage must be accompanied by a declaration that this is not PEFC- or FSC-certified :) not(exists(ProductFormFeature[ProductFormFeatureType eq '37'])) or exists(ProductFormFeature[ProductFormFeatureType eq '30'])"/>
			<xs:assert id="_20171216_d_1" test="(: Repeats of ProductFormFeature must only include a single binding color :) count(ProductFormFeature[ProductFormFeatureType eq '01']) le 1"/>
			<xs:assert id="_20171216_d_2" test="(: Repeats of ProductFormFeature must only include a single page edge color :) count(ProductFormFeature[ProductFormFeatureType eq '02']) le 1"/>
			<xs:assert id="_20190710_g_1" test="(: Repeats of ProductFormFeature with and without warnings are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '12'][matches(ProductFormFeatureValue, '^(11|12)$')]) le 1"/>
			<xs:assert id="_20190710_g_2" test="(: Repeats of ProductFormFeature with and without warnings are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '12'][matches(ProductFormFeatureValue, '^(13|14)$')]) le 1"/>
			<xs:assert id="_20190710_g_3" test="(: Repeats of ProductFormFeature with and without warnings are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '12'][matches(ProductFormFeatureValue, '^(21|22)$')]) le 1"/>
			<xs:assert id="_20171216_f_1" test="(: Repeats of ProductFormFeature must only include a single material type :) count(ProductFormFeature[ProductFormFeatureType eq '04']) le 1"/>
			<xs:assert id="_20171216_e_1" test="(: Repeats of ProductFormFeature for accessibility detail must each have a unique ProductFormFeatureValue :) count(ProductFormFeature[ProductFormFeatureType eq '09']) eq count(distinct-values(ProductFormFeature[ProductFormFeatureType eq '09']/ProductFormFeatureValue))"/>
			<xs:assert id="_20171126_e_2" test="(: Repeats of ProductFormDescription must each have a unique language attribute :) (count(ProductFormDescription) le 1) or count(ProductFormDescription) eq count(distinct-values(ProductFormDescription/@language))"/>
			<xs:assert id="_20171208_c_1" test="(: PrimaryContentType and repeats of ProductContentType must each be unique :) count(PrimaryContentType | ProductContentType) eq count(distinct-values(PrimaryContentType | ProductContentType))"/>
			<xs:assert id="_20180214_k_1" test="(: Only physical products should have measurements :) not(matches(ProductForm, '^(A[JNO]|E[ABCD])$')) or not(exists(Measure))"/>
			<xs:assert id="_20171212_f_1" test="(: Repeats of Measure must each have a unique combination of valid MeasureType and MeasureUnitCode :) count(Measure) eq count(distinct-values(Measure/string-join((MeasureType | MeasureUnitCode), ' ')))"/>
			<xs:assert id="_20180214_b_1" test="(: Unpackaged height measurement must be accompanied by packaged overall height :) not(exists(Measure[MeasureType eq '14'])) or exists(Measure[MeasureType eq '01'])"/>
			<xs:assert id="_20180214_b_2" test="(: Unpackaged width measurement must be accompanied by packaged overall width :) not(exists(Measure[MeasureType eq '15'])) or exists(Measure[MeasureType eq '02'])"/>
			<xs:assert id="_20180214_b_3" test="(: Unpackaged thickness measurement must be accompanied by packaged overall thickness :) not(exists(Measure[MeasureType eq '16'])) or exists(Measure[MeasureType eq '03'])"/>
			<xs:assert id="_20180214_b_4" test="(: Unpackaged product must fit inside packaged dimensions :) not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'mm']) and exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'mm']) and exists(Measure[MeasureType eq '14'][MeasureUnitCode eq 'mm']) and exists(Measure[MeasureType eq '15'][MeasureUnitCode eq 'mm'])) or number(min(Measure[matches(MeasureType, '^(14|15)$')][MeasureUnitCode eq 'mm']/Measurement)) le number(max(Measure[matches(MeasureType, '^(01|02)$')][MeasureUnitCode eq 'mm']/Measurement))"/>
			<xs:assert id="_20180214_b_5" test="(: Unpackaged product must fit inside packaged dimensions :) not(exists(Measure[MeasureType eq '01'][MeasureUnitCode eq 'in']) and exists(Measure[MeasureType eq '02'][MeasureUnitCode eq 'in']) and exists(Measure[MeasureType eq '14'][MeasureUnitCode eq 'in']) and exists(Measure[MeasureType eq '15'][MeasureUnitCode eq 'in'])) or number(min(Measure[matches(MeasureType, '^(14|15)$')][MeasureUnitCode eq 'in']/Measurement)) le number(max(Measure[matches(MeasureType, '^(01|02)$')][MeasureUnitCode eq 'in']/Measurement))"/>
			<xs:assert id="_20180109_d_1" test="(: Repeats of Measure with matching MeasureType but differing MeasureUnitCode must be equivalent :) every $type in distinct-values(Measure/MeasureType) satisfies ((count(Measure[MeasureType eq $type]) eq 1) or (((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']/Measurement) * 25.4) le 25.4 div 8)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']/Measurement) * 10) le 1)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']/Measurement) * 2.54) le 2.54 div 8)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']/Measurement) * 28.35) le 28.35 div 8)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']/Measurement) * 453.6) le 453.6 div 28.35)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']/Measurement) * 1000) le 10)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']/Measurement) * 16) le 1)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']/Measurement) * 35.27) le 1)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']/Measurement) * 2.2) le 2.2 div 16))))"/>
			<xs:assert id="_20190410_d_1" test="(: Weight of batteries must not exceed weight of product in gr :) not(exists(Measure[MeasureType eq '08'][MeasureUnitCode eq 'gr'])) or not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr'])) or number(Measure[MeasureType eq '08'][MeasureUnitCode eq 'gr']/Measurement) ge number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr']/Measurement)"/>
			<xs:assert id="_20190410_d_2" test="(: Weight of batteries must not exceed weight of product in oz :) not(exists(Measure[MeasureType eq '08'][MeasureUnitCode eq 'oz'])) or not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz'])) or number(Measure[MeasureType eq '08'][MeasureUnitCode eq 'oz']/Measurement) ge number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz']/Measurement)"/>
			<xs:assert id="_20190410_d_3" test="(: Weight of lithium in batteries must not exceed weight of product in gr :) not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr'])) or not(exists(Measure[MeasureType eq '18'][MeasureUnitCode eq 'gr'])) or number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr']/Measurement) ge number(Measure[MeasureType eq '18'][MeasureUnitCode eq 'gr']/Measurement)"/>
			<xs:assert id="_20190410_d_4" test="(: Weight of lithium in batteries must not exceed weight of product in oz :) not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz'])) or not(exists(Measure[MeasureType eq '18'][MeasureUnitCode eq 'oz'])) or number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz']/Measurement) ge number(Measure[MeasureType eq '18'][MeasureUnitCode eq 'oz']/Measurement)"/>
			<xs:assert id="_20171216_a_1" test="(: Repeats of EpubTechnicalProtection must each be unique :) count(EpubTechnicalProtection) eq count(distinct-values(EpubTechnicalProtection))"/>
			<xs:assert id="_20171216_a_2" test="(: Repeats of EpubTechnicalProtection must not include 'none' :) not(exists(EpubTechnicalProtection[. eq '00'])) or count(EpubTechnicalProtection) eq 1"/>
			<xs:assert id="_20171212_i_1" test="(: Repeats of EpubUsageConstraint must each have a unique EpubUsageType :) count(EpubUsageConstraint) eq count(distinct-values(EpubUsageConstraint/EpubUsageType))"/>
			<xs:assert id="_20171219_a_1" test="(: Repeats of ProductClassification must each have a unique combination of valid ProductClassificationType and ProductClassificationCode :) count(ProductClassification[ProductClassificationType ne '07']) eq count(distinct-values(ProductClassification[ProductClassificationType ne '07']/string-join((ProductClassificationType | ProductClassificationCode), ' ')))"/>
			<xs:assert id="_20171219_a_2" test="(: Repeats of ProductClassification with matching ProductClassificationType must each include Percent :) every $class in distinct-values(ProductClassification[ProductClassificationType ne '07']/ProductClassificationType) satisfies (count(ProductClassification[ProductClassificationType eq $class]) eq 1 or (count(ProductClassification[ProductClassificationType eq $class]) eq count(ProductClassification[ProductClassificationType eq $class]/Percent)))"/>
			<xs:assert id="_20171219_a_3" test="(: Repeats of ProductClassification with matching ProductClassificationType must include Percents summing to 100 :) every $class in distinct-values(ProductClassification[ProductClassificationType ne '07']/ProductClassificationType) satisfies not(exists(ProductClassification[ProductClassificationType eq $class]/Percent)) or abs(sum(ProductClassification[ProductClassificationType eq $class]/Percent) - 100) le 0.5"/>
			<xs:assert id="_20171219_a_4" test="(: Repeats of proprietary ProductClassification must each hae a unique combination of valid ProductClassificationTypeName and ProductClassificationCode :) count(ProductClassification[ProductClassificationType eq '07']) eq count(distinct-values(ProductClassification[ProductClassificationType eq '07']/string-join((ProductClassificationTypeName | ProductClassificationCode), ' ')))"/>
			<xs:assert id="_20171219_a_5" test="(: Repeats of proprietary ProductClassification with matching ProductClassificationTypeName must each include Percent :) every $class in distinct-values(ProductClassification[ProductClassificationType eq '07']/ProductClassificationTypeName) satisfies (count(ProductClassification[ProductClassificationType eq '07'][ProductClassificationTypeName eq $class]) eq 1 or (count(ProductClassification[ProductClassificationType eq '07'][ProductClassificationTypeName eq $class]) eq count(ProductClassification[ProductClassificationType eq '07'][ProductClassificationTypeName eq $class]/Percent)))"/>
			<xs:assert id="_20171219_a_6" test="(: Repeats of proprietary ProductClassification with matching ProductClassificationType must include Percents summing to 100 :) every $class in distinct-values(ProductClassification[ProductClassificationType eq '07']/ProductClassificationTypeName) satisfies not(exists(ProductClassification[ProductClassificationType eq '07'][ProductClassificationTypeName eq $class]/Percent)) or abs(sum(ProductClassification[ProductClassificationType eq '07'][ProductClassificationTypeName eq $class]/Percent) - 100) le 0.5"/>
			<xs:assert id="_20171126_d_7" test="(: Repeats of Contributor must each have a unique SequenceNumber :) count(Contributor/SequenceNumber) eq count(distinct-values(Contributor/SequenceNumber))"/>
			<xs:assert id="_20171126_d_8" test="(: Repeats of Contributor must each have a SequenceNumber, or must all omit a SequenceNumber :) not(exists(Contributor/SequenceNumber)) or count(Contributor/SequenceNumber) eq count(Contributor)"/>
			<xs:assert id="_20171126_d_9" test="(: Repeats of Contributor must have consecutive SequenceNumbers beginning at 1 :) not(exists(Contributor/SequenceNumber)) or max(Contributor/SequenceNumber) eq count(Contributor)"/>
			<xs:assert id="_20171208_a_9" test="(: Repeats of ContributorStatement must each have a unique language attribute :) (count(ContributorStatement) le 1) or count(ContributorStatement) eq count(distinct-values(ContributorStatement/@language))"/>
			<xs:assert id="_20171126_j_1" test="(: Repeats of EditionType must each be unique :) count(EditionType) eq count(distinct-values(EditionType))"/>
			<xs:assert id="_20180308_c_1" test="(: Edition types ABR and UBR cannot co-exist :) not(exists(EditionType[. eq 'ABR'])) or not(exists(EditionType[. eq 'UBR']))"/>
			<xs:assert id="_20180308_c_2" test="(: Edition types LTE and ULP cannot co-exist :) not(exists(EditionType[. eq 'LTE'])) or not(exists(EditionType[. eq 'ULP']))"/>
			<xs:assert id="_20180308_c_3" test="(: Edition types NUM and UNN cannot co-exist :) not(exists(EditionType[. eq 'NUM'])) or not(exists(EditionType[. eq 'UNN']))"/>
			<xs:assert id="_20180308_c_4" test="(: Edition types STU and TCH cannot co-exist :) not(exists(EditionType[. eq 'STU'])) or not(exists(EditionType[. eq 'TCH']))"/>
			<xs:assert id="_20180308_c_5" test="(: Edition types EXP and UXP cannot co-exist :) not(exists(EditionType[. eq 'EXP'])) or not(exists(EditionType[. eq 'UXP']))"/>
			<xs:assert id="_20171208_a_10" test="(: Repeats of EditionStatement must each have a unique language attribute :) (count(EditionStatement) le 1) or count(EditionStatement) eq count(distinct-values(EditionStatement/@language))"/>
			<xs:assert id="_20171126_f_1" test="(: Repeats of Extent must each have a unique combination of valid ExtentType and ExtentUnit :) count(Extent) eq count(distinct-values(Extent/string-join((ExtentType | ExtentUnit), ' ')))"/>
			<xs:assert id="_20171221_d_1" test="(: Repeats of AncillaryContent must each have a unique AncillaryContentType (unless type is 'unspecified') :) count(AncillaryContent[AncillaryContentType ne '00']) eq count(distinct-values(AncillaryContent[AncillaryContentType ne '00']/AncillaryContentType))"/>
			<xs:assert id="_20171218_f_1" test="(: Repeats of Language must each have a unique combination of valid LanguageRole, LanguageCode, CountryCode and ScriptCode :) count(Language) eq count(distinct-values(Language/string-join((LanguageRole | LanguageCode | CountryCode | ScriptCode), ' ')))"/>
			<xs:assert id="_20171218_f_2" test="(: Original language of a translation must be distinct from the language of the main text :) count(Language[matches(LanguageRole, '^(01|02)$')]) eq count(distinct-values(Language[matches(LanguageRole, '^(01|02)$')]/string-join((LanguageCode | CountryCode | ScriptCode), ' ')))"/>
			<xs:assert id="_20171218_f_3" test="(: Language of abstracts must be distinct from the language of the main text :) count(Language[matches(LanguageRole, '^(01|03)$')]) eq count(distinct-values(Language[matches(LanguageRole, '^(01|03)$')]/string-join((LanguageCode | CountryCode | ScriptCode), ' ')))"/>
			<xs:assert id="_20171218_f_4" test="(: Language of notes must be distinct from the language of the main text :) count(Language[matches(LanguageRole, '^(01|12)$')]) eq count(distinct-values(Language[matches(LanguageRole, '^(01|12)$')]/string-join((LanguageCode | CountryCode | ScriptCode), ' ')))"/>
			<xs:assert id="_20171208_a_11" test="(: Repeats of IllustrationsNote must each have a unique language attribute :) (count(IllustrationsNote) le 1) or count(IllustrationsNote) eq count(distinct-values(IllustrationsNote/@language))"/>
			<xs:assert id="_20171218_b_1" test="(: Repeats of Subject must each have a unique combination of valid SubjectSchemeIdentifier, SubjectSchemeName, SubjectSchemeVersion, SubjectCode (or SubjectHeadingText if there is no code) :) count(Subject) eq count(distinct-values(Subject/string-join((SubjectSchemeIdentifier | SubjectSchemeName | SubjectSchemeVersion | (if (exists(SubjectCode)) then SubjectCode else SubjectHeadingText)), ' ')))"/>
			<xs:assert id="_20171218_c_1" test="(: Repeats of Subject with MainSubject must each have a unique combination of valid SubjectSchemeIdentifier, SubjectSchemeName and SubjectSchemeVersion :) count(Subject[exists(MainSubject)]) eq count(distinct-values(Subject[exists(MainSubject)]/string-join((SubjectSchemeIdentifier | SubjectSchemeName | SubjectSchemeVersion), ' ')))"/>
			<xs:assert id="_20171218_e_1" test="(: A BISAC regional or merchandising theme in SubjectCode requires a repeat of Subject carrying a BISAC subject code :) exists(Subject[SubjectSchemeIdentifier eq '10']) or not(exists(Subject[matches(SubjectSchemeIdentifier, '^(11|22)$')]))"/>
			<xs:assert id="_20171218_e_2" test="(: A BIC qualifier in SubjectCode requires a repeat of Subject carrying a BIC subject code :) exists(Subject[SubjectSchemeIdentifier eq '12']) or not(exists(Subject[matches(SubjectSchemeIdentifier, '^(13|14|15|16|17)$')]))"/>
			<xs:assert id="_20171218_e_3" test="(: A Thema qualifier in SubjectCode requires a repeat of Subject carrying a Thema subject code :) exists(Subject[SubjectSchemeIdentifier eq '93']) or not(exists(Subject[matches(SubjectSchemeIdentifier, '^(94|95|96|97|98|99)$')]))"/>
			<xs:assert id="_20190107_g_1" test="(: Thema Narrative theme cannot be a main subject :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '93'][matches(SubjectCode, '^FX.*$')]))"/>
			<xs:assert id="_20190107_g_2" test="(: Thema Narrative theme or Special feature must be accompanied by another Thema subject code :) not(exists(Subject[SubjectSchemeIdentifier eq '93'][matches(SubjectCode, '^(FX|FY).*$')])) or exists(Subject[SubjectSchemeIdentifier eq '93'][not(matches(SubjectCode, '^(FX|FY)$'))])"/>
			<xs:assert id="_20190107_a_1" test="(: ONIX audience code must be consistent with Thema main subject code indicating for children or teenagers :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '93'][matches(SubjectCode, '^(YB|YD|YF|YN|YR|YX|YZ).*$')]) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][matches(AudienceCodeValue, '^(02|03)$')])"/>
			<xs:assert id="_20190107_a_2" test="(: ONIX audience code must be consistent with Thema main subject code indicating for child or teenage education :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '93'][matches(SubjectCode, '^(YP).*$')]) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][AudienceCodeValue eq '04'])"/>
			<xs:assert id="_20190107_a_3" test="(: ONIX audience code must be consistent with BIC main subject code indicating for children or teenagers :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '12'][matches(SubjectCode, '^(YB|YD|YF|YN|YR|YX|YZ).*$')]) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][matches(AudienceCodeValue, '^(02|03)$')])"/>
			<xs:assert id="_20190107_a_4" test="(: ONIX audience code must be consistent with BIC main subject code indicating for child or teenage education :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '12'][matches(SubjectCode, '^(YQ).*$')]) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][AudienceCodeValue eq '04'])"/>
			<xs:assert id="_20190107_b_1" test="(: ONIX audience code must be consistent with BISAC main subject code indicating for children or teenagers :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '10'][matches(SubjectCode, '^(JUV|JNF).{6}$')]) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][matches(AudienceCodeValue, '^(02|04)$')])"/>
			<xs:assert id="_20190107_b_2" test="(: ONIX audience code must be consistent with BISAC main subject code indicating for young adult :) not(exists(Subject[MainSubject][SubjectSchemeIdentifier eq '10'][matches(SubjectCode, '^(YAF|YAN).{6}$')]) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][matches(AudienceCodeValue, '^(03|04)$')])"/>
			<xs:assert id="_20190107_c_1" test="(: ONIX audience code must be consistent with CBMC :) not(exists(Subject[SubjectSchemeIdentifier eq '21']) and exists(Audience[AudienceCodeType eq '01'])) or exists(Audience[AudienceCodeType eq '01'][matches(AudienceCodeValue, '^(02|03)$')])"/>
			<xs:assert id="_20190107_d_1" test="(: Thema Interest qualifiers may only include one From… age :) count(Subject[SubjectSchemeIdentifier eq '98'][matches(SubjectCode, '^5A[BCDFGHJKLMNPQSTU].*$')]) le 1"/>
			<xs:assert id="_20190107_d_2" test="(: BIC Interest qualifiers may only include one From… age :) count(Subject[SubjectSchemeIdentifier eq '17'][matches(SubjectCode, '^5A[BQ].*$')]) le 1"/>
			<xs:assert id="_20190107_e_1" test="(: Thema main subject code must be consistent with child/teen-only ONIX audience code :) not(exists(Audience[AudienceCodeType eq '01']) and exists(Subject[MainSubject][SubjectSchemeIdentifier eq '93']) and not(exists(Audience[AudienceCodeType eq '01'][not(matches(AudienceCodeValue, '^(02|03)$'))]))) or matches(Subject[MainSubject][SubjectSchemeIdentifier eq '93']/SubjectCode, '^(YB|YD|YF|YN|YR|YX|YZ|X).*$')"/>
			<xs:assert id="_20190107_e_2" test="(: BIC main subject code must be consistent with single ONIX audience code :) not(exists(Audience[AudienceCodeType eq '01']) and exists(Subject[MainSubject][SubjectSchemeIdentifier eq '12']) and not(exists(Audience[AudienceCodeType eq '01'][not(matches(AudienceCodeValue, '^(02|03)$'))]))) or matches(Subject[MainSubject][SubjectSchemeIdentifier eq '12']/SubjectCode, '^(YB|YD|YF|YN|YR|YX|YZ|X).*$')"/>
			<xs:assert id="_20190107_f_1" test="(: Thema main subject code must be consistent with education-only ONIX audience code :) not(exists(Audience[AudienceCodeType eq '01']) and exists(Subject[MainSubject][SubjectSchemeIdentifier eq '93']) and not(exists(Audience[AudienceCodeType eq '01'][AudienceCodeValue ne '04']))) or matches(Subject[MainSubject][SubjectSchemeIdentifier eq '93']/SubjectCode, '^YP.*$')"/>
			<xs:assert id="_20190107_f_2" test="(: BIC main subject code must be consistent with education-only ONIX audience code :) not(exists(Audience[AudienceCodeType eq '01']) and exists(Subject[MainSubject][SubjectSchemeIdentifier eq '12']) and not(exists(Audience[AudienceCodeType eq '01'][AudienceCodeValue ne '04']))) or matches(Subject[MainSubject][SubjectSchemeIdentifier eq '12']/SubjectCode, '^YQ.*$')"/>
			<xs:assert id="_20171208_l_1" test="(: Repeats of Audience must each have a unique combination of valid AudienceCodeType, AudienceCodeTypeName and AudienceCodeValue :) count(Audience) eq count(distinct-values(Audience/string-join((AudienceCodeType | AudienceCodeTypeName | AudienceCodeValue), ' ')))"/>
			<xs:assert id="_20180308_d_1" test="(: ONIX adult content ratings are applicable only to books aimed at the general adult audience :) not(exists(Audience[AudienceCodeType eq '22']) and exists(Audience[AudienceCode eq '01'])) or exists(Audience[AudienceCodeType eq '01'][AudienceCodeValue eq '01'])"/>
			<xs:assert id="_20180324_e_1" test="(: Repeats of AudienceRange must each have a unique AudienceRangeQualifier :) count(AudienceRange) eq count(distinct-values(AudienceRange/AudienceRangeQualifier))"/>
			<xs:assert id="_20171208_a_12" test="(: Repeats of AudienceDescription must each have a unique language attribute :) (count(AudienceDescription) le 1) or count(AudienceDescription) eq count(distinct-values(AudienceDescription/@language))"/>
			<xs:assert id="_20171219_h_1" test="(: Repeats of Complexity must each have a unique ComplexitySchemeIdentifier :) count(Complexity) eq count(distinct-values(Complexity/ComplexitySchemeIdentifier))"/>
			<xs:assert id="_20191031_d_1" test="(: Multiple proprietary Product classifications must include ProductClassificationTypeName :) (count(ProductClassification[ProductClassificationType eq '07']) le 1) or count(ProductClassification[ProductClassificationType eq '07'][exists(ProductClassificationTypeName)]) eq count(ProductClassification[ProductClassificationType eq '07'])"/>
		</xs:complexType>
		<xs:unique name="ProductFormDetail_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductFormDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="ProductFormDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductFormDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="ProductContentType_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PrimaryContentType|onix:ProductContentType"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="Measure_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:Measure"/>
			<xs:field xpath="onix:MeasureType"/>
			<xs:field xpath="onix:MeasureUnitCode"/>
		</xs:unique>
		<xs:unique name="Contributor_SequenceNumber_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:Contributor"/>
			<xs:field xpath="onix:SequenceNumber"/>
		</xs:unique>
		<xs:unique name="ContributorStatement_languge_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ContributorStatement"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="IllustrationsNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:IllustrationsNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="EditionType_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EditionType"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="EditionStatement_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EditionStatement"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="AudienceDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:AudienceDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="Discount">
		<xs:annotation>
			<xs:documentation>Added &lt;ToQuantity> at revison 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="DiscountType"/>
				<xs:sequence minOccurs="0">
					<xs:element ref="Quantity"/>
					<xs:element minOccurs="0" ref="ToQuantity"/>
				</xs:sequence>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="DiscountPercent"/>
						<xs:element minOccurs="0" ref="DiscountAmount"/>
					</xs:sequence>
					<xs:element ref="DiscountAmount"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Discount"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="discount"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountAmount">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DiscountAmount"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x469"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DiscountCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j364"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountCoded">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="DiscountCodeType"/>
				<xs:element minOccurs="0" ref="DiscountCodeTypeName"/>
				<xs:element ref="DiscountCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="DiscountCoded"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="discountcoded"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180517_d_1" test="(: Discount code must be a plausible BIC discount code :) (DiscountCodeType ne '01') or matches(DiscountCode, '^[A-Z]{5}[A-Za-z0-9]{1,3}$')"/>
			<xs:assert id="_20180517_d_2" test="(: Discount code must be a plausible BIC commission code :) (DiscountCodeType ne '06') or matches(DiscountCode, '^[A-Z]{5}[A-Za-z0-9]{1,3}$')"/>
			<xs:assert id="_20180517_e_1" test="(: There must be an DiscountCodeTypeName if (and only if) DiscountCodeType is proprietary :) (matches(DiscountCodeType, '^(02|05)$')) eq exists(DiscountCodeTypeName)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountCodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List100">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DiscountCodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j363"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountCodeTypeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DiscountCodeTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j378"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountPercent">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PercentDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DiscountPercent"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j267"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="DiscountType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List170">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="DiscountType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x467"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EditionNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EditionNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b057"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EditionStatement">
		<xs:annotation>
			<xs:documentation>Modified base type from NonEmptyString, added textformat attribute at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EditionStatement"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b058"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_19" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_20" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_10" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_10" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_10" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_10" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EditionType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List21">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EditionType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x419"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EditionVersionNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EditionVersionNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b217"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EmailAddress">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.EmailString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EmailAddress"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j272"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EndDate">
		<xs:annotation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EndDate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b325"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_29" test="(: Date must be in YYYYMMDD format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_30" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_31" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_32" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_33" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_34" test="(: Date must be in YYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_35" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_36" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_37" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_38" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_39" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_40" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_41" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_42" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EndTime">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.TimeOrDuration">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EndTime"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x543"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubLicense">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="EpubLicenseName"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EpubLicenseExpression"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EpubLicense"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="epublicense"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_46" test="(: Repeats of EpubLicenseName must each have a unique language attribute :) (count(EpubLicenseName) le 1) or count(EpubLicenseName) eq count(distinct-values(EpubLicenseName/@language))"/>
		</xs:complexType>
		<xs:unique name="EpubLicenseName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EpubLicenseName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="EpubLicenseExpression">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EpubLicenseExpressionType"/>
				<xs:element minOccurs="0" ref="EpubLicenseExpressionTypeName"/>
				<xs:element ref="EpubLicenseExpressionLink"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EpubLicenseExpression"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="epublicenseexpression"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubLicenseExpressionLink">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyURI">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubLicenseExpressionLink"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x510"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:assert id="_20181210_a_1" test="(: URI must not contain an empty hostname :) not(matches(., '///'))"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubLicenseExpressionType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List218">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubLicenseExpressionType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x508"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubLicenseExpressionTypeName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubLicenseExpressionTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x509"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubLicenseName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubLicenseName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x511"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubTechnicalProtection">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List144">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubTechnicalProtection"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x317"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubUsageConstraint">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EpubUsageType"/>
				<xs:element ref="EpubUsageStatus"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EpubUsageLimit"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EpubUsageConstraint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="epubusageconstraint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_h_1" test="(: EpubUsgeLimit can only occur if EpubUsageStatus is 'restricted' :) (EpubUsageStatus eq '02') or not(exists(EpubUsageLimit))"/>
			<xs:assert id="_20171212_h_2" test="(: Repeats of EpubUsageLimit must each have a unique EpubUsageUnit :) count(EpubUsageLimit) eq count(distinct-values(EpubUsageLimit/EpubUsageUnit))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubUsageLimit">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Quantity"/>
				<xs:element ref="EpubUsageUnit"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EpubUsageLimit"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="epubusagelimit"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubUsageStatus">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List146">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubUsageStatus"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x319"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubUsageType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List145">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubUsageType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x318"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EpubUsageUnit">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List147">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EpubUsageUnit"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x321"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Event">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EventRole"/>
				<xs:element ref="EventName" maxOccurs="unbounded"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EventAcronym"/>
				<xs:element minOccurs="0" ref="EventNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EventTheme"/>
				<xs:element minOccurs="0" ref="EventDate"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EventPlace"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EventSponsor"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Event"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="event"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_13" test="(: Repeats of EventName must each have a unique language attribute :) (count(EventName) le 1) or count(EventName) eq count(distinct-values(EventName/@language))"/>
			<xs:assert id="_20171208_a_14" test="(: Repeats of EventAcronym must each have a unique language attribute :) (count(EventAcronym) le 1) or count(EventAcronym) eq count(distinct-values(EventAcronym/@language))"/>
			<xs:assert id="_20171208_a_15" test="(: Repeats of EventTheme must each have a unique language attribute :) (count(EventTheme) le 1) or count(EventTheme) eq count(distinct-values(EventTheme/@language))"/>
			<xs:assert id="_20171208_a_16" test="(: Repeats of EventPlace must each have a unique language attribute :) (count(EventPlace) le 1) or count(EventPlace) eq count(distinct-values(EventPlace/@language))"/>
		</xs:complexType>
		<xs:unique name="EventName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="EventAcronym_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventAcronym"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="EventTheme_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventTheme"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="EventPlace_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventPlace"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="EventAcronym">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventAcronym"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x517"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventDate">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventDate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x520"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_43" test="(: Date must be in YYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_44" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_45" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_46" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_47" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_48" test="(: Date must be in YYYY format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_49" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_50" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_51" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_52" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_53" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_54" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_55" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_56" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventDescription">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x550"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_21" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_22" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_11" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_11" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_11" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_11" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EventIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EventIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="eventidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20210429_e_1" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (EventIDType eq '01') eq exists(IDTypeName)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List244">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x547"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x516"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventNumber">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x518"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventOccurrence">
		<xs:annotation>
			<xs:documentation>Added &lt;SupportingResource> at revision 3.0.8</xs:documentation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EventIdentifier" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="OccurrenceDate" maxOccurs="unbounded"/>
				<xs:element ref="EventStatus"/>
				<xs:sequence minOccurs="0">
					<!-- for physical only -->
					<xs:choice>
						<xs:sequence>
							<xs:element ref="CountryCode"/>
							<xs:element ref="RegionCode" minOccurs="0"/>
						</xs:sequence>
						<xs:element ref="RegionCode"/>
					</xs:choice>
					<xs:element ref="LocationName" maxOccurs="unbounded"/>
					<xs:element ref="VenueName"/>
					<xs:element ref="StreetAddress" minOccurs="0"/>
					<xs:element ref="VenueNote" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:element ref="EventDescription" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="SupportingResource" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="EventSponsor" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="Website" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EventOccurrence"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="eventoccurrence"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20191031_b_1" test="(: The region must be within the country :) not(exists(RegionCode) and exists(CountryCode)) or starts-with(RegionCode, CountryCode)"/>
			<xs:assert id="_20210429_a_1" test="(: Repeats of LocationName must each have a unique language attribute :) (count(LocationName) le 1) or count(LocationName) eq count(distinct-values(LocationName/@language))"/>
			<xs:assert id="_20210429_a_2" test="(: Repeats of EventDescription must each have a unique language attribute :) (count(EventDescription) le 1) or count(EventDescription) eq count(distinct-values(EventDescription/@language))"/>
			<xs:assert id="_20210429_a_3" test="(: Repeats of VenueNote must each have a unique language attribute :) (count(VenueNote) le 1) or count(VenueNote) eq count(distinct-values(VenueNote/@language))"/>
		</xs:complexType>
		<xs:unique name="EventOccurrence_LocationName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:LocationName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="EventOccurrence_EventDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="VenueNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:VenueNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="EventPlace">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventPlace"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x521"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventRole">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List20">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x515"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventSponsor">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" ref="EventSponsorIdentifier"/>
					<xs:choice minOccurs="0">
						<xs:element ref="PersonName"/>
						<xs:element ref="CorporateName"/>
					</xs:choice>
				</xs:sequence>
				<xs:element ref="PersonName"/>
				<xs:element ref="CorporateName"/>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EventSponsor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="eventsponsor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_8" test="(: Repeats of EventSponsorIdentifier must each have a unique combination of valid EventSponsorIDType, IDTypeName and IDValue :) count(EventSponsorIdentifier) eq count(distinct-values(EventSponsorIdentifier/string-join((EventSponsorIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventSponsorIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EventSponsorIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="EventSponsorIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="eventsponsoridentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_30" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(EventSponsorIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_31" test="(: IDValue must be a valid GLN (invalid characters) :) (EventSponsorIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_32" test="(: IDValue must be a valid GLN (check digit error) :) (EventSponsorIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_33" test="(: IDValue must be a valid SAN (invalid characters) :) (EventSponsorIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_34" test="(: IDValue must be a valid SAN (check digit error) :) (EventSponsorIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171221_j_35" test="(: IDValue must be a valid ISNI (invalid characters) :) (EventSponsorIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_36" test="(: IDValue must be a valid ISNI (check digit error) :) (EventSponsorIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_37" test="(: IDValue must be a valid ORCID (invalid characters) :) (EventSponsorIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_38" test="(: IDValue must be a valid ORCID (check digit error) :) (EventSponsorIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_39" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (EventSponsorIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171221_j_40" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (EventSponsorIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171221_j_41" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (EventSponsorIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventSponsorIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventSponsorIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x522"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventStatus">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List246">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventStatus"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x549"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventTheme">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventTheme"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x519"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="EventType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List245">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="EventType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x548"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ExpectedDate">
		<xs:annotation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ExpectedDate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j302"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_57" test="(: Date must be in YYYYMMDD format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_58" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_59" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_60" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_61" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_62" test="(: Date must be in YYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_63" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_64" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_65" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_66" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_67" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_68" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_69" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_70" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Extent">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ExtentType"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="ExtentValue"/>
						<xs:element minOccurs="0" ref="ExtentValueRoman"/>
					</xs:sequence>
					<xs:element ref="ExtentValueRoman"/>
				</xs:choice>
				<xs:element ref="ExtentUnit"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Extent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="extent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_f_2" test="(: ExtentUnit must be 'pages' :) not(matches(ExtentType, '^(00|03|04|05|06|07|08|10|11|12)$')) or ExtentUnit eq '03'"/>
			<xs:assert id="_20171126_f_3" test="(: ExtentUnit must be 'characters' or 'words' :) (ExtentType ne '02') or matches(ExtentUnit, '^(01|02)$')"/>
			<xs:assert id="_20171126_f_4" test="(: ExtentUnit must be 'hours', 'minutes' etc :) not(matches(ExtentType, '^(09|13|14|15|16)$')) or matches(ExtentUnit, '^(04|05|06|11|12|14|15|16)$')"/>
			<xs:assert id="_20171126_f_5" test="(: ExtentUnit must be 'kilobytes', 'megabytes' etc :) (ExtentType ne '22') or matches(ExtentUnit, '^(17|18|19)$')"/>
			<xs:assert id="_20180118_a_1" test="(: ExtentValue must be an integer :) not(matches(ExtentUnit, '^(01|02|03|06|11|12|17)$')) or matches(string(ExtentValue), '^[1-9][0-9]*$')"/>
			<xs:assert id="_20180118_a_2" test="(: ExtentValue must match HHH :) (ExtentUnit ne '14') or matches(string(ExtentValue), '^[0-9]{3}$')"/>
			<xs:assert id="_20180118_a_3" test="(: ExtentValue must match HHHmm :) (ExtentUnit ne '15') or matches(string(ExtentValue), '^[0-9]{3}[0-5][0-9]$')"/>
			<xs:assert id="_20180118_a_4" test="(: ExtentValue must match HHHmmss or HHHmmsscc:) (ExtentUnit ne '16') or matches(string(ExtentValue), '^[0-9]{3}[0-5][0-9][0-5][0-9]([0-9]{2})?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ExtentType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List23">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ExtentType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b218"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ExtentUnit">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List24">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ExtentUnit"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b220"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ExtentValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ExtentValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b219"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ExtentValueRoman">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.RomanNumeralString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ExtentValueRoman"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x421"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FaxNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FaxNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j271"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FeatureNote">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FeatureNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x440"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_23" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_24" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_12" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_12" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_12" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_12" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FeatureValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FeatureValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x439"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FirstPageNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FirstPageNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b286"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FreeQuantity">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FreeQuantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j265"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="FromLanguage">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List74">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FromLanguage"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x412"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Funding">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="FundingIdentifier"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Funding"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="funding"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_9" test="(: Repeats of FundingIdentifier must each have a unique combination of valid FundingIDType, IDTypeName and IDValue :) count(FundingIdentifier) eq count(distinct-values(FundingIdentifier/string-join((FundingIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="FundingIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="FundingIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="FundingIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="fundingidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_42" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (FundingIDType eq '01') eq exists(IDTypeName)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="FundingIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List228">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="FundingIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x523"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Gender">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List229">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Gender"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x524"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Header">
		<xs:annotation>
			<xs:documentation>Container for message metadata</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;MessageNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Sender"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Addressee"/>
				<xs:element minOccurs="0" ref="MessageNumber"/>
				<xs:element minOccurs="0" ref="MessageRepeat"/>
				<xs:element ref="SentDateTime"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="MessageNote"/>
				<xs:element minOccurs="0" ref="DefaultLanguageOfText"/>
				<xs:element minOccurs="0" ref="DefaultPriceType"/>
				<xs:element minOccurs="0" ref="DefaultCurrencyCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Header"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="header"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_17" test="(: Repeats of MessageNote must each have a unique language attribute :) (count(MessageNote) le 1) or count(MessageNote) eq count(distinct-values(MessageNote/@language))"/>
		</xs:complexType>
		<xs:unique name="MessageNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:MessageNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="IDTypeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="IDTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b233"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="IDValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="IDValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b244"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Illustrated">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List152">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Illustrated"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x422"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="IllustrationsNote">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="IllustrationsNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b062"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_25" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_26" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_13" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_13" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_13" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_13" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Imprint">
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" ref="ImprintIdentifier"/>
					<xs:element minOccurs="0" ref="ImprintName"/>
				</xs:sequence>
				<xs:element ref="ImprintName"/>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Imprint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="imprint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_10" test="(: Repeats of ImprintIdentifier must each have a unique combination of valid ImprintIDType, IDTypeName and IDValue :) count(ImprintIdentifier) eq count(distinct-values(ImprintIdentifier/string-join((ImprintIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ImprintIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ImprintIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ImprintIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="imprintidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_b_13" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(ImprintIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_b_14" test="(: IDValue must be a valid GLN (invalid characters) :) (ImprintIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_b_15" test="(: IDValue must be a valid GLN (check digit error) :) (ImprintIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_b_16" test="(: IDValue must be a valid SAN (invalid characters) :) (ImprintIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_17" test="(: IDValue must be a valid SAN (check digit error) :) (ImprintIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_b_18" test="(: IDValue must be a valid ISNI (invalid characters) :) (ImprintIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_19" test="(: IDValue must be a valid ISNI (check digit error) :) (ImprintIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_20" test="(: IDValue must be a valid ORCID (invalid characters) :) (ImprintIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_21" test="(: IDValue must be a valid ORCID (check digit error) :) (ImprintIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_22" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (ImprintIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171126_b_23" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (ImprintIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171126_b_24" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (ImprintIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ImprintIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ImprintIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x445"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ImprintName">
		<xs:annotation>
			<xs:documentation>Added collationkey attribute at revision 3.0.7</xs:documentation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ImprintName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b079"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="InitialPrintRun">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="InitialPrintRun"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="k167"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_27" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_28" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_14" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_14" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_14" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_14" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="KeyNames">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="KeyNames"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b040"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Language">
		<xs:annotation>
			<xs:documentation>Added &lt;RegionCode at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="LanguageRole"/>
				<xs:element ref="LanguageCode"/>
				<xs:element minOccurs="0" ref="CountryCode"/>
				<xs:element minOccurs="0" ref="RegionCode"/>
				<xs:element minOccurs="0" ref="ScriptCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Language"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="language"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20191031_b_2" test="(: The region must be within the country :) not(exists(CountryCode) and exists(RegionCode)) or starts-with(RegionCode, CountryCode)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="LanguageCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List74">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LanguageCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b252"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LanguageRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List22">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LanguageRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b253"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LastPageNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LastPageNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b287"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LatestReprintNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LatestReprintNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x446"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LettersAfterNames">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LettersAfterNames"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b042"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LevelSequenceNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.MultiLevelNumber">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LevelSequenceNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b284"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ListName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ListName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x432"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LocationIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="LocationIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="LocationIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="locationidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_43" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(LocationIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_44" test="(: IDValue must be a valid GLN (invalid characters) :) (LocationIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_45" test="(: IDValue must be a valid GLN (check digit error) :) (LocationIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_46" test="(: IDValue must be a valid SAN (invalid characters) :) (LocationIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_47" test="(: IDValue must be a valid SAN (check digit error) :) (LocationIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="LocationIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List92">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LocationIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j377"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="LocationName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="LocationName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j349"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MainSubject">
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="MainSubject"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x425"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="MapScale">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MapScale"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b063"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Market">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Territory"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesRestriction"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Market"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="market"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20190710_h_1" test="(: No restrictions must be the only restriction :) not(exists(SalesRestriction[SalesRestrictionType eq '99'])) or count(SalesRestriction) eq 1"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="MarketDate">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;DateFormat> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="MarketDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="MarketDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="marketdate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_d_15" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20171208_d_16" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20171208_d_17" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20171208_d_18" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_19" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_20" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20171208_d_21" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20171208_d_22" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_23" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_24" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_25" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_26" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20171208_d_27" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20171208_d_28" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="MarketDateRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List163">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MarketDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j408"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MarketPublishingDetail">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;PromotionCampaign>, &lt;InitialPrintRun>, &lt;CopiesSold>, &lt;BookClubAdoption> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;MarketPublishingStatusNote> at revision 3.0.1</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;MarketDate> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PublisherRepresentative"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductContact"/>
				<xs:element ref="MarketPublishingStatus"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="MarketPublishingStatusNote"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="MarketDate"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PromotionCampaign"/>
				<xs:element minOccurs="0" ref="PromotionContact"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="InitialPrintRun"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ReprintDetail"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="CopiesSold"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="BookClubAdoption"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="MarketPublishingDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="marketpublishingdetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180214_d_1" test="(: If MarketPublishingStatus is 'Cancelled', market publication date must not be sent :) (MarketPublishingStatus ne '01') or not(exists(MarketDate[MarketDateRole eq '01']))"/>
			<xs:assert id="_20180214_d_2" test="(: If MarketPublishingStatus is 'Postponed indefinitely', market publication date must not be sent :) (MarketPublishingStatus ne '03') or not(exists(MarketDate[MarketDateRole eq '01']))"/>
			<xs:assert id="_20171208_e_3" test="(: Repeats of MarketDate must each have a unique MarketDateRole :) count(MarketDate) eq count(distinct-values(MarketDate/MarketDateRole))"/>
			<xs:assert id="_20171208_a_18" test="(: Repeats of MarketPublishingStatusNote must each have a unique language attribute :) (count(MarketPublishingStatusNote) le 1) or count(MarketPublishingStatusNote) eq count(distinct-values(MarketPublishingStatusNote/@language))"/>
			<xs:assert id="_20171208_a_19" test="(: Repeats of PromotionCampaign must each have a unique language attribute :) (count(PromotionCampaign) le 1) or count(PromotionCampaign) eq count(distinct-values(PromotionCampaign/@language))"/>
			<xs:assert id="_20171208_a_20" test="(: Repeats of InitialPrintRun must each have a unique language attribute :) (count(InitialPrintRun) le 1) or count(InitialPrintRun) eq count(distinct-values(InitialPrintRun/@language))"/>
			<xs:assert id="_20171208_a_21" test="(: Repeats of ReprintDetail must each have a unique language attribute :) (count(ReprintDetail) le 1) or count(ReprintDetail) eq count(distinct-values(ReprintDetail/@language))"/>
			<xs:assert id="_20171208_a_22" test="(: Repeats of CopiesSold must each have a unique language attribute :) (count(CopiesSold) le 1) or count(CopiesSold) eq count(distinct-values(CopiesSold/@language))"/>
			<xs:assert id="_20171208_a_23" test="(: Repeats of BookClubAdoption must each have a unique language attribute :) (count(BookClubAdoption) le 1) or count(BookClubAdoption) eq count(distinct-values(BookClubAdoption/@language))"/>
		</xs:complexType>
		<xs:unique name="MarketPublishingStatusNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:MarketPublishingStatusNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="PromotionCampaign_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PromotionCampaign"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="InitialPrintRun_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:InitialPrintRun"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="ReprintDetail_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ReprintDetail"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="CopiesSold_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:CopiesSold"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="BookClubAdoption_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:BookClubAdoption"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="MarketPublishingStatus">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List68">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MarketPublishingStatus"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j407"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MarketPublishingStatusNote">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MarketPublishingStatusNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x406"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_29" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_30" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_15" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_15" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_15" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_15" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Measure">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="MeasureType"/>
				<xs:element ref="Measurement"/>
				<xs:element ref="MeasureUnitCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Measure"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="measure"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_g_1" test="(: Linear measurements must use units of length (mm, in, etc) :) matches(MeasureType, '^(01|02|03|04|05|09|10|11|12|13|14|15|16|19|20|21|23|24|25)$') eq matches(MeasureUnitCode, '^(mm|cm|in|px)$')"/>
			<xs:assert id="_20171212_g_2" test="(: Weight measurements must use units of mass (gr, oz, etc) :) matches(MeasureType, '^(08|17|18)$') eq matches(MeasureUnitCode, '^(gr|kg|oz|lb)$')"/>
			<xs:assert id="_20181026_d_1" test="(: Linear measurement in mm must be credible :) (not(matches(MeasureUnitCode, 'mm')) or not(matches(MeasureType, '^(01|02|04|05|09|10|11|12|13|14|15|19|20|21|23|24|25|27|28|29)$'))) or Measurement ge 10"/>
			<xs:assert id="_20181026_d_2" test="(: Linear measurement in cm must be credible :) (not(matches(MeasureUnitCode, 'cm')) or not(matches(MeasureType, '^(01|02|04|05|09|10|11|12|13|14|15|19|20|21|23|24|25|27|28|29)$'))) or Measurement ge 1"/>
			<xs:assert id="_20181026_d_3" test="(: Linear measurement in in must be credible :) (not(matches(MeasureUnitCode, 'in')) or not(matches(MeasureType, '^(01|02|04|05|09|10|11|12|13|14|15|19|20|21|23|24|25|27|28|29)$'))) or Measurement ge 0.4"/>
			<xs:assert id="_20181026_d_4" test="(: Weight measurement in gr must be credible :) (not(matches(MeasureUnitCode, 'gr')) or not(matches(MeasureType, '08'))) or Measurement ge 5"/>
			<xs:assert id="_20181026_d_5" test="(: Weight measurement in kg must be credible :) (not(matches(MeasureUnitCode, 'kg')) or not(matches(MeasureType, '08'))) or Measurement ge 0.005"/>
			<xs:assert id="_20181026_d_6" test="(: Weight measurement in oz must be credible :) (not(matches(MeasureUnitCode, 'oz')) or not(matches(MeasureType, '08'))) or Measurement ge 0.175"/>
			<xs:assert id="_20181026_d_7" test="(: Weight measurement in lb must be credible :) (not(matches(MeasureUnitCode, 'lb')) or not(matches(MeasureType, '08'))) or Measurement ge 0.011"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="Measurement">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Measurement"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="c094"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MeasureType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List48">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MeasureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x315"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MeasureUnitCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List50">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MeasureUnitCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="c095"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MessageNote">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MessageNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m183"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MessageNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MessageNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m180"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MessageRepeat">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MessageRepeat"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m181"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="MinimumOrderQuantity">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="MinimumOrderQuantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j263"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NameAsSubject">
		<xs:annotation>
			<xs:documentation>Added &lt;AlternativeName>, &lt;SubjectDate>, &lt;ProfessionalAffiliation>, &lt;Gender> at revision 3.0.3</xs:documentation>
			<xs:documentation>Added &lt;CorporateNameInverted> at revision 3.0 (2010)</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;NameType> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="NameType"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="NameIdentifier"/>
						<xs:choice minOccurs="0">
							<xs:sequence>
								<xs:group ref="gp.unstructured_name"/>
								<xs:group minOccurs="0" ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:sequence>
								<xs:group ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:group ref="gp.corporate_name"/>
						</xs:choice>
					</xs:sequence>
					<xs:sequence>
						<xs:choice>
							<xs:sequence>
								<xs:group ref="gp.unstructured_name"/>
								<xs:group minOccurs="0" ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:sequence>
								<xs:group ref="gp.structured_name"/>
								<xs:element minOccurs="0" ref="Gender"/>
							</xs:sequence>
							<xs:group ref="gp.corporate_name"/>
						</xs:choice>
					</xs:sequence>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="AlternativeName"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SubjectDate"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProfessionalAffiliation"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NameAsSubject"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="nameassubject"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_11" test="(: Repeats of NameIdentifier must each have a unique combination of valid NameIDType, IDTypeName and IDValue :) count(NameIdentifier) eq count(distinct-values(NameIdentifier/string-join((NameIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171208_e_4" test="(: Repeats of SubjectDate must each have a unique SubjectDateRole :) count(SubjectDate) eq count(distinct-values(SubjectDate/SubjectDateRole))"/>
			<xs:assert id="_20180109_f_2" test="(: For repeats of SubjectDate with matching Birth and Death roles, the Birth date must precede the Death date :) if (exists(SubjectDate[SubjectDateRole eq '50']) and exists(SubjectDate[SubjectDateRole eq '51'])) then (if ((if (exists(SubjectDate[SubjectDateRole eq '50']/Date/@dateformat)) then SubjectDate[SubjectDateRole eq '50']/Date/@dateformat else if (exists(SubjectDate[SubjectDateRole eq '50']/DateFormat)) then SubjectDate[SubjectDateRole eq '50']/DateFormat else '00') eq (if (exists(SubjectDate[SubjectDateRole eq '51']/Date/@dateformat)) then SubjectDate[SubjectDateRole eq '51']/Date/@dateformat else if (exists(SubjectDate[SubjectDateRole eq '51']/DateFormat)) then SubjectDate[SubjectDateRole eq '51']/DateFormat else '00')) then (if ((if (contains(SubjectDate[SubjectDateRole eq '50']/Date, '+')) then (contains(SubjectDate[SubjectDateRole eq '51']/Date, '+') and (substring-after(SubjectDate[SubjectDateRole eq '50']/Date, '+') eq substring-after(SubjectDate[SubjectDateRole eq '51']/Date, '+'))) else not(contains(SubjectDate[SubjectDateRole eq '51']/Date, '+'))) and (if (contains(SubjectDate[SubjectDateRole eq '50']/Date, '-')) then (contains(SubjectDate[SubjectDateRole eq '51']/Date, '-') and (substring-after(SubjectDate[SubjectDateRole eq '50']/Date, '-') eq substring-after(SubjectDate[SubjectDateRole eq '51']/Date, '-'))) else not(contains(SubjectDate[SubjectDateRole eq '51']/Date, '-'))) and (matches(SubjectDate[SubjectDateRole eq '50']/Date, 'Z') eq matches(SubjectDate[SubjectDateRole eq '51']/Date, 'Z'))) then (SubjectDate[SubjectDateRole eq '50']/Date le SubjectDate[SubjectDateRole eq '51']/Date) else true()) else true()) else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NameIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="NameIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NameIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="nameidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_b_25" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(NameIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_b_26" test="(: IDValue must be a valid GLN (invalid characters) :) (NameIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_b_27" test="(: IDValue must be a valid GLN (check digit error) :) (NameIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_b_28" test="(: IDValue must be a valid SAN (invalid characters) :) (NameIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_29" test="(: IDValue must be a valid SAN (check digit error) :) (NameIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_b_30" test="(: IDValue must be a valid ISNI (invalid characters) :) (NameIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_31" test="(: IDValue must be a valid ISNI (check digit error) :) (NameIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_32" test="(: IDValue must be a valid ORCID (invalid characters) :) (NameIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_33" test="(: IDValue must be a valid ORCID (check digit error) :) (NameIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_34" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (NameIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171126_b_35" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (NameIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171126_b_36" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (NameIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NameIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NameIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x415"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NamesAfterKey">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NamesAfterKey"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b041"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NamesBeforeKey">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NamesBeforeKey"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b039"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NameType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List18">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NameType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x414"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NewSupplier">
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="SupplierIdentifier"/>
						<xs:element minOccurs="0" ref="SupplierName"/>
					</xs:sequence>
					<xs:element ref="SupplierName"/>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="FaxNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EmailAddress"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NewSupplier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="newsupplier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_12" test="(: Repeats of SupplierIdentifier must each have a unique combination of valid SupplierIDType, IDTypeName and IDValue :) count(SupplierIdentifier) eq count(distinct-values(SupplierIdentifier/string-join((SupplierIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoCollection">
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoCollection"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x411"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoContributor">
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoContributor"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="n339"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoEdition">
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoEdition"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="n386"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoPrefix">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoPrefix"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x501"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NoProduct">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="NoProduct"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x507"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="NotificationType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List1">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NotificationType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="a002"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Number">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Number"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b257"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NumberOfCopies">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NumberOfCopies"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x323"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NumberOfIllustrations">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NumberOfIllustrations"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b125"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NumberOfItemsOfThisForm">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NumberOfItemsOfThisForm"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x322"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="NumberOfPages">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="NumberOfPages"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b061"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OccurrenceDate">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="OccurrenceDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="OccurrenceDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="occurrencedate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_d_29" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and DateFormat eq '00')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20171208_d_30" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20171208_d_31" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20171208_d_32" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_33" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_34" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20171208_d_35" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20171208_d_36" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_37" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_38" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_39" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_40" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20171208_d_41" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and (DateFormat eq '13' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20171208_d_42" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="OccurrenceDateRole">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List247">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="OccurrenceDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x554"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OnHand">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.Integer">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="OnHand"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j350"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OnOrder">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="OnOrder"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j351"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OnOrderDetail">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="OnOrder"/>
				<xs:element minOccurs="0" ref="Proximity"/>
				<xs:element ref="ExpectedDate"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="OnOrderDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="onorderdetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="OrderQuantityMinimum">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="OrderQuantityMinimum"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x532"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OrderQuantityMultiple">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="OrderQuantityMultiple"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x533"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="OrderTime">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="OrderTime"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j144"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PackQuantity">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PackQuantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j145"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PageRun">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="FirstPageNumber"/>
				<xs:element minOccurs="0" ref="LastPageNumber"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PageRun"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="pagerun"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20181113_c_1" test="(: LastPageNumber must not be less than FirstPageNumber :) not(exists(LastPageNumber)) or not(matches(FirstPageNumber, '^[1-9][0-9]*$') and matches(LastPageNumber, '^[1-9][0-9]*$')) or number(LastPageNumber) ge number(FirstPageNumber)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PalletQuantity">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PalletQuantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x545"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PartNumber">
		<xs:annotation>
			<xs:documentation>Added language, textscript attributes at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PartNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x410"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Percent">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PercentDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Percent"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b337"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PersonName">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PersonName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b036"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PersonNameInverted">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PersonNameInverted"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b037"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PositionOnList">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PositionOnList"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x433"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PositionOnProduct">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List142">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PositionOnProduct"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x313"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrefixToKey">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrefixToKey"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b247"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Price">
		<xs:annotation>
			<xs:documentation>Added &lt;TaxExempt> at revision 3.0.5</xs:documentation>
			<xs:documentation>Added &lt;EpubTechnicalProtection> and &lt;EpubLicense> at revision 3.0.4</xs:documentation>
			<xs:documentation>Added &lt;UnpricedItemType>, &lt;PriceConstraint>, &lt; at revision 3.0.3</xs:documentation>
			<xs:documentation>Added &lt;PriceIdentifier> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;PriceTypeDescription> at revision 3.0.1</xs:documentation>
			<xs:documentation>Added &lt;PriceCoded>, &lt;ComparisonProductPrice> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceIdentifier"/>
				<xs:element minOccurs="0" ref="PriceType"/>
				<xs:element minOccurs="0" ref="PriceQualifier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EpubTechnicalProtection"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceConstraint"/>
				<xs:element minOccurs="0" ref="EpubLicense"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceTypeDescription"/>
				<xs:element minOccurs="0" ref="PricePer"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceCondition"/>
				<xs:element minOccurs="0" ref="MinimumOrderQuantity"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="BatchBonus"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="DiscountCoded"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Discount"/>
				<xs:element minOccurs="0" ref="PriceStatus"/>
				<xs:choice>
					<xs:sequence>
						<xs:choice>
							<xs:element ref="PriceAmount"/>
							<xs:element ref="PriceCoded"/>
						</xs:choice>
						<xs:choice minOccurs="0">
							<xs:element maxOccurs="unbounded" ref="Tax"/>
							<xs:element ref="TaxExempt"/>
						</xs:choice>
					</xs:sequence>
					<xs:element ref="UnpricedItemType"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="CurrencyCode"/>
				<xs:element minOccurs="0" ref="Territory"/>
				<xs:element minOccurs="0" ref="CurrencyZone"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ComparisonProductPrice"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceDate"/>
				<xs:sequence minOccurs="0">
					<xs:element ref="PrintedOnProduct"/>
					<xs:element minOccurs="0" ref="PositionOnProduct"/>
				</xs:sequence>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Price"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="price"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_13" test="(: Repeats of PriceIdentifier must each have a unique combination of valid PriceIDType, IDTypeName and IDValue :) count(PriceIdentifier) eq count(distinct-values(PriceIdentifier/string-join((PriceIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171216_a_3" test="(: Repeats of EpubTechnicalProtection must each be unique :) count(EpubTechnicalProtection) eq count(distinct-values(EpubTechnicalProtection))"/>
			<xs:assert id="_20171216_a_4" test="(: Repeats of EpubTechnicalProtection must not include 'none' :) not(exists(EpubTechnicalProtection[. eq '00'])) or count(EpubTechnicalProtection) eq 1"/>
			<xs:assert id="_20171212_k_1" test="(: Repeats of PriceConstraint must each have a unique PriceConstraintType :) count(PriceConstraint) eq count(distinct-values(PriceConstraint/PriceConstraintType))"/>
			<xs:assert id="_20171208_a_24" test="(: Repeats of PriceTypeDescription must each have a unique language attribute :) (count(PriceTypeDescription) le 1) or count(PriceTypeDescription) eq count(distinct-values(PriceTypeDescription/@language))"/>
			<xs:assert id="_20180927_a_1" test="(: Repeats of DiscountCoded must each have a unique DiscountCodeType :) (count(DiscountCoded) le 1) or count(DiscountCoded) eq count(distinct-values(DiscountCoded/DiscountCodeType))"/>
			<xs:assert id="_20171219_c_1" test="(: PriceTypes excluding tax must not include Tax detail :) matches(PriceType, '^(02|04|07|09|12|14|17|22|24|27|34|42)$') or not(exists(Tax))"/>
			<xs:assert id="_20181026_b_1" test="(: PriceTypes including tax must not include TaxExempt :) matches(PriceType, '^(01|03|05|06|08|11|13|15|21|23|25|31|32|33|41)$') or not(exists(TaxExempt))"/>
			<xs:assert id="_20171221_a_1" test="(: PriceAmount must equal TaxableAmount plus TaxAmount :) not(exists(PriceAmount)) or (count(Tax) ne 1) or not(exists(Tax/TaxableAmount)) or not(exists(Tax/TaxAmount)) or abs(PriceAmount - Tax[1]/TaxableAmount - Tax[1]/TaxAmount) lt 0.01"/>
			<xs:assert id="_20171221_a_2" test="(: PriceAmount must equal TaxableAmount plus TaxRatePercent multiplied by TaxableAmount :) not(exists(PriceAmount)) or (count(Tax) ne 1) or not(exists(Tax/TaxableAmount)) or not(exists(Tax/TaxRatePercent)) or abs(PriceAmount - Tax[1]/TaxableAmount - Tax[1]/TaxableAmount * Tax[1]/TaxRatePercent div 100) lt 0.01"/>
			<xs:assert id="_20171219_d_1" test="(: Repeats of Tax must each include TaxableAmount :) (count(Tax) le 1) or count(Tax) eq count(Tax/TaxableAmount)"/>
			<xs:assert id="_20171221_b_1" test="(: PriceAmount must equal the sum of the TaxableAmount plus TaxAmount within each repeat of Tax:) not(exists(PriceAmount)) or (count(Tax) le 1) or abs(PriceAmount - sum(Tax/TaxableAmount) - sum(Tax[exists(TaxAmount)]/TaxAmount) - sum(Tax[not(exists(TaxAmount))]/(TaxableAmount * TaxRatePercent div 100))) lt 0.01"/>
			<xs:assert id="_20171208_e_5" test="(: Repeats of PriceDate must each have a unique PriceDateRole :) count(PriceDate) eq count(distinct-values(PriceDate/PriceDateRole))"/>
			<xs:assert id="_20180109_e_1" test="(: For repeats of PriceDate with matching From and To roles, the From date must precede the To date :) if (exists(PriceDate[PriceDateRole eq '14']) and exists(PriceDate[PriceDateRole eq '15'])) then (if ((if (exists(PriceDate[PriceDateRole eq '14']/Date/@dateformat)) then PriceDate[PriceDateRole eq '14']/Date/@dateformat else if (exists(PriceDate[PriceDateRole eq '14']/DateFormat)) then PriceDate[PriceDateRole eq '14']/DateFormat else '00') eq (if (exists(PriceDate[PriceDateRole eq '15']/Date/@dateformat)) then PriceDate[PriceDateRole eq '15']/Date/@dateformat else if (exists(PriceDate[PriceDateRole eq '15']/DateFormat)) then PriceDate[PriceDateRole eq '15']/DateFormat else '00')) then (if ((if (contains(PriceDate[PriceDateRole eq '14']/Date, '+')) then (contains(PriceDate[PriceDateRole eq '15']/Date, '+') and (substring-after(PriceDate[PriceDateRole eq '14']/Date, '+') eq substring-after(PriceDate[PriceDateRole eq '15']/Date, '+'))) else not(contains(PriceDate[PriceDateRole eq '15']/Date, '+'))) and (if (contains(PriceDate[PriceDateRole eq '14']/Date, '-')) then (contains(PriceDate[PriceDateRole eq '15']/Date, '-') and (substring-after(PriceDate[PriceDateRole eq '14']/Date, '-') eq substring-after(PriceDate[PriceDateRole eq '15']/Date, '-'))) else not(contains(PriceDate[PriceDateRole eq '15']/Date, '-'))) and (matches(PriceDate[PriceDateRole eq '14']/Date, 'Z') eq matches(PriceDate[PriceDateRole eq '15']/Date, 'Z'))) then (PriceDate[PriceDateRole eq '14']/Date le PriceDate[PriceDateRole eq '15']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20171208_b_1" test="(: PositionOnProduct must be included if (and only if) PrintedOnProduct is 'yes' :) exists(PrintedOnProduct[. eq '02']) eq exists(PositionOnProduct)"/>
		</xs:complexType>
		<xs:unique name="PriceTypeDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PriceTypeDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="PriceAmount">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceAmount"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j151"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x468"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceCoded">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PriceCodeType"/>
				<xs:element minOccurs="0" ref="PriceCodeTypeName"/>
				<xs:element ref="PriceCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceCoded"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="pricecoded"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceCodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List179">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceCodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x465"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceCodeTypeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceCodeTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x477"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceCondition">
		<xs:annotation>
			<xs:documentation>Added &lt;ProductIdentifier> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PriceConditionType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceConditionQuantity"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductIdentifier"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceCondition"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="pricecondition"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_c_2" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_5" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_6" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_7" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_8" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConditionQuantity">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PriceConditionQuantityType"/>
				<xs:element ref="Quantity"/>
				<xs:element ref="QuantityUnit"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceConditionQuantity"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="priceconditionquantity"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConditionQuantityType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List168">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceConditionQuantityType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x464"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConditionType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List167">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceConditionType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x463"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConstraint">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PriceConstraintType"/>
				<xs:element ref="PriceConstraintStatus"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PriceConstraintLimit"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceConstraint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="priceconstraint"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_j_1" test="(: PriceConstraintLimit can only occur if PriceConstraintStatus is 'restricted' :) (PriceConstraintStatus eq '02') eq exists(PriceConstraintLimit)"/>
			<xs:assert id="_20171212_j_2" test="(: Repeats of PriceConstraintLimit must each have a unique PriceConstraintUnit :) count(PriceConstraintLimit) eq count(distinct-values(PriceConstraintLimit/PriceConstraintUnit))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConstraintLimit">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Quantity"/>
				<xs:element ref="PriceConstraintUnit"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceConstraintLimit"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="priceconstraintlimit"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConstraintStatus">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List146">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceConstraintStatus"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x530"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConstraintType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List230">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceConstraintType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x529"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceConstraintUnit">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List147">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceConstraintUnit"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x531"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceDate">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;DateFormat> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PriceDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="pricedate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_d_43" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20171208_d_44" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20171208_d_45" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20171208_d_46" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_47" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_48" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20171208_d_49" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20171208_d_50" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_51" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_52" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_53" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_54" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20171208_d_55" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20171208_d_56" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceDateRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List173">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x476"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PriceIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PriceIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="priceidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_48" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(PriceIDType, '^(01|02|03|04|05|06|07)$') eq exists(IDTypeName)"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List217">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x506"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PricePartDescription">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PricePartDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x535"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PricePer">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List60">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PricePer"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j239"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceQualifier">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List59">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceQualifier"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j261"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceStatus">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List61">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceStatus"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j266"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List58">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x462"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PriceTypeDescription">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PriceTypeDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j262"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrimaryContentType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List81">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrimaryContentType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x416"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrimaryPart">
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PrimaryPart"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x457"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrintedOnProduct">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List174">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrintedOnProduct"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x301"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Prize">
		<xs:annotation>
			<xs:documentation>Added &lt;PrizeRegion> at revision 3.0.7</xs:documentation>
			<xs:documentation>Added &lt;PrizeStatement> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;PrizeName> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;PrizeJury> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="PrizeName"/>
				<xs:element minOccurs="0" ref="PrizeYear"/>
				<xs:element minOccurs="0" ref="PrizeCountry"/>
				<xs:element minOccurs="0" ref="PrizeRegion"/>
				<xs:element minOccurs="0" ref="PrizeCode"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PrizeStatement"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PrizeJury"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Prize"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="prize"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_25" test="(: Repeats of PrizeName must each have a unique language attribute :) (count(PrizeName) le 1) or count(PrizeName) eq count(distinct-values(PrizeName/@language))"/>
			<xs:assert id="_20171208_a_26" test="(: Repeats of PrizeStatement must each have a unique language attribute :) (count(PrizeStatement) le 1) or count(PrizeStatement) eq count(distinct-values(PrizeStatement/@language))"/>
			<xs:assert id="_20171208_a_27" test="(: Repeats of PrizeJury must each have a unique language attribute :) (count(PrizeJury) le 1) or count(PrizeJury) eq count(distinct-values(PrizeJury/@language))"/>
			<xs:assert id="_20191031_b_3" test="(: The region must be within the country :) not(exists(PrizeRegion) and exists(PrizeCountry)) or starts-with(PrizeRegion, PrizeCountry)"/>
		</xs:complexType>
		<xs:unique name="PrizeName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PrizeName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="PrizeStatement_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PrizeStatement"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="PrizeJury_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PrizeJury"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="PrizeCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List41">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="g129"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrizeCountry">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List91">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeCountry"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="g128"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrizeJury">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeJury"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="g343"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_31" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_32" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_16" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_16" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_16" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_16" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrizeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="g126"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrizeRegion">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List49">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeRegion"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x556"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrizeStatement">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified base type from NonEmptyString, added textformat attribute at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeStatement"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x503"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_33" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_34" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_17" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_17" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_17" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_17" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PrizeYear">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.Year">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PrizeYear"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="g127"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Product">
		<xs:annotation>
			<xs:documentation>Container for details of a single product</xs:documentation>
			<xs:documentation>Added &lt;ProductionDetail> (Block 8) at revision 3.0.8</xs:documentation>
			<xs:documentation>Added &lt;PromotionDetail> (Block 7) at revision 3.0.7</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;DeletionText> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.record_metadata"/>
				<xs:group ref="gp.product_numbers"/>
				<xs:element minOccurs="0" ref="DescriptiveDetail"/>
				<xs:element minOccurs="0" ref="CollateralDetail"/>
				<xs:element minOccurs="0" ref="PromotionDetail"/>
				<xs:element minOccurs="0" ref="ContentDetail"/>
				<xs:element minOccurs="0" ref="PublishingDetail"/>
				<xs:element minOccurs="0" ref="RelatedMaterial"/>
				<xs:element minOccurs="0" ref="ProductionDetail"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductSupply"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Product"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="product"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20191031_a_1" test="(: DescriptiveDetail (Block 1) is mandatory except in block updates or deletions :) exists(DescriptiveDetail) or matches(NotificationType, '^(04|05|88)$')"/>
			<xs:assert id="_20191031_a_2" test="(: PublishingDetail (Block 4) is mandatory except in block updates or deletions :) exists(PublishingDetail) or matches(NotificationType, '^(04|05|88)$')"/>
			<xs:assert id="_20181026_a_1" test="(: CollateralDetail (Block 2) must only be empty in a block update :) not(exists(CollateralDetail)) or exists(CollateralDetail/child::*) or matches(NotificationType, '^(04|88)$')"/>
			<xs:assert id="_20181026_a_2" test="(: PromotionDetail (Block 7) must only be empty in a block update :) not(exists(PromotionDetail)) or exists(PromotionDetail/child::*) or matches(NotificationType, '^(04|88)$')"/>
			<xs:assert id="_20181026_a_3" test="(: ContentDetail (Block 3) must only be empty in a block update :) not(exists(ContentDetail)) or exists(ContentDetail/child::*) or matches(NotificationType, '^(04|88)$')"/>
			<xs:assert id="_20181026_a_4" test="(: RelatedMaterial (Block 5) must only be empty in a block update :) not(exists(RelatedMaterial)) or exists(RelatedMaterial/child::*) or matches(NotificationType, '^(04|88)$')"/>
			<xs:assert id="_20181026_a_5" test="(: ProductionDetail (Block 8) must only be empty in a block update :) not(exists(ProductionDetail)) or exists(ProductionDetail/child::*) or matches(NotificationType, '^(04|88)$')"/>
			<xs:assert id="_20190222_a_1" test="(: Reason for deletion must only be used with NotificationType 05 :) not(exists(DeletionText)) or NotificationType eq '05'"/>
			<xs:assert id="_20171208_a_28" test="(: Repeats of DeletionText must each have a unique language attribute :) (count(DeletionText) le 1) or count(DeletionText) eq count(distinct-values(DeletionText/@language))"/>
			<xs:assert id="_20171221_i_14" test="(: Repeats of RecordSourceIdentifier must each have a unique combination of valid RecordSourceIDType, IDTypeName and IDValue :) count(RecordSourceIdentifier) eq count(distinct-values(RecordSourceIdentifier/string-join((RecordSourceIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_c_3" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_9" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_10" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_11" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_12" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
			<xs:assert id="_20171212_e_1" test="(: Repeats of Barcode cannot include BarcodeType 'not barcoded' :) not(exists(Barcode[BarcodeType eq '00'])) or count(Barcode) le 1"/>
			<xs:assert id="_20171212_e_2" test="(: Repeats of Barcode must each have a unique combination of valid BarcodeType and PositionOnProduct :) count(Barcode) eq count(distinct-values(Barcode/string-join((BarcodeType | PositionOnProduct), ' ')))"/>
			<xs:assert id="_20180214_j_1" test="(: A biographical note within TextContent must only be used for group biographies :) not(exists(CollateralDetail/TextContent[TextType eq '12'])) or count(DescriptiveDetail/Contributor) gt 1"/>
			<xs:assert id="_20180109_h_1" test="(: Every country listed in CountriesIncluded within Market must be included in CountriesIncluded within a 'for sale' SalesRights territory :) not(exists(PublishingDetail/SalesRights[matches(SalesRightsType, '^(01|02)$')]) and exists(ProductSupply/Market)) or (every $country in tokenize(string-join(ProductSupply/Market/Territory/CountriesIncluded, ' '), ' ') satisfies (exists(PublishingDetail/SalesRights[matches(SalesRightsType, '^(01|02)$')]/Territory[matches(string(CountriesIncluded), $country)]) or exists(PublishingDetail/SalesRights[matches(SalesRightsType, '^(01|02)$')]/Territory[RegionsIncluded = 'WORLD'][not(matches(string(CountriesExcluded), $country))])))"/>
			<xs:assert id="_20180214_l_1" test="(: Market pub date must not be earlier than the global Pub date :) not(exists(ProductSupply/MarketPublishingDetail/MarketDate[MarketDateRole eq '01']) and exists(PublishingDetail/PublishingDate[PublishingDateRole eq '01'])) or (every $date in ProductSupply/MarketPublishingDetail/MarketDate[MarketDateRole eq '01'] satisfies ((if (exists(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date/@dateformat)) then PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date/@dateformat else if (exists(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/DateFormat)) then PublishingDetail/PublishingDate[PublishingDateRole eq '01']/DateFormat else '00') ne (if (exists($date/Date/@dateformat)) then $date/Date/@dateformat else if (exists($date/DateFormat)) then $date/DateFormat else '00')) or ((contains(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date, '+') and contains($date/Date, '+')) and (substring-after(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date, '+') ne substring-after($date/Date, '+'))) or ((contains(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date, '-') and contains($date/Date, '-')) and (substring-after(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date, '-') ne substring-after($date/Date, '-'))) or (matches(PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date, 'Z') ne matches($date/Date, 'Z')) or PublishingDetail/PublishingDate[PublishingDateRole eq '01']/Date le $date/Date)"/>
			<xs:assert id="_20180214_f_1" test="(: Every price must have an explicit or implied territory within which it is valid :) not(exists(ProductSupply/SupplyDetail/Price)) or (every $price in ProductSupply/SupplyDetail/Price satisfies exists($price/Territory)) or (every $supply in ProductSupply[exists(SupplyDetail/Price[not(exists(Territory))])] satisfies exists($supply/Market/Territory)) or exists(PublishingDetail/SalesRights[matches(SalesRightsType, '^(01|02)$')]) or exists(PublishingDetail[matches(ROWSalesRightsType, '^(01|02)$')]) or (not(exists(PublishingDetail)) and (NotificationType eq '04'))"/>
			<xs:assert id="_20180517_f_1" test="(: Repeats of ProductSupply must each have a Market :) (count(ProductSupply) le 1) or (every $supply in ProductSupply satisfies exists($supply/Market))"/>
			<xs:assert id="_20180517_h_1" test="(: PublishingStatus is required unless every market includes MarketPublishingStatus :) ((not(exists(PublishingDetail)) or not(exists(ProductSupply))) and (NotificationType eq '04')) or exists(PublishingDetail/PublishingStatus) or (every $supply in ProductSupply satisfies exists($supply/MarketPublishingDetail/MarketPublishingStatus))"/>
			<xs:assert id="_20180720_b_1" test="(: Pack quantity must not be specified for electronic products :) not(exists(ProductSupply/SupplyDetail/PackQuantity)) or not(exists(DescriptiveDetail[matches(ProductForm, 'AJ|AN|AO|E.|LC')]))"/>
			<xs:assert id="_20191128_c_1" test="(: Name identifier in Promotional event contributor reference must match a name identifier in Contributor or NameAsSubject :) every $name in PromotionDetail/PromotionalEvent/ContributorReference/NameIdentifier satisfies (exists(DescriptiveDetail/Contributor/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(DescriptiveDetail/Contributor/AlternativeName/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(DescriptiveDetail/Collection/Contributor/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(DescriptiveDetail/Collection/Contributor/AlternativeName/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(DescriptiveDetail/NameAsSubject/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(DescriptiveDetail/NameAsSubject/AlternativeName/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(ContentDetail/ContentItem/Contributor/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(ContentDetail/ContentItem/Contributor/AlternativeName/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(ContentDetail/ContentItem/NameAsSubject/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]) or exists(ContentDetail/ContentItem/NameAsSubject/AlternativeName/NameIdentifier[NameIDType eq $name/NameIDType][not(exists(IDTypeName)) or IDTypeName eq $name/IDTypeName][IDValue eq $name/IDValue]))"/>
			<xs:assert id="_20210302_b_1" test="(: In ProductionManifest, Product identifiers must be used if and only if there are separate ProductParts :) (exists(DescriptiveDetail/ProductPart) and exists(ProductionDetail)) eq exists(ProductionDetail/ProductionManifest/ProductIdentifier)"/>
		</xs:complexType>
		<xs:unique name="DeletionText_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:DeletionText"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ProductAvailability">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List65">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductAvailability"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j396"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductClassification">
		<xs:annotation>
			<xs:documentation>Added &lt;ProductClassificationTypeName> at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ProductClassificationType"/>
				<xs:element ref="ProductClassificationTypeName" minOccurs="0"/>
				<xs:element ref="ProductClassificationCode"/>
				<xs:element minOccurs="0" ref="Percent"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductClassification"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productclassification"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171219_b_1" test="(: WCO ProductClassificationCode must have 6, 8 or 10 digits :) (ProductClassificationType ne '01') or matches(ProductClassificationCode, '^([0-9][0-9]){3,5}$')"/>
			<xs:assert id="_20171219_b_2" test="(: UNSPSC ProductClassificationCode must have 8 or 10 digits :) (ProductClassificationType ne '02') or matches(ProductClassificationCode, '^([0-9][0-9]){4,5}$')"/>
			<xs:assert id="_20171219_b_3" test="(: HMRC ProductClassificationCode must have 8 or 10 digits :) (ProductClassificationType ne '03') or matches(ProductClassificationCode, '^([0-9][0-9]){4,5}$')"/>
			<xs:assert id="_20171219_b_4" test="(: TARIC ProductClassificationCode must have 10 digits :) (ProductClassificationType ne '05') or matches(ProductClassificationCode, '^[0-9]{10}$')"/>
			<xs:assert id="_20171219_b_5" test="(: CPA ProductClassificationCode must have 6 digits :) (ProductClassificationType ne '09') or matches(ProductClassificationCode, '^[0-9]{6}$')"/>
			<xs:assert id="_20171219_b_6" test="(: NCM ProductClassificationCode must have 8 digits :) (ProductClassificationType ne '10') or matches(ProductClassificationCode, '^[0-9]{8}$')"/>
			<xs:assert id="_20171219_b_7" test="(: HTSUS ProductClassificationCode must have 10 digits :) (ProductClassificationType ne '13') or matches(ProductClassificationCode, '^[0-9]{10}$')"/>
			<xs:assert id="_20171219_b_8" test="(: US Schedule B ProductClassificationCode must have 10 digits :) (ProductClassificationType ne '14') or matches(ProductClassificationCode, '^[0-9]{10}$')"/>
			<xs:assert id="_20191031_d_2" test="(: ProductClassificationTypeName may only be used if ProductClassificationType is sender’s own proprietary scheme :) not(exists(ProductClassificationTypeName)) or ProductClassificationType eq '07'"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductClassificationCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductClassificationCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b275"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductClassificationType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List9">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductClassificationType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b274"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductClassificationTypeName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductClassificationTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x555"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductComposition">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List2">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductComposition"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x314"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductContact">
		<xs:annotation>
			<xs:documentation>Added &lt;TelephoneNumber> at 3.0.8</xs:documentation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ProductContactRole"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="ProductContactIdentifier"/>
						<xs:element minOccurs="0" ref="ProductContactName"/>
					</xs:sequence>
					<xs:element ref="ProductContactName"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="ContactName"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" ref="EmailAddress"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductContact"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productcontact"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_15" test="(: Repeats of ProductContactIdentifier must each have a unique combination of valid ProductContactIDType, IDTypeName and IDValue :) count(ProductContactIdentifier) eq count(distinct-values(ProductContactIdentifier/string-join((ProductContactIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductContactIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ProductContactIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductContactIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productcontactidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_49" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(ProductContactIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_50" test="(: IDValue must be a valid GLN (invalid characters) :) (ProductContactIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_51" test="(: IDValue must be a valid GLN (check digit error) :) (ProductContactIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_52" test="(: IDValue must be a valid SAN (invalid characters) :) (ProductContactIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_53" test="(: IDValue must be a valid SAN (check digit error) :) (ProductContactIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171221_j_54" test="(: IDValue must be a valid ISNI (invalid characters) :) (ProductContact ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_55" test="(: IDValue must be a valid ISNI (check digit error) :) (ProductContact ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_56" test="(: IDValue must be a valid ORCID (invalid characters) :) (ProductContact ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_57" test="(: IDValue must be a valid ORCID (check digit error) :) (ProductContact ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_58" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (ProductContactIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171221_j_59" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (ProductContactIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171221_j_60" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (ProductContactIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductContactIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductContactIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x483"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductContactName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductContactName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x484"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductContactRole">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List198">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductContactRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x482"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductContentType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List81">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductContentType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b385"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductForm">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List150">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductForm"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b012"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductFormDescription">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductFormDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b014"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductFormDetail">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List175">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductFormDetail"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b333"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductFormFeature">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;ProductFormFeatureDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ProductFormFeatureType"/>
				<xs:element minOccurs="0" ref="ProductFormFeatureValue"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormFeatureDescription"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductFormFeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productformfeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20190710_a_1" test="(: ProductFormFeatureValue or ProductFormFeatureDescription or both are required :) matches(ProductFormFeatureType, '^(30|40)$') or exists(ProductFormFeatureValue | ProductFormFeatureDescription)"/>
			<xs:assert id="_20171216_d_3" test="(: Cover color in ProductFormFeatureValue must be from ONIX Codelist 98 :) (ProductFormFeatureType ne '01') or matches(ProductFormFeatureValue, '^(BLK|BLU|BRN|BUR|CEL|CRE|FCO|FCS|GLD|GRN|GRY|MUL|NAV|ORG|PNK|PUR|RED|SKY|SLV|TAN|TEA|WHI|YEL|ZZZ)$')"/>
			<xs:assert id="_20171216_d_4" test="(: Page edge color in ProductFormFeatureValue must be from ONIX Codelist 98 :) (ProductFormFeatureType ne '02') or matches(ProductFormFeatureValue, '^(BLK|BLU|BRN|BUR|CEL|CRE|FCO|FCS|GLD|GRN|GRY|MUL|NAV|ORG|PNK|PUR|RED|SKY|SLV|TAN|TEA|WHI|YEL|ZZZ)$')"/>
			<xs:assert id="_20191128_e_1" test="(: Body text typeface and (optionally) point size must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '03') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20171616_f_1" test="(: Cover material in ProductFormFeatureValue must be from ONIX Codelist 99 :) (ProductFormFeatureType ne '04') or matches(ProductFormFeatureValue, '^(00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|6|27)$')"/>
			<xs:assert id="_20180129_a_1" test="(: DVD region in ProductFormFeatureValue must be from ONIX Codelist 76 :) (ProductFormFeatureType ne '05') or matches(ProductFormFeatureValue, '^(0|1|2|3|4|5|6|7|8|A|B|C)$')"/>
			<xs:assert id="_20180129_a_2" test="(: Operating system in ProductFormFeatureValue must be from ONIX Codelist 176 :) (ProductFormFeatureType ne '06') or matches(ProductFormFeatureValue, '^(00|01|02|03|04|05|06|07|08|09|10|11|12|13|14)$')"/>
			<xs:assert id="_20191128_e_2" test="(: System requirements must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '07') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20191128_e_3" test="(: 'Point and listen' device compatbilty must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '08') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20171216_e_2" test="(: Accessibility detail in ProductFormFeatureValue must be from ONIX Codelist 196 :) (ProductFormFeatureType ne '09') or matches(ProductFormFeatureValue, '^(00|01|02|03|05|10|11|12|13|14|15|16|17|18|19|20|21|22|24|25|26|27|28|29|90|93|94|95|96|97|98|99)$')"/>
			<xs:assert id="_20171216_e_3" test="(: ProductFormFeatureDescription must carry a summary or a URL :) (ProductFormFeatureType ne '09') or not(matches(ProductFormFeatureValue, '^(00|94|95|96|97|98|99)$')) or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20191128_e_4" test="(: E-publication format version (eg 3.1) must be specified in ProductFormFeatureValue :) (ProductFormFeatureType ne '10') or matches(ProductFormFeatureValue, '^[0-9]+(\.[0-9]+[A-Za-z]?)*$')"/>
			<xs:assert id="_20180129_a_3" test="(: CPSIA hazard in ProductFormFeatureValue must be from ONIX Codelist 143 :) (ProductFormFeatureType ne '12') or matches(ProductFormFeatureValue, '^(01|02|03|04|05|06|07|11|12|13|14|15|16|17|18|21|22|23)$')"/>
			<xs:assert id="_20180129_a_4" test="(: EU Toy hazard in ProductFormFeatureValue must be from ONIX Codelist 184 :) (ProductFormFeatureType ne '13') or matches(ProductFormFeatureValue, '^(00|01|02|03|04|05|06|07|08|09)$')"/>
			<xs:assert id="_20180129_a_5" test="(: ProductFormFeatureDescription must carry a exact wording or a URL :) (ProductFormFeatureType ne '13') or not(matches(ProductFormFeatureValue, '^(04|05|06|07)$')) or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20191128_e_5" test="(: IATA warning must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '14') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20180129_a_6" test="(: Epub version in ProductFormFeatureValue must be from ONIX Codelist 220 :) (ProductFormFeatureType ne '15') or matches(ProductFormFeatureValue, '^(101A|101B|101C|101D|116A|116B|116C)$')"/>
			<xs:assert id="_20191128_e_6" test="(: E-publication format validator version (eg 4.0.0a) must be specified in ProductFormFeatureValue :) (ProductFormFeatureType ne '16') or matches(ProductFormFeatureValue, '^[0-9]+(\.[0-9]+[A-Za-z]?)*$')"/>
			<xs:assert id="_20191128_e_7" test="(: E-publication format validator must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '16') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20191128_e_8" test="(: 'Point and watch' device compatbilty must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '17') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20191128_e_9" test="(: Authentication and access control details must be specified in ProductFormFeatureDescription :) (ProductFormFeatureType ne '18') or exists(ProductFormFeatureDescription)"/>
			<xs:assert id="_20190410_e_1" test="(: Battery detail in ProductFormFeatureValue must be from ONIX Codelist 242 :) (ProductFormFeatureType ne '19') or matches(ProductFormFeatureValue, '^(00|01|02|03|04|05|06|07|08|09|10|20|21|22|23|24|25|26|27|28|29|99)$')"/>
			<xs:assert id="_20190410_f_1" test="(: Battery detail in ProductFormFeatureDescription must match [int] x [num]V [optional text] :) (ProductFormFeatureType ne '19') or not(matches(ProductFormFeatureValue, '^(02|03|04)$')) or matches(ProductFormFeatureDescription, '^([1-9][0-9]*) *([Xx×\*]) *(([0-9]|[1-9][0-9]+)\.?[0-9]+)[Vv]( *.+)?$')"/>
			<xs:assert id="_20191128_e_10" test="(: Battery capacity must be a number in Watt hours :) (ProductFormFeatureType ne '20') or matches(ProductFormFeatureValue, '^([0-9]|[1-9][0-9]+)(\.[0-9]+)?$')"/>
			<xs:assert id="_20190410_e_2" test="(: Dangerous goods detail in ProductFormFeatureValue must be from ONIX Codelist 243 :) (ProductFormFeatureType ne '21') or matches(ProductFormFeatureValue, '^(00|01|02|03|04|05|06)$')"/>
			<xs:assert id="_20191128_d_1" test="(: ProductFormFeatureDescription must be a UN chemical ID :) (ProductFormFeatureType ne '21') or not(matches(ProductFormFeatureValue, '^(02|03|04|05)$')) or matches(ProductFormFeatureDescription, '^(UN|un) *[0-4][0-9]{3}$')"/>
			<xs:assert id="_20171216_c_3" test="(: FSC certification in ProductFormFeatureValue must be C plus 6 digits, or in the form ABC-COC-123456 :) not(matches(ProductFormFeatureType, '^(31|32|33)$')) or matches(ProductFormFeatureValue, '^([A-Z]{2,5}\-COC\-[0-9]{6}|C[0-9]{6})$')"/>
			<xs:assert id="_20171216_c_4" test="(: PEFC certification in ProductFormFeatureValue must be in the form PEFC/12-34-5678 :) not(matches(ProductFormFeatureType, '^(34|35)$')) or matches(ProductFormFeatureValue, '^PEFC/[0-9]{2}\-[0-9]{2}\-[0-9]{2,6}$')"/>
			<xs:assert id="_20171216_c_5" test="(: ProductFormFeatureValue must be an integer percentage of Pre- and Post-consumer waste :) not(matches(ProductFormFeatureType, '^(36|37)$')) or matches(ProductFormFeatureValue, '^([0-9]|[1-9][0-9]|100)$')"/>
			<xs:assert id="_20171126_e_3" test="(: Repeats of ProductFormFeatureDescription must each have a unique language attribute :) (count(ProductFormFeatureDescription) le 1) or count(ProductFormFeatureDescription) eq count(distinct-values(ProductFormFeatureDescription/@language))"/>
			<xs:assert id="_20200115_c_1" test="(: Number of game pieces must be an integer :) (ProductFormFeatureType ne '22') or matches(ProductFormFeatureValue, '^[1-9][0-9]*$')"/>
			<xs:assert id="_20200115_c_2" test="(: Number of game players must be an integer or integer range :) (ProductFormFeatureType ne '23') or matches(ProductFormFeatureValue, '^[1-9][0-9]*([-–—][1-9][0-9]*)?$')"/>
			<xs:assert id="_20200115_c_3" test="(: Typical game play time must be an integer or integer range :) (ProductFormFeatureType ne '24') or matches(ProductFormFeatureValue, '^[1-9][0-9]*([-–—][1-9][0-9]*)?$')"/>
		</xs:complexType>
		<xs:unique name="ProductFormFeatureDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductFormFeatureDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ProductFormFeatureDescription">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductFormFeatureDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b336"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductFormFeatureType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List79">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductFormFeatureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b334"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductFormFeatureValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductFormFeatureValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b335"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ProductIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_c_7" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (ProductIDType eq '01') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_c_8" test="(: IDValue must be a valid ISBN-10 (invalid characters) :) (ProductIDType ne '02') or matches(IDValue, '^[0-9]{9}[0-9Xx]$')"/>
			<xs:assert id="_20171126_c_9" test="(: IDValue must be a valid ISBN-10 (check digit error) :) (ProductIDType ne '02') or not(matches(IDValue, '^[0-9]{9}[0-9Xx]$')) or (10 * number(substring(IDValue, 1, 1)) + 9 * number(substring(IDValue, 2, 1)) + 8 * number(substring(IDValue, 3, 1)) + 7 * number(substring(IDValue, 4, 1)) + 6 * number(substring(IDValue, 5, 1)) + 5 * number(substring(IDValue, 6, 1)) + 4 * number(substring(IDValue, 7, 1)) + 3 * number(substring(IDValue, 8, 1)) + 2 * number(substring(IDValue, 9, 1)) + (if (matches(substring(IDValue, 10, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 10, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_c_10" test="(: IDValue must be a valid GTIN-13 (invalid characters) :) (ProductIDType ne '03') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_c_11" test="(: IDValue must be a valid ISBN-13 (invalid characters) :) not(matches(ProductIDType, '^(15|24)$')) or matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')"/>
			<xs:assert id="_20171126_c_12" test="(: IDValue must be a valid ISMN-13 (invalid characters) :) (ProductIDType ne '25') or matches(IDValue, '^9790[0-9]{9}$')"/>
			<xs:assert id="_20171126_c_13" test="(: IDValue must be a valid GTIN-13 (check digit error) :) (ProductIDType ne '03') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_c_14" test="(: IDValue must be a valid ISBN-13 (check digit error) :) not(matches(ProductIDType, '^(15|24)$')) or not(matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_c_15" test="(: IDValue must be a valid ISMN-13 (check digit error) :) (ProductIDType ne '25') or not(matches(IDValue, '^9790[0-9]{9}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_c_16" test="(: IDValue must be a valid UPC-12 (invalid characters) :) (ProductIDType ne '04') or matches(IDValue, '^[0-9]{12}$')"/>
			<xs:assert id="_20171126_c_17" test="(: IDValue must be a valid UPC-12+5 (invalid characters) :) (ProductIDType ne '30') or matches(IDValue, '^[0-9]{17}$')"/>
			<xs:assert id="_20171126_c_18" test="(: IDValue must be a valid UPC-12 (check digit error) :) (ProductIDType ne '04') or not(matches(IDValue, '^[0-9]{12}$')) or (3 * (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1))) + number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1))) mod 10 eq 0"/>
			<xs:assert id="_20171126_c_19" test="(: IDValue must be a valid UPC-12+5 (check digit error) :) (ProductIDType ne '30') or not(matches(IDValue, '^[0-9]{17}$')) or (3 * (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1))) + number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1))) mod 10 eq 0"/>
			<xs:assert id="_20171212_a_1" test="(: IDValue must be a valid ISMN-10 (invalid characters) :) (ProductIDType ne '05') or matches(IDValue, '^M[0-9]{9}$')"/>
			<xs:assert id="_20171212_a_2" test="(: IDValue must be a valid ISMN-10 (check digit error) :) (ProductIDType ne '05') or not(matches(IDValue, '^M[0-9]{9}$')) or (9 + 9 + number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + 3 * (7 + 0 + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171212_b_1" test="(: IDValue must be a plausible DOI (invalid structure) :) (ProductIDType ne '06') or matches(IDValue, '^10\.([1-9][0-9]*)(\.[0-9]+)?/.+$')"/>
			<xs:assert id="_20171212_b_2" test="(: IDValue must be a plausible ISBN-A (invalid structure) :) (ProductIDType ne '26') or matches(IDValue, '^10\.97(8\.[0-9]{2,}|9\.[1-9][0-9]+)/[0-9]{2,}$')"/>
			<xs:assert id="_20171212_a_3" test="(: IDValue must be a plausible LCCN (invalid structure) :) (ProductIDType ne '13') or matches(IDValue, '^([A-Za-z]{1,3}|[A-Za-z]{0,2}[0-9]{2})?[0-9]{8}$')"/>
			<xs:assert id="_20171212_a_4" test="(: IDValue must be a valid GTIN-14 (invalid characters) :) (ProductIDType ne '14') or matches(IDValue, '^[0-9]{14}$')"/>
			<xs:assert id="_20171212_a_5" test="(: IDValue must be a valid GTIN-14 (check digit error) :) (ProductIDType ne '14') or not(matches(IDValue, '^[0-9]{14}$')) or (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)) + number(substring(IDValue, 14, 1)) + 3 * (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)))) mod 10 eq 0"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List5">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b221"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductPackaging">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List80">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductPackaging"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b225"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductPart">
		<xs:annotation>
			<xs:documentation>Added &lt;Measure> at revision 3.0.6</xs:documentation>
			<xs:documentation>Added &lt;ProductPckaging> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ProductFormDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="PrimaryPart"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductIdentifier"/>
				<xs:group ref="gp.product_form_core"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductContentType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Measure"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="NumberOfItemsOfThisForm"/>
						<xs:element minOccurs="0" ref="NumberOfCopies"/>
					</xs:sequence>
					<xs:element ref="NumberOfCopies"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="CountryOfManufacture"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductPart"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productpart"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_c_4" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_13" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_14" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_15" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_16" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
			<xs:assert id="_20171216_b_2" test="(: Repeats of ProductFormDetail must each be unique :) count(ProductFormDetail) eq count(distinct-values(ProductFormDetail))"/>
			<xs:assert id="_20180308_a_17" test="(: ProductFormDetail codes A101–2 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(A101|A102)$')])) or matches(ProductForm, '^(AA|AC)$')"/>
			<xs:assert id="_20180308_a_18" test="(: ProductFormDetail codes A103–12 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(A103|A104|A105|A106|A107|A108|A109|A110|A111|A112)$')])) or matches(ProductForm, '^(AA|AE|AH|AJ|AK|AL|AN|AO|D.|E.)$')"/>
			<xs:assert id="_20180308_a_19" test="(: ProductFormDetail codes A301–5 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(A301|A302|A303|A304|A305)$')])) or matches(ProductForm, '^(A.|D.|E.|V.)$')"/>
			<xs:assert id="_20180308_a_20" test="(: ProductFormDetail codes B101–7, B113–4, B116–8, B131–2 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(B101|B102|B103|B104|B105|B106|B107|B113|B114|B116|B117|B118|B131|B132|B412)$')])) or ProductForm eq 'BC'"/>
			<xs:assert id="_20180308_a_21" test="(: ProductFormDetail codes B115, B306 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B115|B306)$')])) or ProductForm eq 'BB'"/>
			<xs:assert id="_20180308_a_22" test="(: ProductFormDetail codes B133 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[. eq 'B133'])) or matches(ProductForm, '^(BB|BC)$')"/>
			<xs:assert id="_20180308_a_23" test="(: ProductFormDetail codes B301-3 can only be used with appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B301|B302|B303)$')])) or ProductForm eq 'BD'"/>
			<xs:assert id="_20180308_a_24" test="(: ProductFormDetail codes B201-2, B204-10, B212-6, B221-3 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(B201|B202|B204|B205|B206|B207|B208|B209|B210|B212|B213|B214|B215|B216|B221|B222|B223)$')])) or matches(ProductForm, '^B.$')"/>
			<xs:assert id="_20180308_a_25" test="(: ProductFormDetail codes B311-4 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B311|B312|B313|B314)$')])) or ProductForm eq 'BE'"/>
			<xs:assert id="_20180308_a_26" test="(: ProductFormDetail codes B403-5 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(B403|B404|B405)$')])) or ProductForm eq 'BG'"/>
			<xs:assert id="_20180308_a_27" test="(: ProductFormDetail codes B201-7 can only be used with appropriate Product forms :) not(exists(ProductFormDetail[matches(., '^(D201|D202|D203|D204|D205|D206|D207)$')])) or matches(ProductForm, '^D.$')"/>
			<xs:assert id="_20180308_a_28" test="(: ProductFormDetail codes P104-112 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(P104|P105|P106|P108|P111|P112)$')])) or ProductForm eq 'PC'"/>
			<xs:assert id="_20180308_a_29" test="(: ProductFormDetail codes P105, P115 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(P105|P115)$')])) or matches(ProductForm, '^(PC|PK)$')"/>
			<xs:assert id="_20180308_a_30" test="(: ProductFormDetail codes P101-103, P107, P110 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[matches(., '^(P101|P102|P103|P107|P110)$')])) or matches(ProductForm, '^(PC|PF)$')"/>
			<xs:assert id="_20180308_a_31" test="(: ProductFormDetail codes P109 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[. eq 'P109'])) or matches(ProductForm, '^(PC|PT)$')"/>
			<xs:assert id="_20180308_a_32" test="(: ProductFormDetail codes P113 can only be used with the appropriate Product form :) not(exists(ProductFormDetail[. eq 'P113'])) or matches(ProductForm, '^(PC|PF|PS)$')"/>
			<xs:assert id="_20180517_c_2" test="(: Only physical products should have FSC, PEFC certification, or PCW claims :) not(matches(ProductForm, '^(A[JNO]|E[ABCD])$')) or not(exists(ProductFormFeature[matches(ProductFormFeatureType, '^(30|31|32|33|34|35|36|37|40)$')]))"/>
			<xs:assert id="_20171216_c_6" test="(: Repeats of ProductFormFeature must only include a single FSC certification :) count(ProductFormFeature[matches(ProductFormFeatureType, '^(31|32|33)$')]) le 1"/>
			<xs:assert id="_20171216_c_7" test="(: Repeats of ProductFormFeature must only include a single PEFC certification :) count(ProductFormFeature[matches(ProductFormFeatureType, '^(34|35)$')]) le 1"/>
			<xs:assert id="_20180214_h_2" test="(: Claimed PCW percentage must be accompanied by a declaration that this is not PEFC- or FSC-certified :) not(exists(ProductFormFeature[ProductFormFeatureType eq '37'])) or exists(ProductFormFeature[ProductFormFeatureType eq '30'])"/>
			<xs:assert id="_20171216_d_6" test="(: Repeats of ProductFormFeature must only include a single page edge color :) count(ProductFormFeature[ProductFormFeatureType eq '01']) le 1"/>
			<xs:assert id="_20171216_d_7" test="(: Repeats of ProductFormFeature must only include a single binding color :) count(ProductFormFeature[ProductFormFeatureType eq '02']) le 1"/>
			<xs:assert id="_20190710_g_4" test="(: Repeats of ProductFormFeature with and without warnings are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '12'][matches(ProductFormFeatureValue, '^(11|12)$')]) le 1"/>
			<xs:assert id="_20190710_g_5" test="(: Repeats of ProductFormFeature with and without warnings are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '12'][matches(ProductFormFeatureValue, '^(13|14)$')]) le 1"/>
			<xs:assert id="_20190710_g_6" test="(: Repeats of ProductFormFeature with and without warnings are mutually exclusive :) count(ProductFormFeature[ProductFormFeatureType eq '12'][matches(ProductFormFeatureValue, '^(21|22)$')]) le 1"/>
			<xs:assert id="_20171216_f_2" test="(: Repeats of ProductFormFeature must only include a single material type :) count(ProductFormFeature[ProductFormFeatureType eq '04']) le 1"/>
			<xs:assert id="_20171216_e_4" test="(: Repeats of ProductFormFeature for accessibility detail must each have a unique ProductFormFeatureValue :) count(ProductFormFeature[ProductFormFeatureType eq '09']) eq count(distinct-values(ProductFormFeature[ProductFormFeatureType eq '09']/ProductFormFeatureValue))"/>
			<xs:assert id="_20171126_e_4" test="(: Repeats of ProductFormDescription must each have a unique language attribute :) (count(ProductFormDescription) le 1) or count(ProductFormDescription) eq count(distinct-values(ProductFormDescription/@language))"/>
			<xs:assert id="_20180214_k_2" test="(: Only physical products should have measurements :) not(matches(ProductForm, '^(A[JNO]|E[ABCD])$')) or not(exists(Measure))"/>
			<xs:assert id="_20171212_f_2" test="(: Repeats of Measure must each have a unique combination of valid MeasureType and MeasureUnitCode :) count(Measure) eq count(distinct-values(Measure/string-join((MeasureType | MeasureUnitCode), ' ')))"/>
			<xs:assert id="_20180109_d_2" test="(: Repeats of Measure with matching MeasureType but differing MeasureUnitCode must be equivalent :) every $type in distinct-values(Measure/MeasureType) satisfies ((count(Measure[MeasureType eq $type]) eq 1) or (((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']/Measurement) * 25.4) le 25.4 div 8)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'mm']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']/Measurement) * 10) le 1)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'cm']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'in']/Measurement) * 2.54) le 2.54 div 8)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']/Measurement) * 28.35) le 28.35 div 8)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']/Measurement) * 453.6) le 453.6 div 28.35)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'gr']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']/Measurement) * 1000) le 10)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']/Measurement) * 16) le 1)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'oz']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']/Measurement) * 35.27) le 1)) and ((not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']))) or (not(exists(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']))) or (abs(number(Measure[MeasureType eq $type][MeasureUnitCode eq 'lb']/Measurement) - number(Measure[MeasureType eq $type][MeasureUnitCode eq 'kg']/Measurement) * 2.2) le 2.2 div 16))))"/>
			<xs:assert id="_20190410_d_5" test="(: Weight of batteries must not exceed weight of product in gr :) not(exists(Measure[MeasureType eq '08'][MeasureUnitCode eq 'gr'])) or not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr'])) or number(Measure[MeasureType eq '08'][MeasureUnitCode eq 'gr']/Measurement) ge number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr']/Measurement)"/>
			<xs:assert id="_20190410_d_7" test="(: Weight of batteries must not exceed weight of product in oz :) not(exists(Measure[MeasureType eq '08'][MeasureUnitCode eq 'oz'])) or not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz'])) or number(Measure[MeasureType eq '08'][MeasureUnitCode eq 'oz']/Measurement) ge number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz']/Measurement)"/>
			<xs:assert id="_20190410_d_8" test="(: Weight of lithium in batteries must not exceed weight of product in gr :) not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr'])) or not(exists(Measure[MeasureType eq '18'][MeasureUnitCode eq 'gr'])) or number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'gr']/Measurement) ge number(Measure[MeasureType eq '18'][MeasureUnitCode eq 'gr']/Measurement)"/>
			<xs:assert id="_20190410_d_9" test="(: Weight of lithium in batteries must not exceed weight of product in oz :) not(exists(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz'])) or not(exists(Measure[MeasureType eq '18'][MeasureUnitCode eq 'oz'])) or number(Measure[MeasureType eq '17'][MeasureUnitCode eq 'oz']/Measurement) ge number(Measure[MeasureType eq '18'][MeasureUnitCode eq 'oz']/Measurement)"/>
			<xs:assert id="_20171208_c_2" test="(: Repeats of ProductContentType must each be unique :) count(ProductContentType) eq count(distinct-values(ProductContentType))"/>
			<xs:assert id="_20181113_b_1" test="(: NumberOfItemsOfThisForm must not be used with ProductIdentifier :) not(exists(ProductIdentifier) and exists(NumberOfItemsOfThisForm))"/>
		</xs:complexType>
		<xs:unique name="ProductPart_ProductFormDetail_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductFormDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="ProductPart_ProductContentType_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductContentType"/>
			<xs:field xpath="."/>
		</xs:unique>
		<xs:unique name="ProductPart_Measure_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:Measure"/>
			<xs:field xpath="onix:MeasureType"/>
			<xs:field xpath="onix:MeasureUnitCode"/>
		</xs:unique>
		<xs:unique name="ProductPart_ProductFormDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductFormDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ProductRelationCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List51">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProductRelationCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x455"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProductSupply">
		<xs:annotation>
			<xs:documentation>Container for data describing a market, and specific publishing and supplier details of the product in that market. Note Block 6 consists of all &lt;ProductSupply> containers together</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;SupplyDetail at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Market"/>
				<xs:element minOccurs="0" ref="MarketPublishingDetail"/>
				<xs:element maxOccurs="unbounded" ref="SupplyDetail"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProductSupply"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="productsupply"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ProfessionalAffiliation">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;ProfessionalPosition> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" ref="ProfessionalPosition"/>
					<xs:element minOccurs="0" ref="Affiliation"/>
				</xs:sequence>
				<xs:element ref="Affiliation"/>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ProfessionalAffiliation"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="professionalaffiliation"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_29" test="(: Repeats of ProfessionalPosition must each have a unique language attribute :) (count(ProfessionalPosition) le 1) or count(ProfessionalPosition) eq count(distinct-values(ProfessionalPosition/@language))"/>
		</xs:complexType>
		<xs:unique name="ProfessionalPosition_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProfessionalPosition"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ProfessionalPosition">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ProfessionalPosition"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b045"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PromotionalEvent">
		<xs:annotation>
			<xs:documentation>Added &lt;SupportingResource> at revision 3.0.8</xs:documentation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="EventIdentifier" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="EventType" maxOccurs="unbounded"/>
				<xs:element ref="EventStatus" minOccurs="0"/>
				<xs:element ref="ContentAudience" maxOccurs="unbounded"/>
				<xs:element ref="EventName" maxOccurs="unbounded"/>
				<xs:choice minOccurs="0">
					<xs:sequence>
						<xs:choice>
							<xs:sequence>
								<xs:element ref="ContributorReference" maxOccurs="unbounded"/>
								<xs:element ref="Contributor" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
							<xs:element ref="Contributor" maxOccurs="unbounded"/>
						</xs:choice>
						<xs:element ref="ContributorStatement" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
					<xs:element ref="NoContributor"/>
				</xs:choice>
				<xs:element ref="EventDescription" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="EventOccurrence" maxOccurs="unbounded"/>
				<xs:element ref="SupportingResource" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="EventSponsor" minOccurs="0" maxOccurs="unbounded"/>
				<xs:element ref="Website" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PromotionalEvent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="promotionalevent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20191128_b_1" test="(: Repeats of ContributorReference and Contributor must each have a unique SequenceNumber :) count((Contributor|ContributorReference)/SequenceNumber) eq count(distinct-values((Contributor|ContributorReference)/SequenceNumber))"/>
			<xs:assert id="_20191128_b_2" test="(: Repeats of ContributorReference and Contributor must each have a SequenceNumber, or must all omit a SequenceNumber :) not(exists((Contributor|ContributorReference)/SequenceNumber)) or count((Contributor|ContributorReference)/SequenceNumber) eq count(Contributor|ContributorReference)"/>
			<xs:assert id="_20191128_b_3" test="(: Repeats of ContributorReference and Contributor must have consecutive SequenceNumbers beginning at 1 :) not(exists((Contributor|ContributorReference)/SequenceNumber)) or max((Contributor|ContributorReference)/SequenceNumber) eq count(Contributor|ContributorReference)"/>
			<xs:assert id="_20210429_a_4" test="(: Repeats of EventName must each have a unique language attribute :) (count(EventName) le 1) or count(EventName) eq count(distinct-values(EventName/@language))"/>
			<xs:assert id="_20210429_a_5" test="(: Repeats of EventDescription must each have a unique language attribute :) (count(EventDescription) le 1) or count(EventDescription) eq count(distinct-values(EventDescription/@language))"/>
			<xs:assert id="_20210429_a_6" test="(: Repeats of ContributorStatement must each have a unique language attribute :) (count(ContributorStatement) le 1) or count(ContributorStatement) eq count(distinct-values(ContributorStatement/@language))"/>
		</xs:complexType>
		<xs:unique name="PromotionalEvent_EventName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="PromotionalEvent_EventDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:EventDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="PromotionalEvent_ContributorStatement_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ContributorStatement"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="PromotionCampaign">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PromotionCampaign"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="k165"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_35" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_36" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_18" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_18" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_18" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_18" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PromotionContact">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;ProductContact> instead</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PromotionContact"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="k166"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_37" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_38" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_19" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_19" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_19" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_19" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PromotionDetail">
		<xs:annotation>
			<xs:documentation>Block 7, container for data describing events arranged to promote the product</xs:documentation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PromotionalEvent"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PromotionDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="promotiondetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="Proximity">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List215">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Proximity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x502"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Publisher">
		<xs:annotation>
			<xs:documentation>Added &lt;Funding> at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PublishingRole"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="PublisherIdentifier"/>
						<xs:element minOccurs="0" ref="PublisherName"/>
					</xs:sequence>
					<xs:element ref="PublisherName"/>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Funding"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Publisher"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="publisher"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_16" test="(: Repeats of PublisherIdentifier must each have a unique combination of valid PublisherIDType, IDTypeName and IDValue :) count(PublisherIdentifier) eq count(distinct-values(PublisherIdentifier/string-join((PublisherIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublisherIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PublisherIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PublisherIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="publisheridentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_b_37" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(PublisherIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_b_38" test="(: IDValue must be a valid GLN (invalid characters) :) (PublisherIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_b_39" test="(: IDValue must be a valid GLN (check digit error) :) (PublisherIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_b_40" test="(: IDValue must be a valid SAN (invalid characters) :) (PublisherIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_41" test="(: IDValue must be a valid SAN (check digit error) :) (PublisherIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_b_42" test="(: IDValue must be a valid ISNI (invalid characters) :) (PublisherIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_43" test="(: IDValue must be a valid ISNI (check digit error) :) (PublisherIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_44" test="(: IDValue must be a valid ORCID (invalid characters) :) (PublisherIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_45" test="(: IDValue must be a valid ORCID (check digit error) :) (PublisherIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_46" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (PublisherIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171126_b_47" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (PublisherIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171126_b_48" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (PublisherIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublisherIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PublisherIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x447"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublisherName">
		<xs:annotation>
			<xs:documentation>Added collationkey attribute at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PublisherName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b081"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublisherRepresentative">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="AgentRole"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="AgentIdentifier"/>
						<xs:element minOccurs="0" ref="AgentName"/>
					</xs:sequence>
					<xs:element ref="AgentName"/>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="FaxNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EmailAddress"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PublisherRepresentative"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="publisherrepresentative"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_17" test="(: Repeats of AgentIdentifier must each have a unique combination of valid AgentIDType, IDTypeName and IDValue :) count(AgentIdentifier) eq count(distinct-values(AgentIdentifier/string-join((AgentIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublishingDate">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;DateFormat> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="PublishingDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PublishingDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="publishingdate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_d_57" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20171208_d_58" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20171208_d_59" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20171208_d_60" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_61" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_62" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20171208_d_63" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20171208_d_64" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_65" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_66" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_67" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_68" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20171208_d_69" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20171208_d_70" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublishingDateRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List163">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PublishingDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x448"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublishingDetail">
		<xs:annotation>
			<xs:documentation>Block 4, container for information about describing branding, publishing and rights attached to the product</xs:documentation>
			<xs:documentation>Added &lt;ProductContact> at revision 3.0.1</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;PublishingStatusNote> at revision 3.0.1</xs:documentation>
			<xs:documentation>Added &lt;ROWSalesRightsType> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:group ref="gp.imprints_publishers"/>
				<xs:group ref="gp.publishing_status"/>
				<xs:group ref="gp.rights_restrictions"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="PublishingDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="publishingdetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_e_6" test="(: Repeats of PublishingDate must each have a unique PublishingDateRole :) count(PublishingDate) eq count(distinct-values(PublishingDate/PublishingDateRole))"/>
			<xs:assert id="_20181113_g_1" test="(: Any sales embargo must not be later than the publication date :) if (exists(PublishingDate[PublishingDateRole eq '01']) and exists(PublishingDate[PublishingDateRole eq '02'])) then (if ((if (exists(PublishingDate[PublishingDateRole eq '01']/Date/@dateformat)) then PublishingDate[PublishingDateRole eq '01']/Date/@dateformat else if (exists(PublishingDate[PublishingDateRole eq '01']/DateFormat)) then PublishingDate[PublishingDateRole eq '01']/DateFormat else '00') eq (if (exists(PublishingDate[PublishingDateRole eq '02']/Date/@dateformat)) then PublishingDate[PublishingDateRole eq '02']/Date/@dateformat else if (exists(PublishingDate[PublishingDateRole eq '02']/DateFormat)) then PublishingDate[PublishingDateRole eq '02']/DateFormat else '00')) then (if ((if (contains(PublishingDate[PublishingDateRole eq '01']/Date, '+')) then (contains(PublishingDate[PublishingDateRole eq '02']/Date, '+') and (substring-after(PublishingDate[PublishingDateRole eq '01']/Date, '+') eq substring-after(PublishingDate[PublishingDateRole eq '02']/Date, '+'))) else not(contains(PublishingDate[PublishingDateRole eq '02']/Date, '+'))) and (if (contains(PublishingDate[PublishingDateRole eq '01']/Date, '-')) then (contains(PublishingDate[PublishingDateRole eq '02']/Date, '-') and (substring-after(PublishingDate[PublishingDateRole eq '01']/Date, '-') eq substring-after(PublishingDate[PublishingDateRole eq '02']/Date, '-'))) else not(contains(PublishingDate[PublishingDateRole eq '02']/Date, '-'))) and (matches(PublishingDate[PublishingDateRole eq '01']/Date, 'Z') eq matches(PublishingDate[PublishingDateRole eq '02']/Date, 'Z'))) then (PublishingDate[PublishingDateRole eq '02']/Date le PublishingDate[PublishingDateRole eq '01']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20171208_a_30" test="(: Repeats of PublishingStatusNote must each have a unique language attribute :) (count(PublishingStatusNote) le 1) or count(PublishingStatusNote) eq count(distinct-values(PublishingStatusNote/@language))"/>
			<xs:assert id="_20180101_a_1" test="(: ROWSalesRightsType is required (rule 1) :) not(exists(SalesRights) and not(exists(SalesRights/Territory[RegionsIncluded = 'WORLD']))) or exists(ROWSalesRightsType)"/>
			<xs:assert id="_20180101_a_2" test="(: ROWSalesRightsType must be omitted (rule 2) :) not(exists(SalesRights) and exists(SalesRights/Territory[RegionsIncluded = 'WORLD']) and not(exists(SalesRights/Territory[RegionsIncluded = 'WORLD']/(CountriesExcluded | RegionsExcluded)))) or not(exists(ROWSalesRightsType))"/>
			<xs:assert id="_20180101_a_3" test="(: ROWSalesRightsType is required (rule 3) :) not(exists(SalesRights) and exists(SalesRights/Territory[RegionsIncluded = 'WORLD']) and exists(SalesRights/Territory[RegionsIncluded = 'WORLD']/(CountriesExcluded | RegionsExcluded))) or (((every $country in tokenize(string(SalesRights/Territory[RegionsIncluded = 'WORLD']/CountriesExcluded), ' ') satisfies exists(SalesRights/Territory[matches(string(CountriesIncluded), $country)])) and (every $region in tokenize(string(SalesRights/Territory[RegionsIncluded = 'WORLD']/RegionsExcluded), ' ') satisfies exists(SalesRights/Territory[matches(string(RegionsIncluded), $region)]))) or exists(ROWSalesRightsType))"/>
			<xs:assert id="_20180101_b_1" test="(: A SalesRights composite where RegionsIncluded includes 'WORLD' must use CountriesExcluded and RegionsExcluded to exclude all countries and regions listed in CountriesIncluded and RegionsIncluded within other repeats of SalesRights :) (not(exists(SalesRights/Territory[RegionsIncluded = 'WORLD']))) or ((every $country in tokenize(string-join(SalesRights/Territory/CountriesIncluded, ' '), ' ') satisfies exists(SalesRights/Territory[RegionsIncluded = 'WORLD'][contains(string(CountriesExcluded), $country)])) and (every $region in tokenize(string-join(SalesRights/Territory[RegionsIncluded != 'WORLD']/RegionsIncluded, ' '), ' ') satisfies exists(SalesRights/Territory[RegionsIncluded = 'WORLD'][contains(string(RegionsExcluded), $region)])))"/>
			<xs:assert id="_20170517_g_1" test="(: A country cannot be included in more than one sales rights composite :) count(tokenize(string-join(SalesRights/Territory/CountriesIncluded, ' '), ' ')) eq count(distinct-values(tokenize(string-join(SalesRights/Territory/CountriesIncluded, ' '), ' ')))"/>
			<xs:assert id="_20170517_g_2" test="(: A region cannot be included in more than one sales rights composite :) count(tokenize(string-join(SalesRights/Territory/RegionsIncluded, ' '), ' ')) eq count(distinct-values(tokenize(string-join(SalesRights/Territory/RegionsIncluded, ' '), ' ')))"/>
			<xs:assert id="_20180214_c_1" test="(: If PublishingStatus is 'Cancelled', publication date must not be sent :) not(exists(PublishingStatus)) or (PublishingStatus ne '01') or not(exists(PublishingDate[PublishingDateRole eq '01']))"/>
			<xs:assert id="_20180214_c_2" test="(: If PublishingStatus is 'Forthcoming', publication date must be sent :) not(exists(PublishingStatus)) or (PublishingStatus ne '02') or exists(PublishingDate[PublishingDateRole eq '01'])"/>
			<xs:assert id="_20180214_c_3" test="(: If PublishingStatus is 'Postponed indefinitely', publication date must not be sent :) not(exists(PublishingStatus)) or (PublishingStatus ne '03') or not(exists(PublishingDate[PublishingDateRole eq '01']))"/>
		</xs:complexType>
		<xs:unique name="PublishingStatusNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PublishingStatusNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="PublishingRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List45">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PublishingRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b291"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublishingStatus">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List64">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PublishingStatus"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b394"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="PublishingStatusNote">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="PublishingStatusNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b395"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_39" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_40" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_20" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_20" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_20" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_20" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Quantity">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Quantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x320"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="QuantityUnit">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List169">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="QuantityUnit"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x466"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Rate">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.Integer">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Rate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x505"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Rating">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Rating"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x525"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RatingLimit">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RatingLimit"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x526"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RatingUnits">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RatingUnits"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x527"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RecordReference">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RecordReference"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="a001"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RecordSourceIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="RecordSourceIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="RecordSourceIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="recordsourceidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_b_49" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(RecordSourceIDType, '01|02') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_b_50" test="(: IDValue must be a valid GLN (invalid characters) :) (RecordSourceIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_b_51" test="(: IDValue must be a valid GLN (check digit error) :) (RecordSourceIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_b_52" test="(: IDValue must be a valid SAN (invalid characters) :) (RecordSourceIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_53" test="(: IDValue must be a valid SAN (check digit error) :) (RecordSourceIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_b_54" test="(: IDValue must be a valid ISNI (invalid characters) :) (RecordSourceIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_55" test="(: IDValue must be a valid ISNI (check digit error) :) (RecordSourceIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_56" test="(: IDValue must be a valid ORCID (invalid characters) :) (RecordSourceIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_57" test="(: IDValue must be a valid ORCID (check digit error) :) (RecordSourceIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_58" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (RecordSourceIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171126_b_59" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (RecordSourceIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171126_b_60" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (RecordSourceIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="RecordSourceIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RecordSourceIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x311"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RecordSourceName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RecordSourceName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="a197"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RecordSourceType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List3">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RecordSourceType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="a194"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RegionCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List49">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RegionCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b398"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:assert id="_20180324_b_1" test="(: WORLD cannot be used :) . ne 'WORLD'"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RegionsIncluded">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.RegionCodeList">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RegionsIncluded"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x450"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RegionsExcluded">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.RegionCodeList">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="RegionsExcluded"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x452"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:assert id="_20171208_j_1" test="(: RegionsExcluded cannot contain WORLD :) . != 'WORLD'"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Reissue">
		<xs:annotation>
			<xs:documentation>Deprecated – use start and end dates in &lt;Price>, &lt;TextContent>, &lt;SupportingResource> etc instead</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ReissueDate"/>
				<xs:element minOccurs="0" ref="ReissueDescription"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Price"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SupportingResource"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Reissue"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="reissue"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReissueDate">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;PublishingDate> or &lt;SupplyDate> instead</xs:documentation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReissueDate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j365"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_71" test="(: Date must be in YYYYMMDD format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_72" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_73" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_74" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_75" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_76" test="(: Date must be in YYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_77" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_78" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_79" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_80" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_81" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_82" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_83" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_84" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReissueDescription">
		<xs:annotation>
			<xs:documentation>Deprecated – use &lt;TextContent> with start and end dates instead</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReissueDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j366"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_41" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_42" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_21" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_21" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_21" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_21" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="RelatedMaterial">
		<xs:annotation>
			<xs:documentation>Block 5, container for elements providing links to closely-related products and works</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group ref="gp.related_materials"/>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="RelatedMaterial"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="relatedmaterial"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<!-- xs:assert id="_20180720_a_2" test="(: RelatedMaterial must not be empty :) exists(child::*)" / -->
			<xs:assert id="_20190710_b_1" test="(: Each RelatedProduct must be unique :) count(RelatedProduct/ProductIdentifier[ProductIDType eq '02']) eq count(distinct-values(RelatedProduct/ProductIdentifier[ProductIDType eq '02']/IDValue))"/>
			<xs:assert id="_20190710_b_2" test="(: Each RelatedProduct must be unique :) count(RelatedProduct/ProductIdentifier[ProductIDType eq '03']) eq count(distinct-values(RelatedProduct/ProductIdentifier[ProductIDType eq '03']/IDValue))"/>
			<xs:assert id="_20190710_b_3" test="(: Each RelatedProduct must be unique :) count(RelatedProduct/ProductIdentifier[ProductIDType eq '15']) eq count(distinct-values(RelatedProduct/ProductIdentifier[ProductIDType eq '15']/IDValue))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="RelatedProduct">
		<xs:annotation>
			<xs:documentation>Added &lt;ProductForm>, &lt;ProductFormDetail> at revision 3.0 (2010)</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;ProductRelationCode> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ProductRelationCode"/>
				<xs:element maxOccurs="unbounded" ref="ProductIdentifier"/>
				<xs:sequence minOccurs="0">
					<xs:element ref="ProductForm"/>
					<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormDetail"/>
				</xs:sequence>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="RelatedProduct"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="relatedproduct"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180105_b_1" test="(: Repeats of ProductRelationCode must each be unique :) count(ProductRelationCode) eq count(distinct-values(ProductRelationCode))"/>
			<xs:assert id="_20171212_c_5" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_17" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_18" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_19" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_20" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
			<xs:assert id="_20171216_b_3" test="(: Repeats of ProductFormDetail must each be unique :) count(ProductFormDetail) eq count(distinct-values(ProductFormDetail))"/>
		</xs:complexType>
		<xs:unique name="RelatedProduct_ProductFormDetail_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ProductFormDetail"/>
			<xs:field xpath="."/>
		</xs:unique>
	</xs:element>
	<xs:element name="RelatedWork">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="WorkRelationCode"/>
				<xs:element maxOccurs="unbounded" ref="WorkIdentifier"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="RelatedWork"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="relatedwork"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_18" test="(: Repeats of WorkIdentifier must each have a unique combination of valid WorkIDType, IDTypeName and IDValue :) count(WorkIdentifier) eq count(distinct-values(WorkIdentifier/string-join((WorkIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReligiousText">
		<xs:complexType>
			<xs:choice>
				<xs:element ref="Bible"/>
				<xs:sequence>
					<xs:element ref="ReligiousTextIdentifier"/>
					<xs:element maxOccurs="unbounded" ref="ReligiousTextFeature"/>
				</xs:sequence>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ReligiousText"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="religioustext"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReligiousTextFeature">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;ReligiousTextFeatureDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ReligiousTextFeatureType"/>
				<xs:element ref="ReligiousTextFeatureCode"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ReligiousTextFeatureDescription"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ReligiousTextFeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="religioustextfeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180214_e_1" test="(: Church season or activity must be from ONIX Codelist 90 :) (ReligiousTextFeatureType ne '01') or matches(ReligiousTextFeatureCode, '^(01|02|03|04|05|06|07|08|09|10|11)$')"/>
			<xs:assert id="_20171208_a_31" test="(: Repeats of ReligiousTextFeatureDescription must each have a unique language attribute :) (count(ReligiousTextFeatureDescription) le 1) or count(ReligiousTextFeatureDescription) eq count(distinct-values(ReligiousTextFeatureDescription/@language))"/>
		</xs:complexType>
		<xs:unique name="ReligiousTextFeatureDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ReligiousTextFeatureDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ReligiousTextFeatureCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List90">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReligiousTextFeatureCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b359"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReligiousTextFeatureDescription">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReligiousTextFeatureDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b360"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_43" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_44" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_22" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_22" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_22" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_22" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReligiousTextFeatureType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List89">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReligiousTextFeatureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b358"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReligiousTextIdentifier">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List88">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReligiousTextIdentifier"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b376"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReprintDetail">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReprintDetail"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="k309"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_45" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_46" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_23" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_23" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_23" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_23" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Reserved">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Reserved"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x536"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceContentType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List158">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceContentType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x436"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceFeature">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;FeatureNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceFeatureType"/>
				<xs:element minOccurs="0" ref="FeatureValue"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="FeatureNote"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ResourceFeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="resourcefeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_32" test="(: Repeats of FeatureNote must each have a unique language attribute :) (count(FeatureNote) le 1) or count(FeatureNote) eq count(distinct-values(FeatureNote/@language))"/>
			<xs:assert id="_20210429_f_1" test="(: FeatureValue must be an RGB or RGBA colour in hexadecimal :) not(matches(ResourceFeatureType, '^(08|10)$')) or matches(FeatureValue, '^([0-9A-Fa-f]{6}([0-9A-Fa-f]{2})?)$')" />
			<xs:assert id="_20210429_g_1" test="(: FeatureValue must be a value from ONIX codelist 256 :) (ResourceFeatureType ne '09') or matches(FeatureValue, '^(01|02|03|04|05|06|07|21|22|23|24|33|34|35|36|41|42|43|47|48)$')" />
		</xs:complexType>
		<xs:unique name="Resource_FeatureNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:FeatureNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ResourceFeatureType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List160">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceFeatureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x438"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceForm">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List161">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceForm"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x441"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceLink">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyURI">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceLink"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x435"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:assert id="_20181210_a_2" test="(: URI must not contain an empty hostname :) not(matches(., '///'))"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceMode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List159">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceMode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x437"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceVersion">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceForm"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceVersionFeature"/>
				<xs:element maxOccurs="unbounded" ref="ResourceLink"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContentDate"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ResourceVersion"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="resourceversion"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180105_d_1" test="(: Repeats of ResourceVersionFeature must each be unique :) count(ResourceVersionFeature) eq count(distinct-values(ResourceVersionFeature/ResourceVersionFeatureType))"/>
			<xs:assert id="_20181210_b_1" test="(: If any ResourceLink carries a language attribute, all must carry a language attribute:) (count(ResourceLink/@language) eq 0) or count(ResourceLink) eq count(ResourceLink/@language)"/>
			<xs:assert id="_20171208_e_7" test="(: Repeats of ContentDate must each have a unique ContentDateRole :) count(ContentDate) eq count(distinct-values(ContentDate/ContentDateRole))"/>
			<xs:assert id="_20180109_g_4" test="(: For repeats of ContentDate with matching From and To roles, the From date must precede the To date :) if (exists(ContentDate[ContentDateRole eq '14']) and exists(ContentDate[ContentDateRole eq '15'])) then (if ((if (exists(ContentDate[ContentDateRole eq '14']/Date/@dateformat)) then ContentDate[ContentDateRole eq '14']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '14']/DateFormat)) then ContentDate[ContentDateRole eq '14']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '15']/Date/@dateformat)) then ContentDate[ContentDateRole eq '15']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '15']/DateFormat)) then ContentDate[ContentDateRole eq '15']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '14']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '15']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '14']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '15']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '15']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '14']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '15']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '14']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '15']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '15']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '14']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '15']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '14']/Date le ContentDate[ContentDateRole eq '15']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20180109_g_5" test="(: For repeats of ContentDate with matching Available from and Available until roles, the Available from date must precede the Available until date :) if (exists(ContentDate[ContentDateRole eq '27']) and exists(ContentDate[ContentDateRole eq '28'])) then (if ((if (exists(ContentDate[ContentDateRole eq '27']/Date/@dateformat)) then ContentDate[ContentDateRole eq '27']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '27']/DateFormat)) then ContentDate[ContentDateRole eq '27']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '28']/Date/@dateformat)) then ContentDate[ContentDateRole eq '28']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '28']/DateFormat)) then ContentDate[ContentDateRole eq '28']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '27']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '28']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '27']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '28']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '28']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '27']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '28']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '27']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '28']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '28']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '27']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '28']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '27']/Date le ContentDate[ContentDateRole eq '28']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20180109_g_6" test="(: For repeats of ContentDate with matching Associated start and Associated end roles, the Associated start date must precede the Associated end date :) if (exists(ContentDate[ContentDateRole eq '31']) and exists(ContentDate[ContentDateRole eq '32'])) then (if ((if (exists(ContentDate[ContentDateRole eq '31']/Date/@dateformat)) then ContentDate[ContentDateRole eq '31']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '31']/DateFormat)) then ContentDate[ContentDateRole eq '31']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '32']/Date/@dateformat)) then ContentDate[ContentDateRole eq '32']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '32']/DateFormat)) then ContentDate[ContentDateRole eq '32']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '31']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '32']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '31']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '32']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '32']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '31']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '32']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '31']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '32']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '32']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '31']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '32']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '31']/Date le ContentDate[ContentDateRole eq '32']/Date) else true()) else true()) else true()"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="ResourceVersionFeature">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;FeatureNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceVersionFeatureType"/>
				<xs:element minOccurs="0" ref="FeatureValue"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="FeatureNote"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ResourceVersionFeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="resourceversionfeature"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_33" test="(: Repeats of FeatureNote must each have a unique language attribute :) (count(FeatureNote) le 1) or count(FeatureNote) eq count(distinct-values(FeatureNote/@language))"/>
			<xs:assert id="_20190107_h_1" test="(: File type in FeatureValue must be from ONIX Codelist 178 :) not(ResourceVersionFeatureType eq '01') or matches(FeatureValue, '^(A103|A104|A105|A106|A107|A108|A111|D101|D102|D103|D104|D105|D106|D107|D108|D109|D401|D501|D502|D503|D504|D505|D506|D507|D508|E101|E105|E107|E112|E113|E115|E116|E139|E140)$')"/>
		</xs:complexType>
		<xs:unique name="Version_FeatureNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:FeatureNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ResourceVersionFeatureType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List162">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ResourceVersionFeatureType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x442"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReturnsCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReturnsCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j269"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReturnsCodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List53">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReturnsCodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j268"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReturnsCodeTypeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReturnsCodeTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x460"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReturnsConditions">
		<xs:annotation>
			<xs:documentation>Added &lt;ReturnsNote> at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ReturnsCodeType"/>
				<xs:element minOccurs="0" ref="ReturnsCodeTypeName"/>
				<xs:element ref="ReturnsCode"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ReturnsNote"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ReturnsConditions"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="returnsconditions"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_34" test="(: Repeats of ReturnsNote must each have a unique language attribute :) (count(ReturnsNote) le 1) or count(ReturnsNote) eq count(distinct-values(ReturnsNote/@language))"/>
			<xs:assert id="_20180129_e_1" test="(: BISAC Returns indicator in ReturnsCode must be from ONIX Codelist 66 :) (ReturnsCodeType ne '02') or matches(ReturnsCode, '^(N|Y|S|C)$')"/>
			<xs:assert id="_20180129_e_2" test="(: ONIX Returns condition in ReturnsCode must be from ONIX Codelist 204 :) (ReturnsCodeType ne '04') or matches(ReturnsCode, '^(00|01|02|03|04|05|06|07)$')"/>
		</xs:complexType>
		<xs:unique name="ReturnsNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:ReturnsNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ReturnsNote">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ReturnsNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x528"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ReviewRating">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Rating"/>
				<xs:element minOccurs="0" ref="RatingLimit"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="RatingUnits"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="ReviewRating"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="reviewrating"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_a_35" test="(: Repeats of RatingUnits must each have a unique language attribute :) (count(RatingUnits) le 1) or count(RatingUnits) eq count(distinct-values(RatingUnits/@language))"/>
		</xs:complexType>
		<xs:unique name="RatingUnits_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:RatingUnits"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="ROWSalesRightsType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List46">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ROWSalesRightsType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x456"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesOutlet">
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="SalesOutletIdentifier"/>
						<xs:element minOccurs="0" ref="SalesOutletName"/>
					</xs:sequence>
					<xs:element ref="SalesOutletName"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SalesOutlet"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="salesoutlet"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_19" test="(: Repeats of SalesOutletIdentifier must each have a unique combination of valid SalesOutletIDType, IDTypeName and IDValue :) count(SalesOutletIdentifier) eq count(distinct-values(SalesOutletIdentifier/string-join((SalesOutletIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesOutletIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SalesOutletIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SalesOutletIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="salesoutletidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_61" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (SalesOutletIDType eq '01') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_k_1" test="(: IDValue must be a value from ONIX Codelist 139 :) (SalesOutletIDType ne '03') or matches(IDValue, '^(SYM|ACM|AAP|ADL|ACB|AKK|ALB|ALT|AMZ|ANR|ANB|APA|APC|ASD|ASB|AUD|AUC|ATK|BDL|BNO|BDZ|BBB|BST|MMM|BIL|BLG|BJW|BLA|BLK|GOS|BKU|BLD|BCA|BOO|BSH|BKP|BRB|BKM|BKS|BTP|BKY|BRD|BRT|CDL|CDN|CEB|CHD|CYM|CMX|COP|CST|CRB|CVS|CVM|CYB|DEM|DSG|DIL|DYM|EPA|ERD|ELC|ESN|EBC|ECH|ECI|ELE|ELB|ELK|ELL|ELS|EMP|ENH|EPC|FDB|FIN|FSP|FLP|FNC|FOL|FRY|GMS|GLO|GOO|HST|HMV|HMD|IMM|IND|IBS|IZN|JBH|JSM|KMT|KID|KPV|KNB|KNO|KBO|KOO|KOR|KRG|LTP|LWE|MAC|MAG|MKS|MAT|MMS|ADP|MCR|MSF|MOF|MRR|MTC|MYB|MYI|NTR|NXT|NUM|OFD|OFM|OLF|OVD|OYS|PST|PTS|PTC|PLY|POK|PTB|RDB|RCL|RST|RET|RTZ|RMB|RBD|SGR|SAF|SFW|SNS|SCR|SLF|SEQ|SBT|SKB|SMW|SNY|SPL|STP|STT|SKK|SSK|SUP|TRG|TES|TEA|TOL|TSR|TSO|TXR|UBH|VRG|WHS|WTR|WLM|WST|WHT|WLS|WLW|YOU|ZVV|PUB|ZZZ)')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesOutletIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List102">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SalesOutletIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b393"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesOutletName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SalesOutletName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b382"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesRestriction">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;SalesRestrictionNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SalesRestrictionType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesOutlet"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesRestrictionNote"/>
				<xs:element minOccurs="0" ref="StartDate"/>
				<xs:element minOccurs="0" ref="EndDate"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SalesRestriction"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="salesrestriction"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20180214_g_1" test="(: The sales restriction must be described in SalesRestrictionNote :) (SalesRestrictionType ne '00') or exists(SalesRestrictionNote)"/>
			<xs:assert id="_20180214_g_2" test="(: The restricted outlet must be specified in SalesOutlet :) not(matches(SalesRestrictionType, '^(01|04|05|11)$')) or exists(SalesOutlet)"/>
			<xs:assert id="_20171208_a_36" test="(: Repeats of SalesRestrictionNote must each have a unique language attribute :) (count(SalesRestrictionNote) le 1) or count(SalesRestrictionNote) eq count(distinct-values(SalesRestrictionNote/@language))"/>
			<xs:assert id="_20180109_a_1" test="(: For matching StartDate and EndDate, the StartDate must precede the EndDate :) if (exists(StartDate) and exists(EndDate)) then (if ((if (exists(StartDate/@dateformat)) then StartDate/@dateformat else '00') eq (if (exists(EndDate/@dateformat)) then EndDate/@dateformat else '00')) then (if ((if (contains(StartDate, '+')) then (contains(EndDate, '+') and (substring-after(StartDate, '+') eq substring-after(EndDate, '+'))) else not(contains(EndDate, '+'))) and (if (contains(StartDate, '-')) then (contains(EndDate, '-') and (substring-after(StartDate, '-') eq substring-after(EndDate, '-'))) else not(contains(EndDate, '-'))) and (matches(StartDate, 'Z') eq matches(EndDate, 'Z'))) then (StartDate le EndDate) else true()) else true()) else true()"/>
		</xs:complexType>
		<xs:unique name="SalesRestrictionNote_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SalesRestrictionNote"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="SalesRestrictionNote">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SalesRestrictionNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x453"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_47" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_48" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_24" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_24" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_24" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_24" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesRestrictionType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List71">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SalesRestrictionType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b381"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesRights">
		<xs:annotation>
			<xs:documentation>Added &lt;SalesRestriction> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SalesRightsType"/>
				<xs:element ref="Territory"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesRestriction"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductIdentifier"/>
				<xs:element minOccurs="0" ref="PublisherName"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SalesRights"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="salesrights"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20190710_h_2" test="(: No restrictions must be the only restriction :) not(exists(SalesRestriction[SalesRestrictionType eq '99'])) or count(SalesRestriction) eq 1"/>
			<xs:assert id="_20180109_b_1" test="(: SalesRestriction must only be used when a product is for sale :) matches(SalesRightsType, '^(01|02)$') or not(exists(SalesRestriction))"/>
			<xs:assert id="_20180109_b_2" test="(: ProductIdentifier and PublisherName must only be used when a product is not for sale :) matches(SalesRightsType, '^(03|04|05|06)$') or not(exists(ProductIdentifier | PublisherName))"/>
			<xs:assert id="_20171212_c_6" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_21" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_22" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_23" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_24" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SalesRightsType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List46">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SalesRightsType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b089"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:assert id="_20171126_g_1" test="(: SalesRightsType cannot be 'unknown or unstated' :) . ne '00'"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ScriptCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List121">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ScriptCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x420"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Sender">
		<xs:annotation>
			<xs:documentation>Added &lt;TelephoneNumber> at 3.0.8</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="SenderIdentifier"/>
						<xs:element minOccurs="0" ref="SenderName"/>
					</xs:sequence>
					<xs:element ref="SenderName"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="ContactName"/>
				<xs:element minOccurs="0" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" ref="EmailAddress"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Sender"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="sender"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_20" test="(: Repeats of SenderIdentifier must each have a unique combination of valid SenderIDType, IDTypeName and IDValue :) count(SenderIdentifier) eq count(distinct-values(SenderIdentifier/string-join((SenderIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SenderIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SenderIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SenderIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="senderidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171126_b_61" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(SenderIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171126_b_62" test="(: IDValue must be a valid GLN (invalid characters) :) (SenderIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171126_b_63" test="(: IDValue must be a valid GLN (check digit error) :) (SenderIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171126_b_64" test="(: IDValue must be a valid SAN (invalid characters) :) (SenderIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_65" test="(: IDValue must be a valid SAN (invalid digit) :) (SenderIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171126_b_66" test="(: IDValue must be a valid ISNI (invalid characters) :) (SenderIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_67" test="(: IDValue must be a valid ISNI (check digit error) :) (SenderIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_68" test="(: IDValue must be a valid ORCID (invalid characters) :) (SenderIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171126_b_69" test="(: IDValue must be a valid ORCID (check digit error) :) (SenderIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171126_b_70" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (SenderIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171126_b_71" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (SenderIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171126_b_72" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (SenderIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SenderIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SenderIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="m379"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SenderName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SenderName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x298"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SentDateTime">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.DateOrDateTime">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SentDateTime"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x307"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SequenceNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveInteger">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SequenceNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b034"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SourceName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SourceName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x330"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SourceTitle">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SourceTitle"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x428"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SourceType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List157">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SourceType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x431"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="StartDate">
		<xs:annotation>
			<xs:documentation>Added dateformat attribute at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StartDate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b324"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_85" test="(: Date must be in YYYYMMDD format to match the dateformat attribute or the default :) (exists(@dateformat) and @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_86" test="(: Date must be in YYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_87" test="(: Date must be in YYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_88" test="(: Date must be in YYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_89" test="(: Date must be in YYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_90" test="(: Date must be in YYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_91" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_92" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_93" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_94" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_95" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_96" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_97" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_98" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="StartTime">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.TimeOrDuration">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StartTime"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x542"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Stock">
		<xs:annotation>
			<xs:documentation>Added &lt;Reserved> and adjacent &lt;Proximity> at revision 3.0.4</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;LocationIdentifier>, &lt;LocationName> at revision 3.0.3</xs:documentation>
			<xs:documentation>Added &lt;Proximity>, &lt;Velocity> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;StockQuantityCoded> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="LocationIdentifier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="LocationName"/>
				<xs:choice>
					<xs:element ref="StockQuantityCoded" maxOccurs="unbounded"/>
					<xs:sequence>
						<xs:element ref="OnHand"/>
						<xs:element minOccurs="0" ref="Proximity"/>
						<xs:sequence minOccurs="0">
							<xs:element ref="Reserved"/>
							<xs:element minOccurs="0" ref="Proximity"/>
						</xs:sequence>
						<xs:sequence minOccurs="0">
							<xs:element ref="OnOrder"/>
							<xs:element minOccurs="0" ref="Proximity"/>
						</xs:sequence>
						<xs:sequence minOccurs="0">
							<xs:element ref="CBO"/>
							<xs:element minOccurs="0" ref="Proximity"/>
						</xs:sequence>
					</xs:sequence>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="OnOrderDetail"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Velocity"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Stock"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="stock"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_2021" test="(: Repeats of LocationIdentifier must each have a unique combination of valid LocationIDType, IDTypeName and IDValue :) count(LocationIdentifier) eq count(distinct-values(LocationIdentifier/string-join((LocationIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171208_a_37" test="(: Repeats of LocationName must each have a unique language attribute :) (count(LocationName) le 1) or count(LocationName) eq count(distinct-values(LocationName/@language))"/>
		</xs:complexType>
		<xs:unique name="Stock_LocationName_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:LocationName"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="StockQuantityCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StockQuantityCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j297"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="StockQuantityCoded">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="StockQuantityCodeType"/>
				<xs:element minOccurs="0" ref="StockQuantityCodeTypeName"/>
				<xs:element ref="StockQuantityCode"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="StockQuantityCoded"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="stockquantitycoded"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="StockQuantityCodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List70">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StockQuantityCodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j293"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="StockQuantityCodeTypeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StockQuantityCodeTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j296"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="StreetAddress">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StreetAddress"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x552"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="StudyBibleType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List84">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="StudyBibleType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b389"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Subject">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;SubjectHeadingText> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="MainSubject"/>
				<xs:element ref="SubjectSchemeIdentifier"/>
				<xs:element minOccurs="0" ref="SubjectSchemeName"/>
				<xs:element minOccurs="0" ref="SubjectSchemeVersion"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="SubjectCode"/>
						<xs:element minOccurs="0" maxOccurs="unbounded" ref="SubjectHeadingText"/>
					</xs:sequence>
					<xs:element maxOccurs="unbounded" ref="SubjectHeadingText"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Subject"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="subject"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171218_a_1" test="(: A proprietary subject scheme requires SubjectSchemeName :) (SubjectSchemeIdentifier ne '24') or exists(SubjectSchemeName)"/>
			<xs:assert id="_20171208_a_38" test="(: Repeats of SubjectHeadingText must each have a unique language attribute :) (count(SubjectHeadingText) le 1) or count(SubjectHeadingText) eq count(distinct-values(SubjectHeadingText/@language))"/>
			<xs:assert id="_20210806_a_1" test="(: There must be a subject code with this subject scheme:) not(matches(SubjectSchemeIdentifier, '^(01|10|11|12|13|14|15|16|17|21|22|26|29|32|92|93|94|95|96|97|98|99)$')) or exists(SubjectCode)"/>
			<xs:assert id="_20210806_b_1" test="(: There must be a subject heading text with this subject scheme :) not(matches(SubjectSchemeIdentifier, '^(20)$')) or exists(SubjectHeadingText)"/>
			<xs:assert id="_20210806_c_1" test="(: SubjectCode must be a plausible Dewey classification :) (SubjectSchemeIdentifier ne '01') or not(exists(SubjectCode)) or matches(SubjectCode, '^([0-9]{3}|[1-9][0-9]|[0-9])([''/]?(\.[0-9]+)?|(\.[0-9]+[''/]?[0-9]*))$')"/>
			<xs:assert id="_20210806_c_2" test="(: SubjectCode must be a plausible Abridged Dewey classification :) (SubjectSchemeIdentifier ne '02') or not(exists(SubjectCode)) or matches(SubjectCode, '^([0-9]{3}|[1-9][0-9]|[0-9])(\.[0-9]+)?$')"/>
			<xs:assert id="_20171218_d_1" test="(: SubjectCode must be a plausible BISAC subject code :) (SubjectSchemeIdentifier ne '10') or not(exists(SubjectCode)) or matches(SubjectCode, '^[A-Z]{3}[0-9]{6}$')"/>
			<xs:assert id="_20171218_d_2" test="(: SubjectCode must be a plausible BISAC regional theme :) (SubjectSchemeIdentifier ne '11') or not(exists(SubjectCode)) or matches(SubjectCode, '^[1-7](\.([1-9])?[0-9]){6}$')"/>
			<xs:assert id="_20171218_d_3" test="(: SubjectCode must be a plausible BIC subject code :) (SubjectSchemeIdentifier ne '12') or not(exists(SubjectCode)) or matches(SubjectCode, '^([A-Z]{1,3}|[A-Z]{4}[0-9]*)$')"/>
			<xs:assert id="_20171218_d_4" test="(: SubjectCode must be a plausible BIC geographic qualifier :) (SubjectSchemeIdentifier ne '13') or not(exists(SubjectCode)) or matches(SubjectCode, '^1[A-Z]+$')"/>
			<xs:assert id="_20171218_d_5" test="(: SubjectCode must be a plausible BIC language qualifier :) (SubjectSchemeIdentifier ne '14') or not(exists(SubjectCode)) or matches(SubjectCode, '^2[A-Z]+$')"/>
			<xs:assert id="_20171218_d_6" test="(: SubjectCode must be a plausible BIC time period qualifier :) (SubjectSchemeIdentifier ne '15') or not(exists(SubjectCode)) or matches(SubjectCode, '^3[A-Z]+$')"/>
			<xs:assert id="_20171218_d_7" test="(: SubjectCode must be a plausible BIC educational purpose qualifier :) (SubjectSchemeIdentifier ne '16') or not(exists(SubjectCode)) or matches(SubjectCode, '^4[A-Z]+$')"/>
			<xs:assert id="_20171218_d_8" test="(: SubjectCode must be a plausible BIC interest qualifier :) (SubjectSchemeIdentifier ne '17') or not(exists(SubjectCode)) or matches(SubjectCode, '^5[A-Z]+$')"/>
			<xs:assert id="_20171218_d_9" test="(: SubjectCode must be a valid CBMC :) (SubjectSchemeIdentifier ne '21') or not(exists(SubjectCode)) or matches(SubjectCode, '^[ABCDE][12345][FGHJKLMNP][67][89]$')"/>
			<xs:assert id="_20171218_d_10" test="(: SubjectCode must be a plausible BISAC merchandising theme :) (SubjectSchemeIdentifier ne '22') or not(exists(SubjectCode)) or matches(SubjectCode, '^[A-Z]{2}[0-9]{3}$')"/>
			<xs:assert id="_20171218_d_11" test="(: SubjectCode must be a plausible WGSneu subject code :) (SubjectSchemeIdentifier ne '26') or not(exists(SubjectCode)) or matches(SubjectCode, '^[0-9]{4}$')"/>
			<xs:assert id="_20171218_d_12" test="(: SubjectCode must be a plausible CLIL subject code :) (SubjectSchemeIdentifier ne '29') or not(exists(SubjectCode)) or matches(SubjectCode, '^[0-9]{4}$')"/>
			<xs:assert id="_20171218_d_13" test="(: SubjectCode must be a plausible NUR subject code :) (SubjectSchemeIdentifier ne '32') or not(exists(SubjectCode)) or matches(SubjectCode, '^[0-9]{3}$')"/>
			<xs:assert id="_20171218_d_14" test="(: SubjectCode must be a plausible UKSLC shelving code :) (SubjectSchemeIdentifier ne '92') or not(exists(SubjectCode)) or matches (SubjectCode, '^([A-Z]{2}|[A-Z]{3}|[FN][579]|[FN]11)$')"/>
			<xs:assert id="_20171218_d_15" test="(: SubjectCode must be a plausible Thema subject code :) (SubjectSchemeIdentifier ne '93') or not(exists(SubjectCode)) or matches(SubjectCode, '^([A-Z]{1,3}|[A-Z]{4}[0-9]*)$') and not(matches(SubjectCode, '^(B.*|C|D|E.*|F|G|H.*|I.*|L|N|O.*|P|Q|R|T|U|V|W|X|Y|Z.*)$'))"/>
			<xs:assert id="_20171218_d_16" test="(: SubjectCode must be a plausible Thema place qualifier :) (SubjectSchemeIdentifier ne '94') or not(exists(SubjectCode)) or matches(SubjectCode, '^1[A-Z]+(\-[A-Z]{2}\-[A-Z]*)?$')"/>
			<xs:assert id="_20171218_d_17" test="(: SubjectCode must be a plausible Thema language qualifier :) (SubjectSchemeIdentifier ne '95') or not(exists(SubjectCode)) or matches(SubjectCode, '^2[A-Z]+(\-[A-Z]{2}\-[A-Z]*)?$')"/>
			<xs:assert id="_20171218_d_18" test="(: SubjectCode must be a plausible Thema time period qualifier :) (SubjectSchemeIdentifier ne '96') or not(exists(SubjectCode)) or matches(SubjectCode, '^3[A-Z]+(\-[A-Z]{2}\-[A-Z]*)?$')"/>
			<xs:assert id="_20171218_d_19" test="(: SubjectCode must be a plausible Thema educational purpose qualifier :) (SubjectSchemeIdentifier ne '97') or not(exists(SubjectCode)) or matches(SubjectCode, '^4[A-Z]+(\-[A-Z]{2}\-[A-Z]*)?$')"/>
			<xs:assert id="_20171218_d_20" test="(: SubjectCode must be a plausible Thema interest qualifier :) (SubjectSchemeIdentifier ne '98') or not(exists(SubjectCode)) or matches(SubjectCode, '^5[A-Z]+(\-[A-Z]{2}\-[A-Z]*)?$')"/>
			<xs:assert id="_20171218_d_21" test="(: SubjectCode must be a plausible Thema style qualifier :) (SubjectSchemeIdentifier ne '99') or not(exists(SubjectCode)) or matches(SubjectCode, '^6[A-Z][A-Z]+(\-[A-Z]{2}\-[A-Z]*)?$')"/>
			<xs:assert id="_20171218_d_22" test="(: SubjectSchemeVersion must be a plausible BIC version number :) not(matches(SubjectSchemeIdentifier, '^(1[2-7])$')) or not(exists(SubjectSchemeVersion)) or matches(SubjectSchemeVersion, '^(1|1\.1|2|2\.0|2\.01|2\.0\.01|2\.1)$')"/>
			<xs:assert id="_20171218_d_23" test="(: SubjectSchemeVersion must be a plausible Thema version number :) not(matches(SubjectSchemeIdentifier, '^(9[3-9])$')) or not(exists(SubjectSchemeVersion)) or matches(SubjectSchemeVersion, '^(1\.[0-4])(\.[0-9])?$')"/>
			<xs:assert id="_20171218_d_24" test="(: SubjectSchemeVersion must be a plausible BISAC version number :) not(matches(SubjectSchemeIdentifier, '^(10)$')) or not(exists(SubjectSchemeVersion)) or matches(SubjectSchemeVersion, '^(1\.0|2\.[0-9]|20(0[6-9]|1[0-9]|2[0-9]))$')"/>
		</xs:complexType>
		<xs:unique name="SubjectHeadingText_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SubjectHeadingText"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="SubjectCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SubjectCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b069"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SubjectDate">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SubjectDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SubjectDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="subjectdate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<!-- was previously 20171208d -->
			<xs:assert id="_20180202_b_15" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20180202_b_16" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20180202_b_17" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20180202_b_18" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20180202_b_19" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20180202_b_20" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^([01][0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20180202_b_21" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20180202_b_22" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20180202_b_23" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20180202_b_24" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20180202_b_25" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^(([01][0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20180202_b_26" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^([01][0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20180202_b_27" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20180202_b_28" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^((([01][0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|(([01][0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|(([01][0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SubjectDateRole">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List177">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SubjectDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x534"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SubjectHeadingText">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SubjectHeadingText"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b070"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SubjectSchemeIdentifier">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List27">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SubjectSchemeIdentifier"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b067"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SubjectSchemeName">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SubjectSchemeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b171"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SubjectSchemeVersion">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SubjectSchemeVersion"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b068"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Subtitle">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Subtitle"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b029"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="textcaseAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SuffixToKey">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SuffixToKey"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b248"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Supplier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SupplierRole"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="SupplierIdentifier"/>
						<xs:element minOccurs="0" ref="SupplierName"/>
					</xs:sequence>
					<xs:element ref="SupplierName"/>
				</xs:choice>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="FaxNumber"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="EmailAddress"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Website"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Supplier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_22" test="(: Repeats of SupplierIdentifier must each have a unique combination of valid SupplierIDType, IDTypeName and IDValue :) count(SupplierIdentifier) eq count(distinct-values(SupplierIdentifier/string-join((SupplierIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierCodeType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List165">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplierCodeType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x458"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierCodeTypeName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplierCodeTypeName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x513"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierCodeValue">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplierCodeValue"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x459"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SupplierIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplierIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplieridentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_62" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(SupplierIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_63" test="(: IDValue must be a valid GLN (invalid characters) :) (SupplierIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_64" test="(: IDValue must be a valid GLN (check digit error) :) (SupplierIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_65" test="(: IDValue must be a valid SAN (invalid characters) :) (SupplierIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_66" test="(: IDValue must be a valid SAN (check digit error) :) (SupplierIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List92">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplierIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j345"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierName">
		<xs:annotation>
			<xs:documentation>Added collationkey attribute at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplierName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j137"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierOwnCoding">
		<xs:annotation>
			<xs:documentation>Added &lt;SupplierCodeTypeName> at revison 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SupplierCodeType"/>
				<xs:element minOccurs="0" ref="SupplierCodeTypeName"/>
				<xs:element ref="SupplierCodeValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplierOwnCoding"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplierowncoding"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplierRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List93">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplierRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j292"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyContact">
		<xs:annotation>
			<xs:documentation>Added &lt;TelephoneNumber> at 3.0.8</xs:documentation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SupplyContactRole"/>
				<xs:choice>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="SupplyContactIdentifier"/>
						<xs:element minOccurs="0" ref="SupplyContactName"/>
					</xs:sequence>
					<xs:element ref="SupplyContactName"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="ContactName"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TelephoneNumber"/>
				<xs:element minOccurs="0" ref="EmailAddress"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplyContact"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplycontact"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_23" test="(: Repeats of SupplyContactIdentifier must each have a unique combination of valid SupplyContactIDType, IDTypeName and IDValue :) count(SupplyContactIdentifier) eq count(distinct-values(SupplyContactIdentifier/string-join((SupplyContactIDType | IDTypeName | IDValue), ' ')))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyContactIdentifier">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SupplyContactIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplyContactIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplycontactidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_67" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) matches(SupplyContactIDType, '^(01|02)$') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_68" test="(: IDValue must be a valid GLN (invalid characters) :) (SupplyContactIDType ne '06') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_69" test="(: IDValue must be a valid GLN (check digit error) :) (SupplyContactIDType ne '06') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_70" test="(: IDValue must be a valid SAN (invalid characters) :) (SupplyContactIDType ne '07') or matches(IDValue, '^[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_71" test="(: IDValue must be a valid SAN (check digit error) :) (SupplyContactIDType ne '07') or not(matches(IDValue, '^[0-9]{6}[0-9Xx]$')) or (7 * number(substring(IDValue, 1, 1)) + 6 * number(substring(IDValue, 2, 1)) + 5 * number(substring(IDValue, 3, 1)) + 4 * number(substring(IDValue, 4, 1)) + 3 * number(substring(IDValue, 5, 1)) + 2 * number(substring(IDValue, 6, 1)) + (if (matches(substring(IDValue, 7, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 7, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171221_j_72" test="(: IDValue must be a valid ISNI (invalid characters) :) (SupplyContactIDType ne '16') or matches(IDValue, '^([0]{7}(0[0-9]|1[0-4]|3[5-9]|[4-9][0-9])|[1-9][0-9]{8}|[0-9][1-9][0-9]{7}|[0-9]{2}[1-9][0-9]{6}|[0-9]{3}[1-9][0-9]{5}|[0-9]{4}[1-9][0-9]{4}|[0-9]{5}[1-9][0-9]{3}|[0-9]{6}[1-9][0-9]{2})[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_73" test="(: IDValue must be a valid ISNI (check digit error) :) (SupplyContactIDType ne '16') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_74" test="(: IDValue must be a valid ORCID (invalid characters) :) (SupplyContactIDType ne '21') or matches(IDValue, '^[0]{7}(1[5-9]|2[0-9]|3[0-4])[0-9]{6}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_75" test="(: IDValue must be a valid ORCID (check digit error) :) (SupplyContactIDType ne '21') or not(matches(IDValue, '^[0-9]{15}[0-9Xx]$')) or ((12 - (32768 * number(substring(IDValue, 1, 1)) + 16384 * number(substring(IDValue, 2, 1)) + 8192 * number(substring(IDValue, 3, 1)) + 4096 * number(substring(IDValue, 4, 1)) + 2048 * number(substring(IDValue, 5, 1)) + 1024 * number(substring(IDValue, 6, 1)) + 512 * number(substring(IDValue, 7, 1)) + 256 * number(substring(IDValue, 8, 1)) + 128 * number(substring(IDValue, 9, 1)) + 64 * number(substring(IDValue, 10, 1)) + 32 * number(substring(IDValue, 11, 1)) + 16 * number(substring(IDValue, 12, 1)) + 8 * number(substring(IDValue, 13, 1)) + 4 * number(substring(IDValue, 14, 1)) + 2 * number(substring(IDValue, 15, 1))) mod 11) mod 11 eq (if (matches(substring(IDValue, 16, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_76" test="(: IDValue must be a plausible Ringgold ID (invalid characters) :) (SupplyContactIDType ne '27') or matches(IDValue, '^[0-9]{4,}$')"/>
			<xs:assert id="_20171221_j_77" test="(: IDValue must be a plausible EIDR DOI (invalid prefix) :) (SupplyContactIDType ne '29') or matches(IDValue, '^10\.5237/.+$')"/>
			<xs:assert id="_20171221_j_78" test="(: IDValue must be a plausible FundRef DOI (invalid prefix) :) (SupplyContactIDType ne '32') or matches(IDValue, '^10\.13039/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyContactIDType">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List44">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplyContactIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x538"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyContactName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplyContactName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x539"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyContactRole">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.4</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List239">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplyContactRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x537"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyDate">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;DateFormat> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="SupplyDateRole"/>
				<xs:element minOccurs="0" ref="DateFormat"/>
				<xs:element ref="Date"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplyDate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplydate"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_d_71" test="(: Date must be in YYYYMMDD format to match the dateformat attribute, DateFormat or the default :) not(Date/@dateformat eq '00' or (not(exists(Date/@dateformat)) and (DateFormat eq '00' or not(exists(DateFormat))))) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
			<xs:assert id="_20171208_d_72" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '01' or (not(exists(Date/@dateformat)) and DateFormat eq '01')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
			<xs:assert id="_20171208_d_73" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '02' or (not(exists(Date/@dateformat)) and DateFormat eq '02')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
			<xs:assert id="_20171208_d_74" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '03' or (not(exists(Date/@dateformat)) and DateFormat eq '03')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_75" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '04' or (not(exists(Date/@dateformat)) and DateFormat eq '04')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
			<xs:assert id="_20171208_d_76" test="(: Date must be in YYYY format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '05' or (not(exists(Date/@dateformat)) and DateFormat eq '05')) or matches(Date, '^(1[0-9]{3}|20[0-9]{2})$')"/>
			<xs:assert id="_20171208_d_77" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '06' or (not(exists(Date/@dateformat)) and DateFormat eq '06')) or (matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(Date, 9, 8) ge substring(Date, 1, 8)))"/>
			<xs:assert id="_20171208_d_78" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '07' or (not(exists(Date/@dateformat)) and DateFormat eq '07')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_79" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '08' or (not(exists(Date/@dateformat)) and DateFormat eq '08')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(Date, 7, 6) ge substring(Date, 1, 6)))"/>
			<xs:assert id="_20171208_d_80" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '09' or (not(exists(Date/@dateformat)) and DateFormat eq '09')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_81" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '10' or (not(exists(Date/@dateformat)) and DateFormat eq '10')) or (matches(Date, '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(Date, 6, 5) ge substring(Date, 1, 5)))"/>
			<xs:assert id="_20171208_d_82" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat:) not(Date/@dateformat eq '11' or (not(exists(Date/@dateformat)) and DateFormat eq '11')) or (matches(Date, '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(Date, 5, 4) ge substring(Date, 1, 4)))"/>
			<xs:assert id="_20171208_d_83" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '13' or (not(exists(Date/@dateformat)) and DateFormat eq '13')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
			<xs:assert id="_20171208_d_84" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) not(Date/@dateformat eq '14' or (not(exists(Date/@dateformat)) and DateFormat eq '14')) or matches(Date, '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyDateRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List166">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="SupplyDateRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x461"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupplyDetail">
		<xs:annotation>
			<xs:documentation>Container for data specifying a supplier operating in a market, the availability of the product from that supplier, and supplier’s commercial terms including prices</xs:documentation>
			<xs:documentation>Added &lt;PalletQuantity> at revision 3.0.5</xs:documentation>
			<xs:documentation>Added &lt;SupplyContact> at revision 3.0.4</xs:documentation>
			<xs:documentation>Added &lt;OrderQuantityMinimum>, &lt;OrderQuantityMultiple> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;Supplier> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="Supplier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SupplyContact"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SupplierOwnCoding"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ReturnsConditions"/>
				<xs:element ref="ProductAvailability"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SupplyDate"/>
				<xs:element minOccurs="0" ref="OrderTime"/>
				<xs:element minOccurs="0" ref="NewSupplier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="Stock"/>
				<xs:element minOccurs="0" ref="PackQuantity"/>
				<xs:element minOccurs="0" ref="PalletQuantity"/>
				<xs:sequence minOccurs="0">
					<xs:element maxOccurs="2" ref="OrderQuantityMinimum"/>
					<xs:element minOccurs="0" ref="OrderQuantityMultiple"/>
				</xs:sequence>
				<xs:choice>
					<xs:element ref="UnpricedItemType"/>
					<xs:element maxOccurs="unbounded" ref="Price"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="Reissue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupplyDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supplydetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_e_8" test="(: Repeats of SupplyDate must each have a unique SupplyDateRole :) count(SupplyDate) eq count(distinct-values(SupplyDate/SupplyDateRole))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="SupportingResource">
		<xs:annotation>
			<xs:documentation>Added &lt;Territory> at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="ResourceContentType"/>
				<xs:element maxOccurs="unbounded" ref="ContentAudience"/>
				<xs:element minOccurs="0" ref="Territory"/>
				<xs:element ref="ResourceMode"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ResourceFeature"/>
				<xs:element maxOccurs="unbounded" ref="ResourceVersion"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="SupportingResource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="supportingresource"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_k_2" test="(: Repeats of ContentAudience must each be a unique :) count(ContentAudience) eq count(distinct-values(ContentAudience))"/>
			<xs:assert id="_20180105_c_1" test="(: Repeats of ResourceFeature must each have a unique ResourceFeatureType (with the exception of resource contributor IDs) :) count(ResourceFeature[not(matches(ResourceFeatureType, '^(05|06)$'))]) eq count(distinct-values(ResourceFeature[not(matches(ResourceFeatureType, '^(05|06)$'))]/ResourceFeatureType))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="Tax">
		<xs:annotation>
			<xs:documentation>Added &lt;PricePartDescription> at revision 3.0.4</xs:documentation>
			<xs:documentation>Added &lt;ProductIdentifier> at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductIdentifier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PricePartDescription"/>
				<xs:element minOccurs="0" ref="TaxType"/>
				<xs:element minOccurs="0" ref="TaxRateCode"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="TaxRatePercent"/>
						<xs:element minOccurs="0" ref="TaxableAmount"/>
						<xs:element minOccurs="0" ref="TaxAmount"/>
					</xs:sequence>
					<xs:sequence>
						<xs:element minOccurs="0" ref="TaxableAmount"/>
						<xs:element ref="TaxAmount"/>
					</xs:sequence>
				</xs:choice>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Tax"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="tax"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171212_c_7" test="(: Repeats of ProductIdentifier must each have a unique combination of valid ProductIDType, IDTypeName and IDValue :) count(ProductIdentifier) eq count(distinct-values(ProductIdentifier/string-join((ProductIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20171212_d_25" test="(: Any ISBN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 978 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('978', replace($isbn10, '.$', ''))]))"/>
			<xs:assert id="_20171212_d_26" test="(: Any ISBN-10 must NOT be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 starting 979 :) not(exists(ProductIdentifier[ProductIDType eq '02'])) or (every $isbn10 in ProductIdentifier[ProductIDType eq '02']/IDValue satisfies not(exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[replace(., '.$', '') eq concat('979', replace($isbn10, '.$', ''))])))"/>
			<xs:assert id="_20171212_d_27" test="(: Any ISMN-10 must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISMN-13 :) not(exists(ProductIdentifier[ProductIDType eq '05'])) or (every $ismn10 in ProductIdentifier[ProductIDType eq '05']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|25)$')]/IDValue[. eq replace($ismn10, 'M', '9790')]))"/>
			<xs:assert id="_20171212_d_28" test="(: Any ISBN-A must be accompanied by a repeat of ProductIdentifier giving the same identifier expressed as an ISBN-13 :) not(exists(ProductIdentifier[ProductIDType eq '26'])) or (every $isbna in ProductIdentifier[ProductIDType eq '26']/IDValue satisfies exists(ProductIdentifier[matches(ProductIDType, '^(03|15|24)$')]/IDValue[. eq replace($isbna, '^10|\.|/', '')]))"/>
			<xs:assert id="_20171208_a_39" test="(: Repeats of PricePartDescription must each have a unique language attribute :) (count(PricePartDescription) le 1) or count(PricePartDescription) eq count(distinct-values(PricePartDescription/@language))"/>
			<xs:assert id="_20171221_c_1" test="(: TaxAmount must be the product of TaxRatePercent and TaxableAmount :) not(exists(TaxableAmount)) or not(exists(TaxRatePercent)) or not(exists(TaxAmount)) or abs(TaxAmount - TaxableAmount * TaxRatePercent div 100) lt 0.01"/>
		</xs:complexType>
		<xs:unique name="PricePartDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:PricePartDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="TaxableAmount">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.StrictPositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TaxableAmount"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x473"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TaxAmount">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TaxAmount"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x474"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TaxExempt">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TaxExempt"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="x546"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="TaxRateCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List62">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TaxRateCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x471"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TaxRatePercent">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PercentDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TaxRatePercent"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x472"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TaxType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List171">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TaxType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x470"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TelephoneNumber">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TelephoneNumber"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j270"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Territory">
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element ref="CountriesIncluded"/>
					<xs:element minOccurs="0" ref="RegionsIncluded"/>
					<xs:element minOccurs="0" ref="RegionsExcluded"/>
				</xs:sequence>
				<xs:sequence>
					<xs:element ref="RegionsIncluded"/>
					<xs:element minOccurs="0" ref="CountriesExcluded"/>
					<xs:element minOccurs="0" ref="RegionsExcluded"/>
				</xs:sequence>
			</xs:choice>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Territory"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="territory"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_h_1" test="(: RegionsIncluded must not contain 'WORLD' if CountriesIncluded is present :) not(exists(CountriesIncluded) and exists(RegionsIncluded)) or RegionsIncluded != 'WORLD'"/>
			<xs:assert id="_20171208_i_1" test="(: RegionsIncluded must contain 'WORLD' if either CountriesExcluded or RegionsExcluded are present :) not(not(exists(CountriesIncluded)) and exists(CountriesExcluded | RegionsExcluded)) or RegionsIncluded = 'WORLD'"/>
			<xs:assert id="_20171221_f_1" test="(: Each region in RegionsExcluded must be within one of the countries in CountriesIncluded :) not(exists(RegionsExcluded)) or not(exists(CountriesIncluded)) or (every $region in tokenize(string(RegionsExcluded), ' ') satisfies matches(string(CountriesIncluded), substring(string($region), 1, 2)))"/>
			<xs:assert id="_20171221_g_1" test="(: Each region in RegionsExcluded must not be within any of the countries in CountriesExcluded :) not(exists(RegionsExcluded)) or not(exists(CountriesExcluded)) or (every $region in tokenize(string(RegionsExcluded), ' ') satisfies not(matches(string(CountriesExcluded), substring(string($region), 1, 2))))"/>
			<xs:assert id="_20171221_g_2" test="(: Each region in RegionsIncluded must not be within any of the countries in CountriesIncluded :) not(exists(RegionsIncluded)) or not(exists(CountriesIncluded)) or (every $region in tokenize(string(RegionsIncluded), ' ') satisfies not(matches(string(CountriesIncluded), substring(string($region), 1, 2))))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="Text">
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="Text"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="d104"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_49" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_50" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_25" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_25" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_25" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_25" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextAuthor">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TextAuthor"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="d107"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextContent">
		<xs:annotation>
			<xs:documentation>Added &lt;TextSourceDescription> at revision 3.0.7</xs:documentation>
			<xs:documentation>Added &lt;Territory>, &lt;ReviewRating> at revision 3.0.3</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;SourceTitle> at revision 3.0.2</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;Text> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="TextType"/>
				<xs:element maxOccurs="unbounded" ref="ContentAudience"/>
				<xs:element minOccurs="0" ref="Territory"/>
				<xs:element maxOccurs="unbounded" ref="Text"/>
				<xs:element minOccurs="0" ref="ReviewRating"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TextAuthor"/>
				<xs:element minOccurs="0" ref="TextSourceCorporate"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TextSourceDescription"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="SourceTitle"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContentDate"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TextContent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="textcontent"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171208_k_3" test="(: Repeats of ContentAudience must each be unique :) count(ContentAudience) eq count(distinct-values(ContentAudience))"/>
			<xs:assert id="_20171208_a_40" test="(: Repeats of Text must each have a unique language attribute :) (count(Text) le 1) or count(Text) eq count(distinct-values(Text/@language))"/>
			<xs:assert id="_20171221_e_1" test="(: A short description must not be longer than 350 characters (including any markup) :) (TextType ne '02') or (every $text in Text satisfies string-length($text) le 350)"/>
			<xs:assert id="_20171208_a_41" test="(: Repeats of SourceTitle must each have a unique language attribute :) (count(SourceTitle) le 1) or count(SourceTitle) eq count(distinct-values(SourceTitle/@language))"/>
			<xs:assert id="_20171208_e_9" test="(: Repeats of ContentDate must each have a unique ContentDateRole :) count(ContentDate) eq count(distinct-values(ContentDate/ContentDateRole))"/>
			<xs:assert id="_20180109_g_7" test="(: For repeats of ContentDate with matching From and To roles, the From date must precede the To date :) if (exists(ContentDate[ContentDateRole eq '14']) and exists(ContentDate[ContentDateRole eq '15'])) then (if ((if (exists(ContentDate[ContentDateRole eq '14']/Date/@dateformat)) then ContentDate[ContentDateRole eq '14']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '14']/DateFormat)) then ContentDate[ContentDateRole eq '14']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '15']/Date/@dateformat)) then ContentDate[ContentDateRole eq '15']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '15']/DateFormat)) then ContentDate[ContentDateRole eq '15']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '14']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '15']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '14']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '15']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '15']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '14']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '15']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '14']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '15']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '15']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '14']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '15']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '14']/Date le ContentDate[ContentDateRole eq '15']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20180109_g_8" test="(: For repeats of ContentDate with matching Available from and Available until roles, the Available from date must precede the Available until date :) if (exists(ContentDate[ContentDateRole eq '27']) and exists(ContentDate[ContentDateRole eq '28'])) then (if ((if (exists(ContentDate[ContentDateRole eq '27']/Date/@dateformat)) then ContentDate[ContentDateRole eq '27']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '27']/DateFormat)) then ContentDate[ContentDateRole eq '27']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '28']/Date/@dateformat)) then ContentDate[ContentDateRole eq '28']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '28']/DateFormat)) then ContentDate[ContentDateRole eq '28']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '27']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '28']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '27']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '28']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '28']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '27']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '28']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '27']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '28']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '28']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '27']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '28']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '27']/Date le ContentDate[ContentDateRole eq '28']/Date) else true()) else true()) else true()"/>
			<xs:assert id="_20180109_g_9" test="(: For repeats of ContentDate with matching Associated start and Associated end roles, the Associated start date must precede the Associated end date :) if (exists(ContentDate[ContentDateRole eq '31']) and exists(ContentDate[ContentDateRole eq '32'])) then (if ((if (exists(ContentDate[ContentDateRole eq '31']/Date/@dateformat)) then ContentDate[ContentDateRole eq '31']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '31']/DateFormat)) then ContentDate[ContentDateRole eq '31']/DateFormat else '00') eq (if (exists(ContentDate[ContentDateRole eq '32']/Date/@dateformat)) then ContentDate[ContentDateRole eq '32']/Date/@dateformat else if (exists(ContentDate[ContentDateRole eq '32']/DateFormat)) then ContentDate[ContentDateRole eq '32']/DateFormat else '00')) then (if ((if (contains(ContentDate[ContentDateRole eq '31']/Date, '+')) then (contains(ContentDate[ContentDateRole eq '32']/Date, '+') and (substring-after(ContentDate[ContentDateRole eq '31']/Date, '+') eq substring-after(ContentDate[ContentDateRole eq '32']/Date, '+'))) else not(contains(ContentDate[ContentDateRole eq '32']/Date, '+'))) and (if (contains(ContentDate[ContentDateRole eq '31']/Date, '-')) then (contains(ContentDate[ContentDateRole eq '32']/Date, '-') and (substring-after(ContentDate[ContentDateRole eq '31']/Date, '-') eq substring-after(ContentDate[ContentDateRole eq '32']/Date, '-'))) else not(contains(ContentDate[ContentDateRole eq '32']/Date, '-'))) and (matches(ContentDate[ContentDateRole eq '31']/Date, 'Z') eq matches(ContentDate[ContentDateRole eq '32']/Date, 'Z'))) then (ContentDate[ContentDateRole eq '31']/Date le ContentDate[ContentDateRole eq '32']/Date) else true()) else true()) else true()"/>
		</xs:complexType>
		<xs:unique name="Text_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:Text"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="TextSourceDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:TextSourceDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="SourceTitle_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:SourceTitle"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="TextItem">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="TextItemType"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="TextItemIdentifier"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PageRun"/>
				<xs:element minOccurs="0" ref="NumberOfPages"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TextItem"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="textitem"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_i_24" test="(: Repeats of TextItemIdentifier must each have a unique combination of valid TextItemIDType, IDTypeName and IDValue :) count(TextItemIdentifier) eq count(distinct-values(TextItemIdentifier/string-join((TextItemIDType | IDTypeName | IDValue), ' ')))"/>
			<xs:assert id="_20181113_d_1" test="(: NumberOfPages must be consistent with the FirstPageNumber and LastPageNumber :) not(exists(PageRun/LastPageNumber) and exists(NumberOfPages) and matches(PageRun/FirstPageNumber, '^[1-9][0-9]*$') and matches(PageRun/LastPageNumber, '^[1-9][0-9]*$')) or abs(number(PageRun/LastPageNumber) - number(PageRun/FirstPageNumber) - number(NumberOfPages)) le 1"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextItemIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="TextItemIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TextItemIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="textitemidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_79" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (TextItemIDType eq '01') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_80" test="(: IDValue must be a valid ISTC (invalid characters) :) (TextItemIDType ne '11') or matches(IDValue, '^[0-9A-Fa-f]{3}2[0-9]{3}[0-9A-Fa-f]{9}$')"/>
			<xs:assert id="_20171221_j_81" test="(: IDValue must be a valid ISTC (check digit error) :) (TextItemIDType ne '11') or not(matches(IDValue, '^[0-9A-Fa-f]{3}2[0-9]{3}[0-9A-Fa-f]{9}$')) or (11 * (string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 1, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 5, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 9, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 13, 1))))) + 9 * (string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 2, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 6, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 10, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 14, 1))))) + 3 * (string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 3, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 7, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 11, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 15, 1))))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 4, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 8, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 12, 1))))) mod 16 eq string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_82" test="(: IDValue must be a valid GTIN-13 (invalid characters) :) (TextItemIDType ne '03') or matches(IDValue, '^[0-9]{13}$')"/>
			<xs:assert id="_20171221_j_83" test="(: IDValue must be a valid GTIN-13 (check digit error) :) (TextItemIDType ne '03') or not(matches(IDValue, '^[0-9]{13}$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_84" test="(: IDValue must be a valid ISBN-13 (invalid characters) :) (TextItemIDType ne '15') or matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')"/>
			<xs:assert id="_20171221_j_85" test="(: IDValue must be a valid ISBN-13 (check digit error) :) (TextItemIDType ne '15') or not(matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_86" test="(: IDValue must be a plausible DOI (invalid structure) :) (TextItemIDType ne '06') or matches(IDValue, '^10\.([1-9][0-9]*)(\.[0-9]+)?/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextItemIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List43">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TextItemIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b285"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextItemType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List42">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TextItemType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b290"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextSourceCorporate">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TextSourceCorporate"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b374"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextSourceDescription">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TextSourceDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x557"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_51" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_52" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_26" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_26" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_26" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_26" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TextType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List153">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TextType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x426"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ThesisPresentedTo">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ThesisPresentedTo"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b369"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ThesisType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List72">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ThesisType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b368"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ThesisYear">
		<xs:annotation>
			<xs:documentation>Added dateformat attribute at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ThesisYear"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b370"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="dateformatAttribute"/>
					<xs:assert id="_20171208_f_99" test="(: Date must be in YYYYMMDD format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '00') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))$')"/>
					<xs:assert id="_20171208_f_100" test="(: Date must be in YYYYMM format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '01') or matches(., '^(1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])$')"/>
					<xs:assert id="_20171208_f_101" test="(: Date must be in YYYYWW format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '02') or matches(., '^(1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])$')"/>
					<xs:assert id="_20171208_f_102" test="(: Date must be in YYYYQ format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '03') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_103" test="(: Date must be in YYYYS format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '04') or matches(., '^(1[0-9]{3}|20[0-9]{2})([1-4])$')"/>
					<xs:assert id="_20171208_f_104" test="(: Date must be in YYYY format to match the dateformat attribute, DateFormat or the default :) (exists(@dateformat) and @dateformat ne '05') or matches(., '^(1[0-9]{3}|20[0-9]{2})$')"/>
					<xs:assert id="_20171208_f_105" test="(: Date range must be in YYYYMMDDYYYYMMDD format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '06') or (matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229)){2}$') and (substring(., 9, 8) ge substring(., 1, 8)))"/>
					<xs:assert id="_20171208_f_106" test="(: Date range must be in YYYYMMYYYYMM format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '07') or (matches(., '^((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_107" test="(: Date range must be in YYYYWWYYYYWW format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '08') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([0-4][0-9]|5[0-3])){2}$') and (substring(., 7, 6) ge substring(., 1, 6)))"/>
					<xs:assert id="_20171208_f_108" test="(: Date range must be in YYYYQYYYYQ format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '09') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_109" test="(: Date range must be in YYYYSYYYYS format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '10') or (matches(., '^((1[0-9]{3}|20[0-9]{2})([1-4])){2}$') and (substring(., 6, 5) ge substring(., 1, 5)))"/>
					<xs:assert id="_20171208_f_110" test="(: Date range must be in YYYYYYYY format to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '11') or (matches(., '^(1[0-9]{3}|20[0-9]{2}){2}$') and (substring(., 5, 4) ge substring(., 1, 4)))"/>
					<xs:assert id="_20171208_f_112" test="(: Datetime must be in YYYYMMDDThhmm format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '13') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])|2400)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
					<xs:assert id="_20171208_f_113" test="(: Datetime must be in YYYYMMDDThhmmss format (with optional Z or timezone) to match the dateformat attribute or DateFormat :) (not(exists(@dateformat)) or @dateformat ne '14') or matches(., '^(((1[0-9]{3}|20[0-9]{2})(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8]))|((1[0-9]{3}|20[0-9]{2})(0[13-9]|1[0-2])(29|30))|((1[0-9]{3}|20[0-9]{2})(0[13578]|1[02])31)|(0[048](0[048]|[13579][26]|[2468][048])0229)|(0[1235679](0[48]|[13579][26]|[2468][048])0229)|(1[26](0[048]|[13579][26]|[2468][048])0229)|(1[01345789](0[48]|[13579][26]|[2468][048])0229)|(20(0[048]|[13579][26]|[2468][048])0229))T((0[0-9]|1[0-9]|2[0-3])([0-5][0-9])([0-5][0-9])|240000)(Z|\+(0000|0100|0200|0300|0330|0400|0430|0500|0530|0545|0600|0630|0700|0800|0830|0900|0930|1000|1030|1100|1130|1200|1245|1300|1400)|-(0000|0100|0200|0300|0330|0400|0500|0600|0700|0800|0900|0930|1000|1100|1200))?$')"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TimeRun">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.5</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="StartTime"/>
				<xs:element minOccurs="0" ref="EndTime"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TimeRun"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="timerun"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20181026_e_1" test="(: EndTime must be greater than StartTime :) not(exists(EndTime)) or number(substring(concat(string(EndTime), '00'), 1, 9)) gt number(substring(concat(string(StartTime), '00'), 1, 9))"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitleDetail">
		<xs:annotation>
			<xs:documentation>Added &lt;TitleStatement> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="TitleType"/>
				<xs:element maxOccurs="unbounded" ref="TitleElement"/>
				<xs:element minOccurs="0" ref="TitleStatement"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TitleDetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="titledetail"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
		<xs:unique name="TitleElement_SequenceNumber_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:TitleElement"/>
			<xs:field xpath="onix:SequenceNumber"/>
		</xs:unique>
	</xs:element>
	<xs:element name="TitleElement">
		<xs:annotation>
			<xs:documentation>Added &lt;NoPrefix> at revision 3.0.2</xs:documentation>
			<xs:documentation>Added &lt;SequenceNumber> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="SequenceNumber"/>
				<xs:element ref="TitleElementLevel"/>
				<xs:choice>
					<xs:sequence>
						<xs:element ref="PartNumber"/>
						<xs:element minOccurs="0" ref="YearOfAnnual"/>
						<xs:choice minOccurs="0">
							<xs:sequence>
								<xs:choice>
									<xs:element ref="TitlePrefix"/>
									<xs:element ref="NoPrefix"/>
								</xs:choice>
								<xs:element ref="TitleWithoutPrefix"/>
							</xs:sequence>
							<xs:element ref="TitleText"/>
						</xs:choice>
					</xs:sequence>
					<xs:sequence>
						<xs:element ref="YearOfAnnual"/>
						<xs:choice minOccurs="0">
							<xs:sequence>
								<xs:choice>
									<xs:element ref="TitlePrefix"/>
									<xs:element ref="NoPrefix"/>
								</xs:choice>
								<xs:element ref="TitleWithoutPrefix"/>
							</xs:sequence>
							<xs:element ref="TitleText"/>
						</xs:choice>
					</xs:sequence>
					<xs:sequence>
						<xs:choice>
							<xs:element ref="TitlePrefix"/>
							<xs:element ref="NoPrefix"/>
						</xs:choice>
						<xs:element ref="TitleWithoutPrefix"/>
					</xs:sequence>
					<xs:element ref="TitleText"/>
				</xs:choice>
				<xs:element minOccurs="0" ref="Subtitle"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="TitleElement"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="titleelement"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20181210_c_1" test="(: PartNumber cannot be used at element level 02 :) not(exists(PartNumber)) or TitleElementLevel ne '02'"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitleElementLevel">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List149">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitleElementLevel"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x409"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitlePrefix">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitlePrefix"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b030"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="textcaseAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitlesAfterNames">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitlesAfterNames"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b043"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitlesBeforeNames">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitlesBeforeNames"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b038"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitleStatement">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitleStatement"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x478"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_53" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_54" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_27" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_27" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_27" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_27" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitleText">
		<xs:annotation>
			<xs:documentation>Added textscript attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitleText"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b203"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="textcaseAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitleType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List15">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitleType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b202"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TitleWithoutPrefix">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.2</xs:documentation>
			<xs:documentation>Added collationkey, textscript attributes at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TitleWithoutPrefix"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b031"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="collationkeyAttribute"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textscriptAttribute"/>
					<xs:attributeGroup ref="textcaseAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ToLanguage">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List74">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ToLanguage"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x413"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="ToQuantity">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.PositiveDecimal">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ToQuantity"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x514"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="TradeCategory">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List12">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="TradeCategory"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b384"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="UnnamedPersons">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List19">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="UnnamedPersons"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b249"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="UnpricedItemType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List57">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="UnpricedItemType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="j192"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Velocity">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="VelocityMetric"/>
				<xs:element ref="Rate"/>
				<xs:element minOccurs="0" ref="Proximity"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Velocity"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="velocity"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="VelocityMetric">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List216">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="VelocityMetric"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x504"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="VenueName">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyString">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="VenueName"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x551"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="VenueNote">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.7</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="VenueNote"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x553"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_55" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_56" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_28" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_28" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_28" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_28" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="Website">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;WebsiteLink> at revision 3.0.6</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;WebsiteDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="WebsiteRole"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="WebsiteDescription"/>
				<xs:element maxOccurs="unbounded" ref="WebsiteLink"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="Website"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="website"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20181210_e_1" test="(: Website description must be included if role is unspecified :) not(exists(WebsiteRole[. eq '00'])) or exists(WebsiteDescription)"/>
			<xs:assert id="_20171208_a_42" test="(: Repeats of WebsiteDescription must each have a unique language attribute :) (count(WebsiteDescription) le 1) or count(WebsiteDescription) eq count(distinct-values(WebsiteDescription/@language))"/>
			<xs:assert id="_20171208_a_43" test="(: Repeats of WebsiteLink must each have a unique language attribute :) (count(WebsiteLink) le 1) or count(WebsiteLink) eq count(distinct-values(WebsiteLink/@language))"/>
		</xs:complexType>
		<xs:unique name="WebsiteDescription_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:WebsiteDescription"/>
			<xs:field xpath="@language"/>
		</xs:unique>
		<xs:unique name="WebsiteLink_language_attribute_must_be_unique" xmlns:onix="http://ns.editeur.org/onix/3.0/reference">
			<xs:selector xpath="onix:WebsiteLink"/>
			<xs:field xpath="@language"/>
		</xs:unique>
	</xs:element>
	<xs:element name="WebsiteDescription">
		<xs:annotation>
			<xs:documentation>Added language attribute at revision 3.0.6</xs:documentation>
		</xs:annotation>
		<xs:complexType mixed="true">
			<xs:complexContent>
				<xs:extension base="Flow">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="WebsiteDescription"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b294"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:attributeGroup ref="textformatAttribute"/>
					<xs:assert id="_20180517_b_57" test="(: Element must not be empty or consist solely of white space :) matches(., '\S')"/>
					<xs:assert id="_20180517_b_58" test="(: Element must not be empty or consist solely of white space and markup :) not(matches(@textformat, '^(02|03)$')) or matches(replace(., '(&lt;|&amp;lt;)/?[A-Za-z][^(>|&amp;gt;)]*(>|&amp;gt;)', ''), '\S')"/>
					<xs:assert id="_20180129_g_29" test="(: textformat attribute only allows values 02, 03, 05, 06, 07 :) not(exists(@textformat)) or matches(@textformat, '^(02|03|05|06|07)$')"/>
					<xs:assert id="_20180517_a_29" test="(: ASCII text must not contain extended characters :) not(exists(@textformat)) or (@textformat ne '07') or matches(., '^(\n|\r|\t|[ -~])+$')"/>
					<xs:assert id="_20171208_g_29" test="(: XHTML markup requires textformat attribute 05 :) (@textformat eq '05') or not(exists(child::*))"/>
					<xs:assert id="_20180129_f_29" test="(: No (X)HTML markup allowed with default text format or textformat attribute 06/07 :) matches(@textformat, '^(02|03|05)$') or not(matches(., '&lt;/?[A-Za-z][^>]*>'))"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="WebsiteLink">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.NonEmptyURI">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="WebsiteLink"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b295"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
					<xs:attributeGroup ref="languageAttribute"/>
					<xs:assert id="_20181210_a_3" test="(: URI must not contain an empty hostname :) not(matches(., '///'))"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="WebsiteRole">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List73">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="WebsiteRole"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b367"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="WorkIdentifier">
		<xs:complexType>
			<xs:sequence>
				<xs:element ref="WorkIDType"/>
				<xs:element minOccurs="0" ref="IDTypeName"/>
				<xs:element ref="IDValue"/>
			</xs:sequence>
			<xs:attribute name="refname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="WorkIdentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute name="shortname">
				<xs:simpleType>
					<xs:restriction base="xs:token">
						<xs:enumeration value="workidentifier"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="generalAttributes"/>
			<xs:assert id="_20171221_j_87" test="(: There must be an IDTypeName if (and only if) IDType is proprietary :) (WorkIDType eq '01') eq exists(IDTypeName)"/>
			<xs:assert id="_20171221_j_88" test="(: IDValue must be a valid ISBN-10 (invalid characters) :) (WorkIDType ne '02') or matches(IDValue, '^[0-9]{9}[0-9Xx]$')"/>
			<xs:assert id="_20171221_j_89" test="(: IDValue must be a valid ISBN-10 (check digit error) :) (WorkIDType ne '02') or not(matches(IDValue, '^[0-9]{9}[0-9Xx]$')) or (10 * number(substring(IDValue, 1, 1)) + 9 * number(substring(IDValue, 2, 1)) + 8 * number(substring(IDValue, 3, 1)) + 7 * number(substring(IDValue, 4, 1)) + 6 * number(substring(IDValue, 5, 1)) + 5 * number(substring(IDValue, 6, 1)) + 4 * number(substring(IDValue, 7, 1)) + 3 * number(substring(IDValue, 8, 1)) + 2 * number(substring(IDValue, 9, 1)) + (if (matches(substring(IDValue, 10, 1), '^(X|x)$')) then 10 else number(substring(IDValue, 10, 1)))) mod 11 eq 0"/>
			<xs:assert id="_20171221_j_90" test="(: IDValue must be a valid ISTC (invalid characters) :) (WorkIDType ne '11') or matches(IDValue, '^[0-9A-Fa-f]{3}2[0-9]{3}[0-9A-Fa-f]{9}$')"/>
			<xs:assert id="_20171221_j_91" test="(: IDValue must be a valid ISTC (check digit error) :) (WorkIDType ne '11') or not(matches(IDValue, '^[0-9A-Fa-f]{3}2[0-9]{3}[0-9A-Fa-f]{9}$')) or (11 * (string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 1, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 5, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 9, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 13, 1))))) + 9 * (string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 2, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 6, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 10, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 14, 1))))) + 3 * (string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 3, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 7, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 11, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 15, 1))))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 4, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 8, 1)))) + string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 12, 1))))) mod 16 eq string-length(substring-before('0123456789abcdef', lower-case(substring(IDValue, 16, 1))))"/>
			<xs:assert id="_20171221_j_92" test="(: IDValue must be a valid ISBN-13 (invalid characters) :) (WorkIDType ne '15') or matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')"/>
			<xs:assert id="_20171221_j_93" test="(: IDValue must be a valid ISBN-13 (check digit error) :) (WorkIDType ne '15') or not(matches(IDValue, '^(978[0-9]{10}|979[1-9][0-9]{9})$')) or (number(substring(IDValue, 1, 1)) + number(substring(IDValue, 3, 1)) + number(substring(IDValue, 5, 1)) + number(substring(IDValue, 7, 1)) + number(substring(IDValue, 9, 1)) + number(substring(IDValue, 11, 1)) + number(substring(IDValue, 13, 1)) + 3 * (number(substring(IDValue, 2, 1)) + number(substring(IDValue, 4, 1)) + number(substring(IDValue, 6, 1)) + number(substring(IDValue, 8, 1)) + number(substring(IDValue, 10, 1)) + number(substring(IDValue, 12, 1)))) mod 10 eq 0"/>
			<xs:assert id="_20171221_j_94" test="(: IDValue must be a plausible DOI (invalid structure) :) (WorkIDType ne '06') or matches(IDValue, '^10\.([1-9][0-9]*)(\.[0-9]+)?/.+$')"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="WorkIDType">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List16">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="WorkIDType"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b201"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="WorkRelationCode">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="List164">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="WorkRelationCode"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="x454"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:element name="YearOfAnnual">
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="dt.YearOrYearRange">
					<xs:attribute name="refname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="YearOfAnnual"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute name="shortname">
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="b020"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attributeGroup ref="generalAttributes"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<xs:group name="gp.record_metadata">
		<xs:annotation>
			<xs:documentation>Group of elements carrying infomation about the &lt;Product> record itself</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;MessageNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="RecordReference"/>
			<xs:element ref="NotificationType"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="DeletionText"/>
			<xs:element minOccurs="0" ref="RecordSourceType"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="RecordSourceIdentifier"/>
			<xs:element minOccurs="0" ref="RecordSourceName"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.product_numbers">
		<xs:annotation>
			<xs:documentation>Group of elements carrying one or more identifiers for the product</xs:documentation>
			<xs:documentation>Modified cardinality of &lt;MessageNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ProductIdentifier"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Barcode"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.unstructured_name">
		<xs:sequence>
			<xs:choice>
				<xs:sequence>
					<xs:element ref="PersonName"/>
					<xs:element minOccurs="0" ref="PersonNameInverted"/>
				</xs:sequence>
				<xs:element ref="PersonNameInverted"/>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.structured_name">
		<xs:sequence>
			<xs:element minOccurs="0" ref="TitlesBeforeNames"/>
			<xs:element minOccurs="0" ref="NamesBeforeKey"/>
			<xs:element minOccurs="0" ref="PrefixToKey"/>
			<xs:element ref="KeyNames"/>
			<xs:element minOccurs="0" ref="NamesAfterKey"/>
			<xs:element minOccurs="0" ref="SuffixToKey"/>
			<xs:element minOccurs="0" ref="LettersAfterNames"/>
			<xs:element minOccurs="0" ref="TitlesAfterNames"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.corporate_name">
		<xs:annotation>
			<xs:documentation>Added &lt;CorporateNameInverted> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:sequence>
				<xs:element ref="CorporateName"/>
				<xs:element minOccurs="0" ref="CorporateNameInverted"/>
			</xs:sequence>
			<xs:element ref="CorporateNameInverted"/>
		</xs:choice>
	</xs:group>
	<xs:group name="gp.product_form_core">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;ProductFormDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="ProductForm"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormDetail"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormFeature"/>
			<xs:element minOccurs="0" ref="ProductPackaging"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductFormDescription"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.product_form">
		<xs:annotation>
			<xs:documentation>Added &lt;EpubLicense> at revision 3.0.2</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="ProductComposition"/>
			<xs:group ref="gp.product_form_core"/>
			<xs:element minOccurs="0" ref="TradeCategory"/>
			<xs:element minOccurs="0" ref="PrimaryContentType"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductContentType"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Measure"/>
			<xs:element minOccurs="0" ref="CountryOfManufacture"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="EpubTechnicalProtection"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="EpubUsageConstraint"/>
			<xs:element minOccurs="0" ref="EpubLicense"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="MapScale"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductClassification"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductPart"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.collections">
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element maxOccurs="unbounded" ref="Collection"/>
				<xs:element ref="NoCollection"/>
			</xs:choice>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.titles">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="TitleDetail"/>
			<xs:sequence minOccurs="0">
				<xs:element ref="ThesisType"/>
				<xs:element minOccurs="0" ref="ThesisPresentedTo"/>
				<xs:element minOccurs="0" ref="ThesisYear"/>
			</xs:sequence>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.authorship">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;ContributorStatement> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="Contributor"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="ContributorStatement"/>
			</xs:sequence>
			<xs:element minOccurs="0" ref="NoContributor"/>
		</xs:choice>
	</xs:group>
	<xs:group name="gp.events">
		<xs:annotation>
			<xs:documentation>Added &lt;Event>, deprecated &lt;Conference> at revision 3.0.3</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Event"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Conference"/>
		</xs:choice>
	</xs:group>
	<xs:group name="gp.editions">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;EditionStatement> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:sequence>
					<xs:element minOccurs="0" maxOccurs="unbounded" ref="EditionType"/>
					<xs:sequence minOccurs="0">
						<xs:element ref="EditionNumber"/>
						<xs:element minOccurs="0" ref="EditionVersionNumber"/>
					</xs:sequence>
					<xs:element minOccurs="0" maxOccurs="unbounded" ref="EditionStatement"/>
				</xs:sequence>
				<xs:element minOccurs="0" ref="NoEdition"/>
			</xs:choice>
			<xs:element minOccurs="0" ref="ReligiousText"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.languages">
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Language"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.extents">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;IllustrationsNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Extent"/>
			<xs:element minOccurs="0" ref="Illustrated"/>
			<xs:element minOccurs="0" ref="NumberOfIllustrations"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="IllustrationsNote"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="AncillaryContent"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.subjects">
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Subject"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="NameAsSubject"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.audiences">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;AudienceDescription> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="AudienceCode"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Audience"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="AudienceRange"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="AudienceDescription"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Complexity"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.descriptions">
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="TextContent"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="CitedContent"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="SupportingResource"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.related_materials">
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="RelatedWork"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="RelatedProduct"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.prizes">
		<xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="Prize"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.imprints_publishers">
		<xs:annotation>
			<xs:documentation>Added &lt;ProductContact> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" ref="Imprint"/>
					<xs:element minOccurs="0" maxOccurs="unbounded" ref="Publisher"/>
				</xs:sequence>
				<xs:element maxOccurs="unbounded" ref="Publisher"/>
			</xs:choice>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="CityOfPublication"/>
			<xs:element minOccurs="0" ref="CountryOfPublication"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="ProductContact"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.publishing_status">
		<xs:annotation>
			<xs:documentation>Modified cardinality of &lt;PublishingStatusNote> at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:sequence minOccurs="0">
				<xs:element ref="PublishingStatus"/>
				<xs:element minOccurs="0" maxOccurs="unbounded" ref="PublishingStatusNote"/>
			</xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="PublishingDate"/>
			<xs:element minOccurs="0" ref="LatestReprintNumber"/>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="CopyrightStatement"/>
		</xs:sequence>
	</xs:group>
	<xs:group name="gp.rights_restrictions">
		<xs:annotation>
			<xs:documentation>Deprecated &lt;SalesRestriction> at revision 3.0.2</xs:documentation>
			<xs:documentation>Added &lt;ROWSalesRightsType> at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:sequence minOccurs="0">
				<xs:element maxOccurs="unbounded" ref="SalesRights"/>
				<xs:element minOccurs="0" ref="ROWSalesRightsType"/>
			</xs:sequence>
			<xs:element minOccurs="0" maxOccurs="unbounded" ref="SalesRestriction"/>
		</xs:sequence>
	</xs:group>
	<xs:simpleType name="dt.CountryCodeList">
		<xs:restriction>
			<xs:simpleType>
				<xs:list itemType="List91"/>
			</xs:simpleType>
			<xs:minLength value="1"/>
			<xs:assertion id="_20171126_h_1" test="(: Country codes must each be unique within the list :) count($value) eq count(distinct-values($value))"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.RegionCodeList">
		<xs:restriction>
			<xs:simpleType>
				<xs:list itemType="List49"/>
			</xs:simpleType>
			<xs:minLength value="1"/>
			<xs:assertion id="_20171126_h_2" test="(: WORLD cannot be included alongside other regions :) not($value = 'WORLD') or count($value) eq 1"/>
			<xs:assertion id="_20171126_h_3" test="(: Region codes must each be unique within the list :) count($value) eq count(distinct-values($value))"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.DateOrDateTime">
		<xs:union>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<!-- STRICT ensure only years 1900-2099 -->
					<xs:pattern value="(19|20)\d\d(0[1-9]|1[0-2])(0[1-9]|1[0-9]|2[0-8])(T([01][0-9]|2[0-3])[0-5][0-9]([0-5][0-9])?(Z|[+\-](0[0-9]|1[0-2])(00|15|30|45))?)?"/>
					<xs:pattern value="(19|20)\d\d(0[13-9]|1[0-2])(29|30)(T([01][0-9]|2[0-3])[0-5][0-9]([0-5][0-9])?(Z|[+\-](0[0-9]|1[0-2])(00|15|30|45))?)?"/>
					<xs:pattern value="(19|20)\d\d(0[13578]|1[02])31(T([01][0-9]|2[0-3])[0-5][0-9]([0-5][0-9])?(Z|[+\-](0[0-9]|1[0-2])(00|15|30|45))?)?"/>
					<xs:pattern value="19(0[48]|[13579][26]|[2468][048])0229(T([01][0-9]|2[0-3])[0-5][0-9]([0-5][0-9])?(Z|[+\-](0[0-9]|1[0-2])(00|15|30|45))?)?"/>
					<xs:pattern value="20(0[048]|[13579][26]|[2468][048])0229(T([01][0-9]|2[0-3])[0-5][0-9]([0-5][0-9])?(Z|[+\-](0[0-9]|1[0-2])(00|15|30|45))?)?"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="dt.Decimal">
		<xs:annotation>
			<xs:documentation>Datatype for any real number</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:decimal"/>
	</xs:simpleType>
	<xs:simpleType name="dt.PositiveDecimal">
		<xs:annotation>
			<xs:documentation>Datatype for zero or any positive real number</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:decimal">
			<xs:minInclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.StrictPositiveDecimal">
		<xs:annotation>
			<xs:documentation>Datatype for any positive real number (not including zero)</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:decimal">
			<xs:minExclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.PercentDecimal">
		<xs:annotation>
			<xs:documentation>Datatype for real number 0–100</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:decimal">
			<xs:minInclusive value="0"/>
			<xs:maxInclusive value="100"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.Integer">
		<xs:annotation>
			<xs:documentation>Datatype for any integer</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:int"/>
	</xs:simpleType>
	<xs:simpleType name="dt.PositiveInteger">
		<xs:annotation>
			<xs:documentation>Datatype for zero or any positive integer</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:nonNegativeInteger"/>
	</xs:simpleType>
	<xs:simpleType name="dt.StrictPositiveInteger">
		<xs:annotation>
			<xs:documentation>Datatype for any positive integer (not including zero)</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:positiveInteger"/>
	</xs:simpleType>
	<xs:simpleType name="dt.NonEmptyString">
		<xs:annotation>
			<xs:documentation>Datatype for non-empty string without leading or trailing white space</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<!-- STRICT ensure no leading or trailing whitespace -->
			<xs:pattern value="\S(.*\S)?"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.EmailString">
		<xs:annotation>
			<xs:documentation>Datatype for plausible e-mail address</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="[A-Za-z0-9_]+([\-+.'][A-Za-z0-9_]+)*@[A-Za-z0-9_]+([\-.][A-Za-z0-9_]+)*\.[A-Za-z0-9_]+([\-.][A-Za-z0-9_]+)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.RomanNumeralString">
		<xs:annotation>
			<xs:documentation>Datatype for Roman numerals (upper or lower case)</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="([MDCLXVI]+|[mdclxvi]+)"/>
		</xs:restriction>
	</xs:simpleType>
	
	<xs:simpleType name="dt.NonEmptyURI">
		<xs:annotation>
			<xs:documentation>Datatype for URI, ideally without leading or trailing white space</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:anyURI">
			<xs:pattern value="\S+"/>
			<xs:assertion id="_20210820_a_1" test="not(matches($value, '://')) or not(matches($value, '\P{IsBasicLatin}'))"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.Year">
		<xs:annotation>
			<xs:documentation>Datatype for year 1000 to 2099</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<!-- STRICT ensure only years 1000 to 2099 -->
			<xs:pattern value="(1[0-9]{3}|20[0-9]{2})"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.TimeOrDuration">
		<xs:restriction base="xs:string">
			<xs:pattern value="[0-9]{3}[0-5][0-9][0-5][0-9]([0-9]{2})?"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.YearOrYearRange">
		<xs:annotation>
			<xs:documentation>Datatype for year or range of years 1000-2099</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<!-- STRICT ensure only years 1000 to 2099 -->
			<xs:pattern value="(1[0-9]{3}|20[0-9]{2})(-(1[0-9]{3}|20[0-9]{2}))?"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.MultiLevelNumber">
		<xs:annotation>
			<xs:documentation>Datatype for string of dot-separated numbers, eg 3.12.8</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="\d+(\.\d+)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="dt.MultiLevelNumberOrHyphen">
		<xs:annotation>
			<xs:documentation>Datatype for string of dot-separated numbers where hyphen can replace a number, eg 3.-.8</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="(\d+|-)(\.(\d+|-))*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="releaseAttribute">
		<xs:annotation>
			<xs:documentation>Must be 3.0 for this release</xs:documentation>
		</xs:annotation>
		<xs:attribute name="release" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="3.0"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="collationkeyAttribute">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:attribute name="collationkey" type="dt.NonEmptyString"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="generalAttributes">
		<xs:attribute name="datestamp" type="dt.DateOrDateTime"/>
		<xs:attribute name="sourcetype" type="SourceTypeCode"/>
		<xs:attribute name="sourcename" type="dt.NonEmptyString"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="dateformatAttribute">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0 (2010)</xs:documentation>
		</xs:annotation>
		<xs:attribute name="dateformat" type="List55"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="languageAttribute">
		<xs:attribute name="language" type="List74"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="textcaseAttribute">
		<xs:attribute name="textcase" type="TextCaseCode"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="textformatAttribute">
		<xs:attribute name="textformat" type="TextFormatCode"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="textscriptAttribute">
		<xs:annotation>
			<xs:documentation>Added at revision 3.0.1</xs:documentation>
		</xs:annotation>
		<xs:attribute name="textscript" type="List121"/>
	</xs:attributeGroup>
</xs:schema>
